Sections:
00: "CODE" (0-AF5)


Source: "bios.asm"
                            	     1: ; Very simple cpm68k bios
                            	     2: ; Malcolm Harrow August 2023
                            	     3: 
                            	     4: _ccp               equ $150BC                           ; hard location for _ccp of CPM15000.SR
                            	     5: ramDriveLocation   equ $C0000                           ; memory location for RAM drive
                            	     6: DEBUG              set 1                                ; set to 1 to print debug messgae, 0 turns off  
                            	     7: 
                            	     8: ; pass in a character to this routine and print it out
                            	     9: ; use to track progress through the code in debug ..
                            	    10: debugPrintChar MACRO
                            	    11:     IFNE DEBUG
                            	    12:         movem.l D0-D3/A0-A3,-(A7)
                            	    13: 
                            	    14:         moveq.l #6,D0                                   
                            	    15:         move.b  #\1,D1                                     
                            	    16:         trap    #15
                            	    17:     
                            	    18:         movem.l (A7)+,D0-D3/A0-A3
                            	    19:     ENDIF
                            	    20: ENDM
                            	    21: 
                            	    22: ; print sector information read from / written to a SD disk image (or real SD card)
                            	    23: ; pass in a character to this routine to specify type of operation on the sector eg 'R' or 'W'
                            	    24: debugPrintSector MACRO
                            	    25:     IFNE DEBUG
                            	    26:         movem.l D0-D3/A0-A3,-(A7)
                            	    27: 
                            	    28:         moveq.l #6,D0                                   
                            	    29:         move.b  #\1,D1                                     
                            	    30:         trap    #15
                            	    31:     
                            	    32:         moveq.l #15,D0
                            	    33:         move.l  (lastFATSector),D1                          ; sector in hex
                            	    34:         move.b  #16,D2
                            	    35:         trap    #15
                            	    36: 
                            	    37:         moveq.l #6,D0
                            	    38:         move.b  #'-',D1                                    
                            	    39:         trap    #15
                            	    40: 
                            	    41:         moveq.l #15,D0
                            	    42:         move.l  D3,D1                                       ; offset on sector in hex
                            	    43:         move.b  #16,D2
                            	    44:         trap    #15
                            	    45: 
                            	    46:         moveq.l #6,D0
                            	    47:         move.b  #'-',D1                                     
                            	    48:         trap    #15
                            	    49: 
                            	    50:         moveq.l #15,D0
                            	    51:         move.l  (DMA),D1                          ; sector in hex
                            	    52:         move.b  #16,D2
                            	    53:         trap    #15
                            	    54: 
                            	    55:         moveq.l #6,D0
                            	    56:         move.b  #' ',D1                                     
                            	    57:         trap    #15
                            	    58: 
                            	    59:         movem.l (A7)+,D0-D3/A0-A3
                            	    60:     ENDIF
                            	    61: ENDM
                            	    62: 
                            	    63: ; print sector information read from / written to a RAM disk
                            	    64: ; pass in a character to this routine to specify type of operation on the RAM drive eg 'R' or 'W'
                            	    65: ; Assuem A0 is already set up to point to the RAM being moved
                            	    66: debugPrintRAM MACRO
                            	    67:     IFNE DEBUG
                            	    68:         movem.l D0-D3/A0-A3,-(A7)
                            	    69: 
                            	    70:         exg     A0,A3                                       ; save A0 as trap 15 trashes it
                            	    71:         moveq.l #6,D0                                   
                            	    72:         move.b  #\1,D1                                     
                            	    73:         trap    #15
                            	    74:         exg     A3,A0
                            	    75: 
                            	    76:         moveq.l #15,D0
                            	    77:         move.l  A0,D1                                       ; address in hex
                            	    78:         move.b  #16,D2
                            	    79:         trap    #15
                            	    80: 
                            	    81:         moveq.l #6,D0
                            	    82:         move.b  #'-',D1                                     
                            	    83:         trap    #15
                            	    84: 
                            	    85:         moveq.l #15,D0
                            	    86:         move.l  (DMA),D1                          ; sector in hex
                            	    87:         move.b  #16,D2
                            	    88:         trap    #15
                            	    89: 
                            	    90:         moveq.l #6,D0
                            	    91:         move.b  #' ',D1                                     
                            	    92:         trap    #15
                            	    93: 
                            	    94:         movem.l (A7)+,D0-D3/A0-A3
                            	    95:     ENDIF
                            	    96: ENDM
                            	    97: 
                            	    98: _init::    
                            	    99:     ; at this stage, we have loaded from the SDCARD, so we know its valid, no need to re-init
                            	   100:     ; need to find the starting sector of the CPM disk image on the sd card.
                            	   101:     ; To do this we will trawl through the FAT32 boot record etc
                            	   102: 
                            	   103:     ; to do this:
                            	   104:     ;   - read the MBR, block 0 and note:
                            	   105:     ;     - number of reserved sectors, 0x0E, word (eg 20 00)
                            	   106:     ;     - logical sectors per FAT, 0x24, long  (eg f1 03 00 00)
                            	   107:     ;     - number of fats, 0x10, byte (eg 02)
                            	   108:     ;   - This enables us to calculate:
                            	   109:     ;     - start of FAT table (sector after number of reserved sectors - 32 or 0x4000
                            	   110:     ;     - start of root directory,  Logical sectors per FAT (0x24) * Number of FATs (0x10) + Reserved logical sectors
                            	   111:     ;   - The root directory is arranged 32 bytes per entry.  We will assume our CPM disk image is in the root and call
                            	   112:     
                            	   113:     ; check sd card support
00:00000000 7000            	   114:     moveq.l #0,D0
00:00000002 4E4D            	   115:     trap    #13
00:00000004 B0BC1234FEDC    	   116:     cmp.l   #$1234FEDC,D0                               ; check magic return
00:0000000A 6708            	   117:     beq     .haveSDsupport
00:0000000C 41FA0A18        	   118:     lea     msgNoSdCardSupport,A0
00:00000010 6000013E        	   119:     jmp     .errExit
                            	   120:     
                            	   121: .haveSDsupport:
                            	   122:     ; init the sd card and get sd card structure back
00:00000014 43FA09AE        	   123:     lea     sd,A1
00:00000018 7001            	   124:     moveq.l #1,D0                                       
00:0000001A 4E4D            	   125:     trap    #13
00:0000001C 4A80            	   126:     cmp.l   #0,D0                                       ; check return
00:0000001E 6708            	   127:     beq     .haveSDinit
00:00000020 41FA0A27        	   128:     lea     msgNoSdCardInit,A0
00:00000024 6000012A        	   129:     jmp     .errExit
                            	   130: 
                            	   131: .haveSDinit:
                            	   132:     ; read the MBR from sector 0 on the disk so we can read the partition table
00:00000028 43FA099A        	   133:     lea     sd,A1
00:0000002C 7002            	   134:     moveq.l #2,D0                                       ; read the MBR from the sd card 
00:0000002E 7200            	   135:     moveq.l #0,D1                                       ; sector number to read
00:00000030 45FA0792        	   136:     lea     sdBuf,A2
00:00000034 4E4D            	   137:     trap    #13
00:00000036 4A80            	   138:     cmp.l   #0,D0                                       ; check return
00:00000038 6608            	   139:     bne     .haveReadDiskMBR
00:0000003A 41FA0A31        	   140:     lea     msgNoSdCardRead,A0
00:0000003E 60000110        	   141:     jmp     .errExit
                            	   142: 
                            	   143: .haveReadDiskMBR:
                            	   144:     ; now we need to check the disk MBR for a partition table and get the offset to the first partition
                            	   145:     ; this is a bodge .. CPM has to be on the first partition, partiton 0 and 0x1BE on the disk MBR
                            	   146:     ; The code should really check all 4 partitions ..
                            	   147: 
                            	   148:     ; as we read longs and words off of the MBR we have to take endianess into account and switch the byte order 
                            	   149:     ; as we are on the 68000 CPU
00:00000042 2C3A0946        	   150:     move.l  $1c6+sdBuf,D6                               ; read LBA start from partition 0
00:00000046 E15E            	   151:     rol.w   #8,D6
00:00000048 4846            	   152:     swap    D6
00:0000004A E15E            	   153:     rol.w   #8,D6
00:0000004C 23C600000A04    	   154:     move.l  D6,partStartSector
                            	   155: 
                            	   156:     ; read the MBR from sector 0 of the partition so we can calculate position of the root diectory and hence the CPM i
00:00000052 43FA0970        	   157:     lea     sd,A1
00:00000056 7002            	   158:     moveq.l #2,D0                                       ; read the MBR from the sd card 
00:00000058 2206            	   159:     move.l  D6,D1                                       ; sector number to read - partStartSector
00:0000005A 45FA0768        	   160:     lea     sdBuf,A2
00:0000005E 4E4D            	   161:     trap    #13
00:00000060 4A80            	   162:     cmp.l   #0,D0                                       ; check return
00:00000062 6608            	   163:     bne     .haveReadPartMBR
00:00000064 41FA0A07        	   164:     lea     msgNoSdCardRead,A0
00:00000068 600000E6        	   165:     jmp     .errExit
                            	   166: 
                            	   167: .haveReadPartMBR
                            	   168: 
00:0000006C 3C3A0764        	   169:     move.w  $e+sdBuf,D6                                 ; number of reserved sectors from MBR.  Reversed due to endiane
00:00000070 E15E            	   170:     rol.w   #8,D6
00:00000072 33C600000A0E    	   171:     move.w  D6,reservedSectors
                            	   172: 
00:00000078 2C3A0776        	   173:     move.l  $2c+sdBuf,D6                                ; read root director cluster (usually 2)
00:0000007C E15E            	   174:     rol.w   #8,D6
00:0000007E 4846            	   175:     swap    D6
00:00000080 E15E            	   176:     rol.w   #8,D6
00:00000082 23C600000A08    	   177:     move.l  D6,rootDirectoryCluster
                            	   178: 
                            	   179:     ; up until the root directory, we use sectors; after the root directory we have to deal with clusters (groups of se
                            	   180:     ; see the diagram here: https://eric-lo.gitbook.io/lab9-filesystem/overview-of-fat32#
                            	   181:     ; we need to store the number of sectors per cluster for later use
00:00000088 7C00            	   182:     moveq.l #0,D6
00:0000008A 1C3A0745        	   183:     move.b  $d+sdBuf,D6                                 ; read number of sectors per cluster
00:0000008E 33C600000A10    	   184:     move.w  D6,sectorsPerCluster                        ; save as a word for later mulu
                            	   185: 
                            	   186:     ; Calculate the sector of the root directory: 
                            	   187:     ; = sectors per FAT * number of FATs + number of reserved sectors
                            	   188:     ; += partStartSector to allow for the start of the partition on the disk
00:00000094 2A3A0752        	   189:     move.l  $24+sdBuf,D5                                ; read sectors per FAT
00:00000098 E15D            	   190:     rol.w   #8,D5
00:0000009A 4845            	   191:     swap    D5
00:0000009C E15D            	   192:     rol.w   #8,D5
                            	   193:     
00:0000009E 7C00            	   194:     moveq.l #0,D6                                       ; read number of FAT tables
00:000000A0 1C3A0732        	   195:     move.b  $10+sdBuf,D6
                            	   196: 
00:000000A4 CCC5            	   197:     mulu.w  D5,D6
00:000000A6 DC7A0966        	   198:     add.w   reservedSectors,D6
00:000000AA DCBA0958        	   199:     add.l   partStartSector,D6                          ; partStartSector is a long
00:000000AE 33C600000A0C    	   200:     move.w  D6,rootDirectorySector
                            	   201: 
                            	   202: 
                            	   203: ;    sector = sector of start of root directory
                            	   204: ;    entry = 0
                            	   205: ;    while (1) {
                            	   206: ;      offset = entry % 16
                            	   207: ;      if offset == 0 {
                            	   208: ;        // read next sector
                            	   209: ;        read next sector
                            	   210: ;        increment sector
                            	   211: ;      };;
                            	   212: ;
                            	   213: ;      directory_entry = offset * 32 plus buffer start
                            	   214: ;
                            	   215: ;      if directory_entry[0] == 0 { // end of root directory
                            	   216: ;        message failure
                            	   217: ;        return failure
                            	   218: ;      }
                            	   219: ;
                            	   220: ;      if directory_entry[0xb] & 0x10 { // subdirectory
                            	   221: ;        continue
                            	   222: ;      }
                            	   223: ;
                            	   224: ;      if directory entry[0xb] == 0xf { // record contains a long file name
                            	   225: ;        continue
                            	   226: ;      }
                            	   227: ;
                            	   228: ;      if strncmp(directory entry, "CPMDISK IMG", 11) {
                            	   229: ;        // found file, might have to ignore case here, lets see
                            	   230: ;        // record sector file starts and file length
                            	   231: ;        block = entry[20,21] << 16 + entry[26,27]
                            	   232: ;        // both of these are store lsb first eg length of 0x7e84 is stored 84 7e 00 00
                            	   233: ;        return success
                            	   234: ;      }
                            	   235: ;      entry++
                            	   236: ;    }
                            	   237: 
                            	   238: 
                            	   239:     ; search the FAT to try to find the CPM disk image
00:000000B4 7600            	   240:     moveq.l #0,D3                                       ; sector to read
00:000000B6 7800            	   241:     moveq.l #0,D4                                       ; directory entry in sector.  Sector is 512b, directory table i
                            	   242: 
                            	   243: .startDirectoryEntry:
00:000000B8 2A04            	   244:     move.l  D4,D5
00:000000BA CABC0000000F    	   245:     and.l   #15,D5                                      ; only look at last 4 bits, we want to calculate (directory ent
00:000000C0 6620            	   246:     bne     .noReadRequired                             ; we dont need to read a new sector from the sd card
                            	   247: 
                            	   248:     ; read the MBR from sector 0 so we can calculate position of the MBR and root diectory in the CPM image
00:000000C2 43FA0900        	   249:     lea     sd,A1
00:000000C6 7002            	   250:     moveq.l #2,D0                                       ; read sector trap
00:000000C8 323A0942        	   251:     move.w  rootDirectorySector,D1
00:000000CC D243            	   252:     add.w   D3,D1                                       ; sector number to read plus offset to rootDirectoryCluster
00:000000CE 45FA06F4        	   253:     lea     sdBuf,A2
00:000000D2 4E4D            	   254:     trap    #13
00:000000D4 4A80            	   255:     cmp.l   #0,D0                                       ; check return
00:000000D6 6606            	   256:     bne     .noReadError
00:000000D8 41FA0993        	   257:     lea     msgNoSdCardRead,A0
00:000000DC 6072            	   258:     jmp     .errExit
                            	   259: 
                            	   260: .noReadError:
00:000000DE 5283            	   261:     addq.l  #1,D3                                       ; increment next sector to read
00:000000E0 7800            	   262:     moveq.l #0,D4                                       ; reset directory entry to zero 
                            	   263: 
                            	   264: .noReadRequired:
00:000000E2 2A04            	   265:     move.l  D4,D5                                       ; D4 contains directory record
00:000000E4 EB8D            	   266:     lsl.l   #5,D5                                       ; multiply offset by 32 to get to start of directory record
00:000000E6 DABC000007C4    	   267:     add.l   #sdBuf,D5
00:000000EC 2A45            	   268:     movea.l D5,A5
00:000000EE 1C15            	   269:     move.b  (A5),D6
00:000000F0 4A06            	   270:     tst.b   D6                                          ; reached end of root directory entries
00:000000F2 6606            	   271:     bne     .notDirEnd
00:000000F4 41FA09B4        	   272:     lea     msgNoCPMImage,A0
00:000000F8 6056            	   273:     jmp     .errExit
                            	   274: 
                            	   275: .notDirEnd:
00:000000FA 1C2D000B        	   276:     move.b  $b(A5),D6
00:000000FE BC3C0010        	   277:     cmp.b   #$10,D6
00:00000102 6746            	   278:     beq     .nextDir                                    ; skip subdirectories entries
00:00000104 BC3C000F        	   279:     cmp.b   #$f,D6
00:00000108 6740            	   280:     beq     .nextDir                                    ; skip long filename entries
                            	   281: 
                            	   282:     ; check to see if we have found the CPM Image file
                            	   283:     ; The name CPMDISK.IMG is stored as "CPMDISK " then "IMG" in FAT32
00:0000010A 49FA090E        	   284:     LEA     imageName,A4
00:0000010E BB8C            	   285:     cmp.l   (A4)+,(A5)+
00:00000110 6638            	   286:     bne     .nextDir
                            	   287:     
00:00000112 BB8C            	   288:     cmp.l   (A4)+,(A5)+
00:00000114 6634            	   289:     bne     .nextDir
                            	   290:     
00:00000116 2C15            	   291:     move.l  (A5),D6                                      ; wipe last byte from FAT to compare to 0 from imageName
00:00000118 4206            	   292:     clr.b   D6
00:0000011A BC94            	   293:     cmp.l   (A4),D6
00:0000011C 662C            	   294:     bne     .nextDir
                            	   295: 
                            	   296:     ; found file, A5 will now be pointing at entry[8] so adjust offsets to compensate
                            	   297:     ;        block = entry[20,21] << 16 + entry[26,27]
                            	   298:     ; get starting block of CPMDISK.IMG
00:0000011E 3C2D000C        	   299:     move.w  $c(A5),D6                                   
00:00000122 E15E            	   300:     rol.w   #8,D6
00:00000124 4846            	   301:     swap    D6
00:00000126 3C2D0012        	   302:     move.w  $12(A5),D6
00:0000012A E15E            	   303:     rol.w   #8,D6
                            	   304: 
00:0000012C 9CBA08DA        	   305:     sub.l   (rootDirectoryCluster),D6                   ; allow for the position of the root directory (usually 2)
00:00000130 CCFA08DE        	   306:     mulu.w  (sectorsPerCluster),D6  
                            	   307: 
                            	   308:     ; for efficiency we will point CPMImageSector at the actual block on the sd card
00:00000134 DC7A08D6        	   309:     add.w  (rootDirectorySector),D6
00:00000138 23C600000A12    	   310:     move.l D6,CPMImageSector
                            	   311: 
00:0000013E 21FC00000158008C	   312:     move.l  #TRAPHNDL,$8c                               ; set up trap #3 handler
00:00000146 7000            	   313:     moveq.l #0,D0                                       ; log on disk A, user 0
00:00000148 4E75            	   314:     rts
                            	   315: 
                            	   316: .nextDir:
00:0000014A 5284            	   317:     addq.l  #1,D4                                       ; look at next directory entry
00:0000014C 6000FF6A        	   318:     jmp     .startDirectoryEntry
                            	   319: 
                            	   320: .errExit:
00:00000150 7201            	   321:     moveq.l #1,D1                                       ; Func code is 1 PRINTLN, A0 preloaded with address of error me
00:00000152 4E4E            	   322:     trap    #14                          
00:00000154 7001            	   323:     moveq.l #1,D0                                       ; signal error
00:00000156 4E75            	   324:     rts
                            	   325: 
                            	   326: TRAPHNDL:
00:00000158 0C400017        	   327:     cmpi    #23,D0                                      ; Function call in range ?
00:0000015C 6408            	   328:     bcc     TRAPNG
                            	   329: 
00:0000015E E588            	   330:     lsl.l   #2,D0                                       ; change function call to offset by multiplting by 4
00:00000160 207B0006        	   331:     move.l  BIOSBASE(PC,D0),A0          ; ... and calc offset into table...
00:00000164 4E90            	   332:     jsr     (A0)                        ; ... then jump there
                            	   333: 
                            	   334: TRAPNG:
00:00000166 4E73            	   335:     rte
                            	   336: 
                            	   337: BIOSBASE:
00:00000168 00000000        	   338:     dc.l    _init
00:0000016C 000001C4        	   339:     dc.l    WBOOT
00:00000170 000001CA        	   340:     dc.l    CONSTAT
00:00000174 000001D4        	   341:     dc.l    CONIN
00:00000178 000001E2        	   342:     dc.l    CONOUT
00:0000017C 000001E8        	   343:     dc.l    LSTOUT
00:00000180 000001E8        	   344:     dc.l    PUN
00:00000184 000001E8        	   345:     dc.l    RDR
00:00000188 000001F2        	   346:     dc.l    HOME
00:0000018C 000001FA        	   347:     dc.l    SELDSK
00:00000190 0000021E        	   348:     dc.l    SETTRK
00:00000194 00000226        	   349:     dc.l    SETSEC
00:00000198 00000232        	   350:     dc.l    SETDMA
00:0000019C 0000024C        	   351:     dc.l    READ
00:000001A0 000003CE        	   352:     dc.l    WRITE
00:000001A4 000001EC        	   353:     dc.l    LISTST
00:000001A8 0000022E        	   354:     dc.l    SECTRAN
00:000001AC 0000023A        	   355:     dc.l    SETDMA2
00:000001B0 000004A6        	   356:     dc.l    GETSEG
00:000001B4 000001E8        	   357:     dc.l    GETIOB
00:000001B8 000001E8        	   358:     dc.l    SETIOB
00:000001BC 000004A2        	   359:     dc.l    FLUSH
00:000001C0 000004AE        	   360:     dc.l    SETEXC
                            	   361: 
                            	   362: 
                            	   363: WBOOT:  
00:000001C4 4EF9000150BC    	   364:     jmp     _ccp
                            	   365: 
                            	   366: CONSTAT: 
                            	   367: ; Check for keyboard input. Set d0 to 1 if keyboard input is pending, otherwise set to 0.
00:000001CA 7007            	   368:     moveq.l #7,D0                        ; use EASy68k trap 15 task 7
00:000001CC 4E4F            	   369:     trap    #15                          ; d1.b = 1 if keyboard ready, otherwise = 0
00:000001CE 7000            	   370:     moveq.l #0,D0
00:000001D0 1001            	   371:     move.b  D1,D0
00:000001D2 4E75            	   372:     rts
                            	   373: 
                            	   374: CONIN:    
                            	   375: ; Read single ASCII character from the keyboard into d0
                            	   376: ; Rosco implementation of this trap waits for input
00:000001D4 7005            	   377:     moveq.l #5,D0                        ; use EASy68k trap 15 task 5
00:000001D6 4E4F            	   378:     trap    #15                          ; d1.b contains the ascii character
00:000001D8 1001            	   379:     move.b  D1,D0      
00:000001DA C0BC0000007F    	   380:     and.l   #$7f,D0                      ; only use 7 bit character set
00:000001E0 4E75            	   381:     rts
                            	   382: 
                            	   383: CONOUT: 
                            	   384: ; Display single ASCII character in d1
00:000001E2 7006            	   385:     moveq.l #6,D0                        ; use EASy68k trap 15 task 6
00:000001E4 4E4F            	   386:     trap    #15
00:000001E6 4E75            	   387:     rts                                  ; and exit
                            	   388: 
                            	   389: LSTOUT:    
                            	   390: PUN:
                            	   391: RDR:
                            	   392: GETIOB:
                            	   393: SETIOB:
00:000001E8 7000            	   394:     moveq.l #0,D0
00:000001EA 4E75            	   395:     rts
                            	   396: 
                            	   397: LISTST:    
00:000001EC 103C00FF        	   398:     move.b #$ff,D0
00:000001F0 4E75            	   399:     rts
                            	   400: 
                            	   401: HOME:    
00:000001F2 4279000004DA    	   402:     clr.w  TRACK
00:000001F8 4E75            	   403:     rts
                            	   404: 
                            	   405: SELDSK:    
                            	   406: ; drive should be in d1.b
00:000001FA B23C0001        	   407:     cmp.b   #1,D1
00:000001FE 670E            	   408:     beq     .seldrive1     
00:00000200 4239000004D8    	   409:     move.b  #0,SELDRV
00:00000206 203C000004EE    	   410:     move.l  #DPH0,D0
00:0000020C 4E75            	   411:     rts
                            	   412: 
                            	   413: .seldrive1
00:0000020E 13FC0001000004D8	   414:     move.b  #1,SELDRV
00:00000216 203C00000518    	   415:     move.l  #DPH1,D0
00:0000021C 4E75            	   416:     rts
                            	   417: 
                            	   418: SETTRK:    
00:0000021E 33C1000004DA    	   419:     move.w  D1,TRACK
00:00000224 4E75            	   420:     rts
                            	   421: 
                            	   422: SETSEC:    
00:00000226 33C1000004DC    	   423:     move.w  D1,SECTOR
00:0000022C 4E75            	   424:     rts
                            	   425: 
                            	   426: SECTRAN:
                            	   427: ;    no sector translate, put d1 into d0 and return
00:0000022E 3001            	   428:     move.w  D1,D0
00:00000230 4E75            	   429:     rts
                            	   430: 
                            	   431: SETDMA:
00:00000232 23C1000004DE    	   432:     move.l  D1,DMA
00:00000238 4E75            	   433:     rts
                            	   434: 
                            	   435: SETDMA2:
                            	   436:     debugPrintChar '*'
                            	     1M     IFNE DEBUG
00:0000023A 48E7F0F0        	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
00:0000023E 7006            	     4M         moveq.l #6,D0                                   
00:00000240 123C002A        	     5M         move.b  #'*',D1                                     
00:00000244 4E4F            	     6M         trap    #15
                            	     7M     
00:00000246 4CDF0F0F        	     8M         movem.l (A7)+,D0-D3/A0-A3
                            	     9M     ENDIF
00:0000024A 4E75            	   437:     rts
                            	   438: 
                            	   439: READ:
                            	   440: ; Read one cpm sector from requested disk, track, sector to dma address
                            	   441: ; Can be a cpmimage on the sd card or the ram disk
00:0000024C 4A39000004D8    	   442:     cmp.b   #0,SELDRV
00:00000252 6612            	   443:     bne     .readRAMDrive
                            	   444: 
00:00000254 617C            	   445:     bsr     setupReadDisk                               ; sets A0 to point to the right 128 bytes in memory, potentiall
00:00000256 227A0286        	   446:     move.l  DMA,A1
00:0000025A 701F            	   447:     move.l  #(128/4-1),D0  
                            	   448: 
                            	   449: .MOVE_LOOP1:
00:0000025C 22D8            	   450:     MOVE.L  (A0)+,(A1)+                                 ; copy long word from source to dest
00:0000025E 51C8FFFC        	   451:     dbra    D0,.MOVE_LOOP1
                            	   452:     
00:00000262 7000            	   453:     moveq.l #0,D0                                       ; return OK status         
00:00000264 4E75            	   454:     rts
                            	   455: 
                            	   456: .readRAMDrive:
00:00000266 614A            	   457:     bsr     setupReadRAM                                ; sets A0 to point to the right 128 bytes in memory to read
                            	   458:     debugPrintRAM 'R'
                            	     1M     IFNE DEBUG
00:00000268 48E7F0F0        	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
00:0000026C C14B            	     4M         exg     A0,A3                                       ; save A0 as trap 15 trashes it
00:0000026E 7006            	     5M         moveq.l #6,D0                                   
00:00000270 123C0052        	     6M         move.b  #'R',D1                                     
00:00000274 4E4F            	     7M         trap    #15
00:00000276 C748            	     8M         exg     A3,A0
                            	     9M 
00:00000278 700F            	    10M         moveq.l #15,D0
00:0000027A 2208            	    11M         move.l  A0,D1                                       ; address in hex
00:0000027C 143C0010        	    12M         move.b  #16,D2
00:00000280 4E4F            	    13M         trap    #15
                            	    14M 
00:00000282 7006            	    15M         moveq.l #6,D0
00:00000284 123C002D        	    16M         move.b  #'-',D1                                     
00:00000288 4E4F            	    17M         trap    #15
                            	    18M 
00:0000028A 700F            	    19M         moveq.l #15,D0
00:0000028C 223A0250        	    20M         move.l  (DMA),D1                          ; sector in hex
00:00000290 143C0010        	    21M         move.b  #16,D2
00:00000294 4E4F            	    22M         trap    #15
                            	    23M 
00:00000296 7006            	    24M         moveq.l #6,D0
00:00000298 123C0020        	    25M         move.b  #' ',D1                                     
00:0000029C 4E4F            	    26M         trap    #15
                            	    27M 
00:0000029E 4CDF0F0F        	    28M         movem.l (A7)+,D0-D3/A0-A3
                            	    29M     ENDIF
00:000002A2 227A023A        	   459:     move.l  DMA,A1
00:000002A6 701F            	   460:     move.l  #(128/4-1),d0  
                            	   461: 
                            	   462: .MOVE_LOOP2:
00:000002A8 22D8            	   463:     MOVE.L  (A0)+,(A1)+                                 ; copy long word from source to dest
00:000002AA 51C8FFFC        	   464:     dbra    D0,.MOVE_LOOP2
                            	   465: 
00:000002AE 7000            	   466:     moveq.l #0,D0                                       ; return OK status         
00:000002B0 4E75            	   467:     rts         
                            	   468: 
                            	   469: setupReadRAM:
                            	   470: ; translate track/sector into RAM location on the RAM drive
00:000002B2 7000            	   471:     moveq.l #0,D0
00:000002B4 303A0224        	   472:     move.w  TRACK,D0
00:000002B8 760C            	   473:     moveq.l #12,D3                                      ; much faster than shifting by 8 then 4 (40 versus 12 cycles)
00:000002BA E7A8            	   474:     lsl.l   D3,D0
                            	   475: 
00:000002BC 7400            	   476:     moveq.l #0,D2
00:000002BE 343A021C        	   477:     move.w  SECTOR,D2
00:000002C2 7607            	   478:     moveq.l #7,D3                                       ; much faster than shifting by 7 (22 versus 12 cycles)
00:000002C4 E7AA            	   479:     lsl.l   D3,D2
                            	   480: 
00:000002C6 D082            	   481:     add.l   D2,D0
00:000002C8 D0BC000C0000    	   482:     add.l   #ramDriveLocation,D0                        ; add base address of RAM drive
00:000002CE 2040            	   483:     movea.l D0,A0                                       ; point to the track/sector in RAM drive
00:000002D0 4E75            	   484:     rts
                            	   485: 
                            	   486: setupReadDisk:
                            	   487: ;
                            	   488: ; algorithm
                            	   489: ;
                            	   490: ; keep 512b in a memory buffer
                            	   491: ; keep sector number of the data currently in the buffer
                            	   492: ;
                            	   493: ; if requested sector not in buffer {
                            	   494: ;     calcuate the sector and offset that the FAT entry for the sector is located in
                            	   495: ;     read sector pointed to in FAT table from disk into buffer
                            	   496: ;     note requested sector in buffer
                            	   497: ; }
                            	   498: ;
                            	   499: ; calculate offset of CPM 128b required in 512b buffer
                            	   500: ; copy the correct 12b across into the CPM dma area
                            	   501: 
                            	   502:     ; start by calculating the requested (FAT32) sector number from TRACK and SECTOR in D0
                            	   503:     ; also calculate the offset into that 512b buffer for the 128b CPM sector data in D3
00:000002D2 7200            	   504:     moveq.l #0,D1
00:000002D4 323A0204        	   505:     move.w  TRACK,D1
00:000002D8 E789            	   506:     lsl.l   #3,D1
                            	   507: 
00:000002DA 7400            	   508:     moveq.l #0,D2
00:000002DC 343A01FE        	   509:     move.w  SECTOR,D2
                            	   510: 
00:000002E0 2602            	   511:     move.l  D2,D3
00:000002E2 C6BC00000003    	   512:     and.l   #3,D3                                       ; use D3 to calculate the offset of the 128b CPM sector in the 
00:000002E8 7807            	   513:     moveq.l #7,D4                                       ; much faster than shifting by 7 (22 versus 12 cycles)
00:000002EA E9AB            	   514:     lsl.l   D4,D3
                            	   515: 
00:000002EC E48A            	   516:     lsr.l   #2,D2
00:000002EE D282            	   517:     add.l   D2,D1                                        ; D1 now has the requested sector number
00:000002F0 D2BA0720        	   518:     add.l   (CPMImageSector),D1                          ; D1 now has the actual sector on the SD card
                            	   519: 
                            	   520:     ; check to see if this FAT32 sector already in memory
00:000002F4 B2BA0720        	   521:     cmp.l (lastFATSector),D1
00:000002F8 670000CC        	   522:     beq   .noDiskReadRequired
                            	   523: 
                            	   524:     ; we are going to read the sector (hopefully) so update the last read FAT sector before we lose the contents of D1
00:000002FC 23C100000A16    	   525:     move.l D1,lastFATSector
                            	   526: 
                            	   527:     ; we assume that the FAT table is contiguous for the CP/M image
                            	   528:     ; file, this avoids a walk of the FAT table linked list .. but wont deal with any bad sectors on the sd card
                            	   529: 
00:00000302 43FA06C0        	   530:     lea     sd,A1
00:00000306 7002            	   531:     moveq.l #2,D0                                        ; read sector function code
00:00000308 45FA04BA        	   532:     lea     sdBuf,A2
00:0000030C 4E4D            	   533:     trap    #13
00:0000030E 4A80            	   534:     cmp.l   #0,D0                                        ; check return
00:00000310 666A            	   535:     bne     .noDiskReadError
                            	   536: 
                            	   537:     ; if we get here we had a disk read error
                            	   538:     debugPrintSector 'E'
                            	     1M     IFNE DEBUG
00:00000312 48E7F0F0        	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
00:00000316 7006            	     4M         moveq.l #6,D0                                   
00:00000318 123C0045        	     5M         move.b  #'E',D1                                     
00:0000031C 4E4F            	     6M         trap    #15
                            	     7M     
00:0000031E 700F            	     8M         moveq.l #15,D0
00:00000320 223A06F4        	     9M         move.l  (lastFATSector),D1                          ; sector in hex
00:00000324 143C0010        	    10M         move.b  #16,D2
00:00000328 4E4F            	    11M         trap    #15
                            	    12M 
00:0000032A 7006            	    13M         moveq.l #6,D0
00:0000032C 123C002D        	    14M         move.b  #'-',D1                                    
00:00000330 4E4F            	    15M         trap    #15
                            	    16M 
00:00000332 700F            	    17M         moveq.l #15,D0
00:00000334 2203            	    18M         move.l  D3,D1                                       ; offset on sector in hex
00:00000336 143C0010        	    19M         move.b  #16,D2
00:0000033A 4E4F            	    20M         trap    #15
                            	    21M 
00:0000033C 7006            	    22M         moveq.l #6,D0
00:0000033E 123C002D        	    23M         move.b  #'-',D1                                     
00:00000342 4E4F            	    24M         trap    #15
                            	    25M 
00:00000344 700F            	    26M         moveq.l #15,D0
00:00000346 223A0196        	    27M         move.l  (DMA),D1                          ; sector in hex
00:0000034A 143C0010        	    28M         move.b  #16,D2
00:0000034E 4E4F            	    29M         trap    #15
                            	    30M 
00:00000350 7006            	    31M         moveq.l #6,D0
00:00000352 123C0020        	    32M         move.b  #' ',D1                                     
00:00000356 4E4F            	    33M         trap    #15
                            	    34M 
00:00000358 4CDF0F0F        	    35M         movem.l (A7)+,D0-D3/A0-A3
                            	    36M     ENDIF
                            	   539:     
00:0000035C 41FA070F        	   540:     lea     msgNoSdCardRead,A0
00:00000360 7201            	   541:     moveq.l #1,D1                                       ; Func code is 1 PRINTLN, A0 preloaded with address of error me
00:00000362 4E4E            	   542:     trap    #14                         
00:00000364 7001            	   543:     moveq.l #1,D0                                       ; signal error
                            	   544: 
00:00000366 23FCFFFFFFFF0000	   545:     move.l  #-1,lastFATSector
00:0000036E 0A16
00:00000370 243C000000FF    	   546:     move.l  #$ff,D2
00:00000376 45BC0001        	   547:     chk     #1,D2                                       ; cause a trap to stop execution
00:0000037A 4E75            	   548:     rts                                                 ; should not get here .. 
                            	   549: 
                            	   550: .noDiskReadError:
                            	   551:     debugPrintSector 'R'
                            	     1M     IFNE DEBUG
00:0000037C 48E7F0F0        	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
00:00000380 7006            	     4M         moveq.l #6,D0                                   
00:00000382 123C0052        	     5M         move.b  #'R',D1                                     
00:00000386 4E4F            	     6M         trap    #15
                            	     7M     
00:00000388 700F            	     8M         moveq.l #15,D0
00:0000038A 223A068A        	     9M         move.l  (lastFATSector),D1                          ; sector in hex
00:0000038E 143C0010        	    10M         move.b  #16,D2
00:00000392 4E4F            	    11M         trap    #15
                            	    12M 
00:00000394 7006            	    13M         moveq.l #6,D0
00:00000396 123C002D        	    14M         move.b  #'-',D1                                    
00:0000039A 4E4F            	    15M         trap    #15
                            	    16M 
00:0000039C 700F            	    17M         moveq.l #15,D0
00:0000039E 2203            	    18M         move.l  D3,D1                                       ; offset on sector in hex
00:000003A0 143C0010        	    19M         move.b  #16,D2
00:000003A4 4E4F            	    20M         trap    #15
                            	    21M 
00:000003A6 7006            	    22M         moveq.l #6,D0
00:000003A8 123C002D        	    23M         move.b  #'-',D1                                     
00:000003AC 4E4F            	    24M         trap    #15
                            	    25M 
00:000003AE 700F            	    26M         moveq.l #15,D0
00:000003B0 223A012C        	    27M         move.l  (DMA),D1                          ; sector in hex
00:000003B4 143C0010        	    28M         move.b  #16,D2
00:000003B8 4E4F            	    29M         trap    #15
                            	    30M 
00:000003BA 7006            	    31M         moveq.l #6,D0
00:000003BC 123C0020        	    32M         move.b  #' ',D1                                     
00:000003C0 4E4F            	    33M         trap    #15
                            	    34M 
00:000003C2 4CDF0F0F        	    35M         movem.l (A7)+,D0-D3/A0-A3
                            	    36M     ENDIF
                            	   552:     ;jmp    .noCachePrint
                            	   553: 
                            	   554: .noDiskReadRequired:
                            	   555:     ;debugPrintSector 'C'
                            	   556:     
                            	   557: .noCachePrint:
00:000003C6 41FA03FC        	   558:     lea    sdBuf,A0
00:000003CA D1C3            	   559:     add.l  D3,A0                                        ; add offset into 512b buffer
00:000003CC 4E75            	   560:     rts
                            	   561: 
                            	   562: WRITE:
                            	   563: ; Write one cpm sector from requested disk, track, sector to dma address
                            	   564: ; Can be a cpmimage on the sd card or the ram disk
00:000003CE 4A39000004D8    	   565:     cmp.b   #0,SELDRV
00:000003D4 667E            	   566:     bne     .writeRAMDrive
                            	   567: 
                            	   568:     ; going to write to disk    
00:000003D6 6100FEFA        	   569:     bsr     setupReadDisk                               ; sets A0 to point to the right 128 bytes in memory, potentiall
                            	   570:     debugPrintSector 'W'
                            	     1M     IFNE DEBUG
00:000003DA 48E7F0F0        	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
00:000003DE 7006            	     4M         moveq.l #6,D0                                   
00:000003E0 123C0057        	     5M         move.b  #'W',D1                                     
00:000003E4 4E4F            	     6M         trap    #15
                            	     7M     
00:000003E6 700F            	     8M         moveq.l #15,D0
00:000003E8 223A062C        	     9M         move.l  (lastFATSector),D1                          ; sector in hex
00:000003EC 143C0010        	    10M         move.b  #16,D2
00:000003F0 4E4F            	    11M         trap    #15
                            	    12M 
00:000003F2 7006            	    13M         moveq.l #6,D0
00:000003F4 123C002D        	    14M         move.b  #'-',D1                                    
00:000003F8 4E4F            	    15M         trap    #15
                            	    16M 
00:000003FA 700F            	    17M         moveq.l #15,D0
00:000003FC 2203            	    18M         move.l  D3,D1                                       ; offset on sector in hex
00:000003FE 143C0010        	    19M         move.b  #16,D2
00:00000402 4E4F            	    20M         trap    #15
                            	    21M 
00:00000404 7006            	    22M         moveq.l #6,D0
00:00000406 123C002D        	    23M         move.b  #'-',D1                                     
00:0000040A 4E4F            	    24M         trap    #15
                            	    25M 
00:0000040C 700F            	    26M         moveq.l #15,D0
00:0000040E 223A00CE        	    27M         move.l  (DMA),D1                          ; sector in hex
00:00000412 143C0010        	    28M         move.b  #16,D2
00:00000416 4E4F            	    29M         trap    #15
                            	    30M 
00:00000418 7006            	    31M         moveq.l #6,D0
00:0000041A 123C0020        	    32M         move.b  #' ',D1                                     
00:0000041E 4E4F            	    33M         trap    #15
                            	    34M 
00:00000420 4CDF0F0F        	    35M         movem.l (A7)+,D0-D3/A0-A3
                            	    36M     ENDIF
00:00000424 227A00B8        	   571:     move.l  DMA,A1
00:00000428 701F            	   572:     move.l  #(128/4-1),d0  
                            	   573:     
                            	   574: .MOVE_LOOP3:
00:0000042A 20D9            	   575:     MOVE.L  (A1)+,(A0)+                                 ; copy long word from source to dest, reverse direction from re
00:0000042C 51C8FFFC        	   576:     dbra    D0,.MOVE_LOOP3
                            	   577: 
                            	   578:     ; and write out the 512b buffer to disk
00:00000430 223A05E4        	   579:     move.l  (lastFATSector),D1                          ; set up in SETUPRD
00:00000434 43FA058E        	   580:     lea     sd,A1
00:00000438 7003            	   581:     moveq.l #3,D0                                       ; write sector function call
00:0000043A 45FA0388        	   582:     lea     sdBuf,A2                                    ; write out sdBuf to disk
00:0000043E 4E4D            	   583:     trap    #13
00:00000440 4A80            	   584:     cmp.l   #0,D0                                       ; check return
00:00000442 660C            	   585:     bne     .noWriteError
00:00000444 41FA0645        	   586:     lea     msgNoSdCardWrite,A0
00:00000448 7201            	   587:     moveq.l #1,D1                                       ; Func code is 1 PRINTLN, A0 preloaded with address of error me
00:0000044A 4E4E            	   588:     trap    #14                                         ; TRAP to firmware    
00:0000044C 7001            	   589:     moveq.l #1,D0                                       ; signal error
00:0000044E 4E75            	   590:     rts
                            	   591:     
                            	   592: .noWriteError:
                            	   593:     ;move.l #-1,lastFATSector
00:00000450 7000            	   594:     moveq.l #0,D0                                       ; return success
00:00000452 4E75            	   595:     rts                    
                            	   596: 
                            	   597: .writeRAMDrive:
00:00000454 6100FE5C        	   598:     bsr     setupReadRAM                                ; sets A0 to point to the right 128 bytes in memory to read
                            	   599:     debugPrintRAM 'W'
                            	     1M     IFNE DEBUG
00:00000458 48E7F0F0        	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
00:0000045C C14B            	     4M         exg     A0,A3                                       ; save A0 as trap 15 trashes it
00:0000045E 7006            	     5M         moveq.l #6,D0                                   
00:00000460 123C0057        	     6M         move.b  #'W',D1                                     
00:00000464 4E4F            	     7M         trap    #15
00:00000466 C748            	     8M         exg     A3,A0
                            	     9M 
00:00000468 700F            	    10M         moveq.l #15,D0
00:0000046A 2208            	    11M         move.l  A0,D1                                       ; address in hex
00:0000046C 143C0010        	    12M         move.b  #16,D2
00:00000470 4E4F            	    13M         trap    #15
                            	    14M 
00:00000472 7006            	    15M         moveq.l #6,D0
00:00000474 123C002D        	    16M         move.b  #'-',D1                                     
00:00000478 4E4F            	    17M         trap    #15
                            	    18M 
00:0000047A 700F            	    19M         moveq.l #15,D0
00:0000047C 223A0060        	    20M         move.l  (DMA),D1                          ; sector in hex
00:00000480 143C0010        	    21M         move.b  #16,D2
00:00000484 4E4F            	    22M         trap    #15
                            	    23M 
00:00000486 7006            	    24M         moveq.l #6,D0
00:00000488 123C0020        	    25M         move.b  #' ',D1                                     
00:0000048C 4E4F            	    26M         trap    #15
                            	    27M 
00:0000048E 4CDF0F0F        	    28M         movem.l (A7)+,D0-D3/A0-A3
                            	    29M     ENDIF
00:00000492 227A004A        	   600:     move.l  DMA,A1
00:00000496 701F            	   601:     move.l  #(128/4-1),d0  
                            	   602: 
                            	   603: .MOVE_LOOP4:
00:00000498 20D9            	   604:     MOVE.L  (A1)+,(A0)+                                 ; copy long word from source to dest, reverse direction from re
00:0000049A 51C8FFFC        	   605:     dbra    D0,.MOVE_LOOP4
                            	   606: 
00:0000049E 7000            	   607:     moveq.l #0,D0
00:000004A0 4E75            	   608:     rts        
                            	   609: 
                            	   610: FLUSH:
00:000004A2 7000            	   611:     moveq.l #0,D0                                       ; return successful
00:000004A4 4E75            	   612:     rts
                            	   613: 
                            	   614: GETSEG:
00:000004A6 203C000004E4    	   615:     move.l #MEMRGN,D0                                   ; return address of mem region table
00:000004AC 4E75            	   616:     rts
                            	   617: 
                            	   618: SETEXC:
00:000004AE 0281000000FF    	   619:     andi.l  #$ff,D1                                     ; do only for exceptions 0 - 255
                            	   620: 
00:000004B4 0C41002D        	   621:     cmpi    #45,D1
00:000004B8 671A            	   622:     beq     NOSET                                       ; don't set trap 13,14,15 as used by rosco firmware
00:000004BA 0C41002E        	   623:     cmpi    #46,D1
00:000004BE 6714            	   624:     beq     NOSET                        
00:000004C0 0C41002F        	   625:     cmpi    #47,D1
00:000004C4 670E            	   626:     beq     NOSET                       
00:000004C6 0C410009        	   627:     cmpi    #9,D1                                       ; don't set trace trap
00:000004CA 6708            	   628:     beq     NOSET
00:000004CC E549            	   629:     lsl     #2,D1                                       ; multiply exception number by 4
00:000004CE 2041            	   630:     movea.l D1,A0
00:000004D0 2010            	   631:     move.l  (A0),D0                                     ; return old vector value
00:000004D2 2082            	   632:     move.l  D2,(A0)                                     ; insert new vector
                            	   633: 
                            	   634: NOSET:    
00:000004D4 4E75            	   635:     rts
                            	   636: 
                            	   637: * ************************************************************************** *
                            	   638: ; Data
                            	   639: * ************************************************************************** *
                            	   640: 
                            	   641:               align 2                    ; DMA must be at even address
00:000004D8 FF              	   642: SELDRV        dc.b        $ff            ; drive requested by seldsk
00:000004D9 00              	   643: RESV          dc.b        0              ; reserve byte, padding
00:000004DA 0000            	   644: TRACK         dc.w        0              ; track requested by settrk
00:000004DC 0000            	   645: SECTOR        dc.w        0              ; max sector value is 0x3FF
00:000004DE 00000000        	   646: DMA           dc.l        0
00:000004E2 00              	   647: SELCODE       dc.b        0              ; reserve byte
00:000004E3 00              	   648: RESV1         dc.b        0              ; reserve byte, padding
                            	   649: 
                            	   650: ; memory table must start on an even address
                            	   651:               align 2
00:000004E4 0001            	   652: MEMRGN        dc.w        1              ; 1 memory region
00:000004E6 00020000        	   653:               dc.l        $20000         ; after the CP/M 
00:000004EA 000A0000        	   654: 			  dc.l        $A0000         ; 524K bytes, more than enough for bootstrapping  
                            	   655: 
                            	   656: ; disk parameter header - 4mb disk on sd card
                            	   657: DPH0:    
00:000004EE 00000000        	   658:     dc.l      0                          ; no sector translation table
00:000004F2 0000            	   659:     dc.w      0                          ; dummy
00:000004F4 0000            	   660:     dc.w      0
00:000004F6 0000            	   661:     dc.w      0
00:000004F8 00000544        	   662:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000004FC 00000508        	   663:     dc.l      DPB0                       ; ptr to disk parameter block
00:00000500 00000000        	   664:     dc.l      0                          ; permanent drive, no check vector
00:00000504 000005C4        	   665:     dc.l      ALV0                       ; ptr to allocation vector
                            	   666: 
                            	   667: DPB0:    
00:00000508 0020            	   668:     dc.w     32                          ; 32 sectors per track
00:0000050A 04              	   669:     dc.b     4                           ; block shift for BLS of 2048
00:0000050B 0F              	   670:     dc.b     15                          ; block mask for BLS of 2048
00:0000050C 00              	   671:     dc.b     0                           ; extent mask, EXM
00:0000050D 00              	   672:     dc.b     0                           ; dummy fill
00:0000050E 07FF            	   673:     dc.w     2047                        ; DSM, (1024 tracks * 32 sectors * 128 bytes /2048)-1
                            	   674:                            
00:00000510 00FF            	   675:     dc.w     255                         ; DRM, 256 directory entries
00:00000512 0000            	   676:     dc.w     0                           ; directory mask
00:00000514 0000            	   677:     dc.w     0                           ; permanent mounted drive, check size is zero
00:00000516 0000            	   678:     dc.w     0                           ; no track offset
                            	   679: 
                            	   680: 
                            	   681: ; disk parameter header - 128k ram disk 
                            	   682: DPH1:    
00:00000518 00000000        	   683:     dc.l      0                          ; no sector translation table
00:0000051C 0000            	   684:     dc.w      0                          ; dummy
00:0000051E 0000            	   685:     dc.w      0
00:00000520 0000            	   686:     dc.w      0
00:00000522 00000544        	   687:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000526 00000532        	   688:     dc.l      DPB1                       ; ptr to disk parameter block
00:0000052A 00000000        	   689:     dc.l      0                          ; permanent drive, no check vector
00:0000052E 000006C4        	   690:     dc.l      ALV1                       ; ptr to allocation vector
                            	   691: 
                            	   692: DPB1:    
00:00000532 0020            	   693:     dc.w     32                          ; 32 sectors per track
00:00000534 04              	   694:     dc.b     4                           ; block shift for BLS of 2048
00:00000535 0F              	   695:     dc.b     15                          ; block mask for BLS of 2048
00:00000536 00              	   696:     dc.b     0                           ; extent mask, EXM
00:00000537 00              	   697:     dc.b     0                           ; dummy fill
00:00000538 003F            	   698:     dc.w     63                          ; DSM, (32 tracks * 32 sectors * 128 bytes /2048)-1
                            	   699:                            
00:0000053A 00FF            	   700:     dc.w     255                         ; DRM, 256 directory entries
00:0000053C 0000            	   701:     dc.w     0                           ; directory mask
00:0000053E 0000            	   702:     dc.w     0                           ; permanent mounted drive, check size is zero
00:00000540 0000            	   703:     dc.w     0                           ; no track offset
                            	   704: 
                            	   705: 
                            	   706:     align 2
                            	   707: DIRBUF:    
00:00000544 00              	   708:     ds.b     128                         ; directory buffer
00:00000545 *
                            	   709: 
                            	   710: ALV0:    
00:000005C4 00              	   711: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000005C5 *
                            	   712: 
                            	   713: ALV1:    
00:000006C4 00              	   714: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000006C5 *
                            	   715: 
                            	   716: sdBuf:    
00:000007C4 00              	   717: 	ds.b     512                         ; buffer to read/write sectors to sd card
00:000007C5 *
                            	   718: 
                            	   719: sd:
00:000009C4 00              	   720:     ds.b     64                          ; needs to be large enough to hold a sd card structure
00:000009C5 *
                            	   721: 
                            	   722: partStartSector:                         ; starting sector for partition 0 on the disk
00:00000A04 00000000        	   723:     dc.l     0
                            	   724: 
                            	   725: rootDirectoryCluster:                    ; cluster of root directory - usually 2
00:00000A08 00000000        	   726:     dc.l     0
                            	   727: 
                            	   728: rootDirectorySector:                     ; sector where root directory starts on sd card
00:00000A0C 0000            	   729:     dc.w     0
                            	   730: 
                            	   731: reservedSectors:                         ; sector where FAT table starts on sd card
00:00000A0E 0000            	   732:     dc.w     0
                            	   733: 
                            	   734: sectorsPerCluster:                       ; sectors per cluster in word format
00:00000A10 0000            	   735:     dc.w     0
                            	   736: 
                            	   737: CPMImageSector:                          ; sector number of CPM image
00:00000A12 00000000        	   738:     dc.l     0
                            	   739: 
                            	   740: lastFATSector:                           ; last FAT sector read (contents should be in sdBuf)
00:00000A16 FFFFFFFF        	   741:     dc.l     -1
                            	   742: 
                            	   743: imageName:
00:00000A1A 43504D4449534B20	   744:     dc.b     "CPMDISK IMG",0             ; Nameof CPM image file on SD card
00:00000A22 494D47
00:00000A25 00
                            	   745: 
                            	   746: msgNoSdCardSupport:
00:00000A26 6572726F723A204E	   747:     dc.b     "error: No SD card support detected",0
00:00000A2E 6F20534420636172
00:00000A36 6420737570706F72
00:00000A3E 7420646574656374
00:00000A46 6564
00:00000A48 00
                            	   748: 
                            	   749: msgNoSdCardInit:
00:00000A49 6572726F723A2055	   750:     dc.b     "error: Unable to initialize SD card",0
00:00000A51 6E61626C6520746F
00:00000A59 20696E697469616C
00:00000A61 697A652053442063
00:00000A69 617264
00:00000A6C 00
                            	   751: 
                            	   752: msgNoSdCardRead:
00:00000A6D 6572726F723A2055	   753:     dc.b     "error: Unable to read SD card",0
00:00000A75 6E61626C6520746F
00:00000A7D 2072656164205344
00:00000A85 2063617264
00:00000A8A 00
                            	   754: 
                            	   755: msgNoSdCardWrite:
00:00000A8B 6572726F723A2055	   756:     dc.b     "error: Unable to write SD card",0
00:00000A93 6E61626C6520746F
00:00000A9B 2077726974652053
00:00000AA3 442063617264
00:00000AA9 00
                            	   757: 
                            	   758: msgNoCPMImage:
00:00000AAA 6572726F723A2043	   759:     dc.b     "error: Cannot find CPMDISK.IMG in root directory of partition 0 on SD card",0
00:00000AB2 616E6E6F74206669
00:00000ABA 6E642043504D4449
00:00000AC2 534B2E494D472069
00:00000ACA 6E20726F6F742064
00:00000AD2 69726563746F7279
00:00000ADA 206F662070617274
00:00000AE2 6974696F6E203020
00:00000AEA 6F6E205344206361
00:00000AF2 7264
00:00000AF4 00
                            	   760: 


Symbols by name:
ALV0                            00:000005C4
ALV1                            00:000006C4
BIOSBASE                        00:00000168
CONIN                           00:000001D4
CONOUT                          00:000001E2
CONSTAT                         00:000001CA
CPMImageSector                  00:00000A12
DEBUG                            S:00000001
DIRBUF                          00:00000544
DMA                             00:000004DE
DPB0                            00:00000508
DPB1                            00:00000532
DPH0                            00:000004EE
DPH1                            00:00000518
FLUSH                           00:000004A2
GETIOB                          00:000001E8
GETSEG                          00:000004A6
HOME                            00:000001F2
LISTST                          00:000001EC
LSTOUT                          00:000001E8
MEMRGN                          00:000004E4
NOSET                           00:000004D4
PUN                             00:000001E8
RDR                             00:000001E8
READ                            00:0000024C
RESV                            00:000004D9
RESV1                           00:000004E3
SECTOR                          00:000004DC
SECTRAN                         00:0000022E
SELCODE                         00:000004E2
SELDRV                          00:000004D8
SELDSK                          00:000001FA
SETDMA                          00:00000232
SETDMA2                         00:0000023A
SETEXC                          00:000004AE
SETIOB                          00:000001E8
SETSEC                          00:00000226
SETTRK                          00:0000021E
TRACK                           00:000004DA
TRAPHNDL                        00:00000158
TRAPNG                          00:00000166
WBOOT                           00:000001C4
WRITE                           00:000003CE
_ccp                             E:000150BC
_init                           00:00000000 EXP
imageName                       00:00000A1A
lastFATSector                   00:00000A16
msgNoCPMImage                   00:00000AAA
msgNoSdCardInit                 00:00000A49
msgNoSdCardRead                 00:00000A6D
msgNoSdCardSupport              00:00000A26
msgNoSdCardWrite                00:00000A8B
partStartSector                 00:00000A04
ramDriveLocation                 E:000C0000
reservedSectors                 00:00000A0E
rootDirectoryCluster            00:00000A08
rootDirectorySector             00:00000A0C
sd                              00:000009C4
sdBuf                           00:000007C4
sectorsPerCluster               00:00000A10
setupReadDisk                   00:000002D2
setupReadRAM                    00:000002B2

Symbols by value:
00000000 _init
00000001 DEBUG
00000158 TRAPHNDL
00000166 TRAPNG
00000168 BIOSBASE
000001C4 WBOOT
000001CA CONSTAT
000001D4 CONIN
000001E2 CONOUT
000001E8 SETIOB
000001E8 RDR
000001E8 PUN
000001E8 LSTOUT
000001E8 GETIOB
000001EC LISTST
000001F2 HOME
000001FA SELDSK
0000021E SETTRK
00000226 SETSEC
0000022E SECTRAN
00000232 SETDMA
0000023A SETDMA2
0000024C READ
000002B2 setupReadRAM
000002D2 setupReadDisk
000003CE WRITE
000004A2 FLUSH
000004A6 GETSEG
000004AE SETEXC
000004D4 NOSET
000004D8 SELDRV
000004D9 RESV
000004DA TRACK
000004DC SECTOR
000004DE DMA
000004E2 SELCODE
000004E3 RESV1
000004E4 MEMRGN
000004EE DPH0
00000508 DPB0
00000518 DPH1
00000532 DPB1
00000544 DIRBUF
000005C4 ALV0
000006C4 ALV1
000007C4 sdBuf
000009C4 sd
00000A04 partStartSector
00000A08 rootDirectoryCluster
00000A0C rootDirectorySector
00000A0E reservedSectors
00000A10 sectorsPerCluster
00000A12 CPMImageSector
00000A16 lastFATSector
00000A1A imageName
00000A26 msgNoSdCardSupport
00000A49 msgNoSdCardInit
00000A6D msgNoSdCardRead
00000A8B msgNoSdCardWrite
00000AAA msgNoCPMImage
000150BC _ccp
000C0000 ramDriveLocation
