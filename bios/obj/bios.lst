Sections:
00: "CODE" (0-98D)


Source: "bios.asm"
                            	     1: ; Very simple cpm68k bios
                            	     2: ; Malcolm Harrow August 2023
                            	     3: 
                            	     4: _ccp               equ $150BC                           ; hard location for _ccp of CPM15000.SR
                            	     5: ramDriveLocation   equ $C0000                           ; memory location for RAM drive
                            	     6: DEBUG              set 0                                ; set to 1 to print debug messgae, 0 turns off  
                            	     7: 
                            	     8: ; pass in a character to this routine and print it out
                            	     9: ; use to track progress through the code in debug ..
                            	    10: debugPrintChar MACRO
                            	    11:     IFNE DEBUG
                            	    12:         movem.l D0-D3/A0-A3,-(A7)
                            	    13: 
                            	    14:         moveq.l #6,D0                                   
                            	    15:         move.b  #\1,D1                                     
                            	    16:         trap    #15
                            	    17:     
                            	    18:         movem.l (A7)+,D0-D3/A0-A3
                            	    19:     ENDIF
                            	    20: ENDM
                            	    21: 
                            	    22: ; print sector information read from / written to a SD disk image (or real SD card)
                            	    23: ; pass in a character to this routine to specify type of operation on the sector eg 'R' or 'W'
                            	    24: debugPrintSector MACRO
                            	    25:     IFNE DEBUG
                            	    26:         movem.l D0-D3/A0-A3,-(A7)
                            	    27: 
                            	    28:         moveq.l #6,D0                                   
                            	    29:         move.b  #\1,D1                                     
                            	    30:         trap    #15
                            	    31:     
                            	    32:         moveq.l #15,D0
                            	    33:         move.l  (lastFATSector),D1                          ; sector in hex
                            	    34:         move.b  #16,D2
                            	    35:         trap    #15
                            	    36: 
                            	    37:         moveq.l #6,D0
                            	    38:         move.b  #'-',D1                                    
                            	    39:         trap    #15
                            	    40: 
                            	    41:         moveq.l #15,D0
                            	    42:         move.l  D3,D1                                       ; offset on sector in hex
                            	    43:         move.b  #16,D2
                            	    44:         trap    #15
                            	    45: 
                            	    46:         ;moveq.l #6,D0
                            	    47:         ;move.b  #'-',D1                                     
                            	    48:         ;trap    #15
                            	    49: 
                            	    50:         ;moveq.l #15,D0
                            	    51:         ;move.l  (DMA),D1                          ; DMA in hex
                            	    52:         ;move.b  #16,D2
                            	    53:         ;trap    #15
                            	    54: 
                            	    55:         moveq.l #6,D0
                            	    56:         move.b  #' ',D1                                     
                            	    57:         trap    #15
                            	    58: 
                            	    59:         movem.l (A7)+,D0-D3/A0-A3
                            	    60:     ENDIF
                            	    61: ENDM
                            	    62: 
                            	    63: ; print sector information read from / written to a RAM disk
                            	    64: ; pass in a character to this routine to specify type of operation on the RAM drive eg 'R' or 'W'
                            	    65: ; Assuem A0 is already set up to point to the RAM being moved
                            	    66: debugPrintRAM MACRO
                            	    67:     IFNE DEBUG
                            	    68:         movem.l D0-D3/A0-A3,-(A7)
                            	    69: 
                            	    70:         exg     A0,A3                                       ; save A0 as trap 15 trashes it
                            	    71:         moveq.l #6,D0                                   
                            	    72:         move.b  #\1,D1                                     
                            	    73:         trap    #15
                            	    74:         exg     A3,A0
                            	    75: 
                            	    76:         moveq.l #15,D0
                            	    77:         move.l  A0,D1                                       ; address in hex
                            	    78:         move.b  #16,D2
                            	    79:         trap    #15
                            	    80: 
                            	    81:         moveq.l #6,D0
                            	    82:         move.b  #'-',D1                                     
                            	    83:         trap    #15
                            	    84: 
                            	    85:         moveq.l #15,D0
                            	    86:         move.l  (DMA),D1                          ; sector in hex
                            	    87:         move.b  #16,D2
                            	    88:         trap    #15
                            	    89: 
                            	    90:         moveq.l #6,D0
                            	    91:         move.b  #' ',D1                                     
                            	    92:         trap    #15
                            	    93: 
                            	    94:         movem.l (A7)+,D0-D3/A0-A3
                            	    95:     ENDIF
                            	    96: ENDM
                            	    97: 
                            	    98: _init::    
                            	    99:     ; at this stage, we have loaded from the SDCARD, so we know its valid, no need to re-init
                            	   100:     ; need to find the starting sector of the CPM disk image on the sd card.
                            	   101:     ; To do this we will trawl through the FAT32 boot record etc
                            	   102: 
                            	   103:     ; to do this:
                            	   104:     ;   - read the MBR, block 0 and note:
                            	   105:     ;     - number of reserved sectors, 0x0E, word (eg 20 00)
                            	   106:     ;     - logical sectors per FAT, 0x24, long  (eg f1 03 00 00)
                            	   107:     ;     - number of fats, 0x10, byte (eg 02)
                            	   108:     ;   - This enables us to calculate:
                            	   109:     ;     - start of FAT table (sector after number of reserved sectors - 32 or 0x4000
                            	   110:     ;     - start of root directory,  Logical sectors per FAT (0x24) * Number of FATs (0x10) + Reserved logical sectors
                            	   111:     ;   - The root directory is arranged 32 bytes per entry.  We will assume our CPM disk image is in the root and call
                            	   112:     
                            	   113:     ; check sd card support
00:00000000 7000            	   114:     moveq.l #0,D0
00:00000002 4E4D            	   115:     trap    #13
00:00000004 B0BC1234FEDC    	   116:     cmp.l   #$1234FEDC,D0                               ; check magic return
00:0000000A 6708            	   117:     beq     .haveSDsupport
00:0000000C 41FA08B0        	   118:     lea     msgNoSdCardSupport,A0
00:00000010 6000013E        	   119:     jmp     .errExit
                            	   120:     
                            	   121: .haveSDsupport:
                            	   122:     ; init the sd card and get sd card structure back
00:00000014 43FA0846        	   123:     lea     sd,A1
00:00000018 7001            	   124:     moveq.l #1,D0                                       
00:0000001A 4E4D            	   125:     trap    #13
00:0000001C 4A80            	   126:     cmp.l   #0,D0                                       ; check return
00:0000001E 6708            	   127:     beq     .haveSDinit
00:00000020 41FA08BF        	   128:     lea     msgNoSdCardInit,A0
00:00000024 6000012A        	   129:     jmp     .errExit
                            	   130: 
                            	   131: .haveSDinit:
                            	   132:     ; read the MBR from sector 0 on the disk so we can read the partition table
00:00000028 43FA0832        	   133:     lea     sd,A1
00:0000002C 7002            	   134:     moveq.l #2,D0                                       ; read the MBR from the sd card 
00:0000002E 7200            	   135:     moveq.l #0,D1                                       ; sector number to read
00:00000030 45FA062A        	   136:     lea     sdBuf,A2
00:00000034 4E4D            	   137:     trap    #13
00:00000036 4A80            	   138:     cmp.l   #0,D0                                       ; check return
00:00000038 6608            	   139:     bne     .haveReadDiskMBR
00:0000003A 41FA08C9        	   140:     lea     msgNoSdCardRead,A0
00:0000003E 60000110        	   141:     jmp     .errExit
                            	   142: 
                            	   143: .haveReadDiskMBR:
                            	   144:     ; now we need to check the disk MBR for a partition table and get the offset to the first partition
                            	   145:     ; this is a bodge .. CPM has to be on the first partition, partiton 0 and 0x1BE on the disk MBR
                            	   146:     ; The code should really check all 4 partitions ..
                            	   147: 
                            	   148:     ; as we read longs and words off of the MBR we have to take endianess into account and switch the byte order 
                            	   149:     ; as we are on the 68000 CPU
00:00000042 2C3A07DE        	   150:     move.l  $1c6+sdBuf,D6                               ; read LBA start from partition 0
00:00000046 E15E            	   151:     rol.w   #8,D6
00:00000048 4846            	   152:     swap    D6
00:0000004A E15E            	   153:     rol.w   #8,D6
00:0000004C 23C60000089C    	   154:     move.l  D6,partStartSector
                            	   155: 
                            	   156:     ; read the MBR from sector 0 of the partition so we can calculate position of the root diectory and hence the CPM i
00:00000052 43FA0808        	   157:     lea     sd,A1
00:00000056 7002            	   158:     moveq.l #2,D0                                       ; read the MBR from the sd card 
00:00000058 2206            	   159:     move.l  D6,D1                                       ; sector number to read - partStartSector
00:0000005A 45FA0600        	   160:     lea     sdBuf,A2
00:0000005E 4E4D            	   161:     trap    #13
00:00000060 4A80            	   162:     cmp.l   #0,D0                                       ; check return
00:00000062 6608            	   163:     bne     .haveReadPartMBR
00:00000064 41FA089F        	   164:     lea     msgNoSdCardRead,A0
00:00000068 600000E6        	   165:     jmp     .errExit
                            	   166: 
                            	   167: .haveReadPartMBR
                            	   168: 
00:0000006C 3C3A05FC        	   169:     move.w  $e+sdBuf,D6                                 ; number of reserved sectors from MBR.  Reversed due to endiane
00:00000070 E15E            	   170:     rol.w   #8,D6
00:00000072 33C6000008A6    	   171:     move.w  D6,reservedSectors
                            	   172: 
00:00000078 2C3A060E        	   173:     move.l  $2c+sdBuf,D6                                ; read root director cluster (usually 2)
00:0000007C E15E            	   174:     rol.w   #8,D6
00:0000007E 4846            	   175:     swap    D6
00:00000080 E15E            	   176:     rol.w   #8,D6
00:00000082 23C6000008A0    	   177:     move.l  D6,rootDirectoryCluster
                            	   178: 
                            	   179:     ; up until the root directory, we use sectors; after the root directory we have to deal with clusters (groups of se
                            	   180:     ; see the diagram here: https://eric-lo.gitbook.io/lab9-filesystem/overview-of-fat32#
                            	   181:     ; we need to store the number of sectors per cluster for later use
00:00000088 7C00            	   182:     moveq.l #0,D6
00:0000008A 1C3A05DD        	   183:     move.b  $d+sdBuf,D6                                 ; read number of sectors per cluster
00:0000008E 33C6000008A8    	   184:     move.w  D6,sectorsPerCluster                        ; save as a word for later mulu
                            	   185: 
                            	   186:     ; Calculate the sector of the root directory: 
                            	   187:     ; = sectors per FAT * number of FATs + number of reserved sectors
                            	   188:     ; += partStartSector to allow for the start of the partition on the disk
00:00000094 2A3A05EA        	   189:     move.l  $24+sdBuf,D5                                ; read sectors per FAT
00:00000098 E15D            	   190:     rol.w   #8,D5
00:0000009A 4845            	   191:     swap    D5
00:0000009C E15D            	   192:     rol.w   #8,D5
                            	   193:     
00:0000009E 7C00            	   194:     moveq.l #0,D6                                       ; read number of FAT tables
00:000000A0 1C3A05CA        	   195:     move.b  $10+sdBuf,D6
                            	   196: 
00:000000A4 CCC5            	   197:     mulu.w  D5,D6
00:000000A6 DC7A07FE        	   198:     add.w   reservedSectors,D6
00:000000AA DCBA07F0        	   199:     add.l   partStartSector,D6                          ; partStartSector is a long
00:000000AE 33C6000008A4    	   200:     move.w  D6,rootDirectorySector
                            	   201: 
                            	   202: 
                            	   203: ;    sector = sector of start of root directory
                            	   204: ;    entry = 0
                            	   205: ;    while (1) {
                            	   206: ;      offset = entry % 16
                            	   207: ;      if offset == 0 {
                            	   208: ;        // read next sector
                            	   209: ;        read next sector
                            	   210: ;        increment sector
                            	   211: ;      };;
                            	   212: ;
                            	   213: ;      directory_entry = offset * 32 plus buffer start
                            	   214: ;
                            	   215: ;      if directory_entry[0] == 0 { // end of root directory
                            	   216: ;        message failure
                            	   217: ;        return failure
                            	   218: ;      }
                            	   219: ;
                            	   220: ;      if directory_entry[0xb] & 0x10 { // subdirectory
                            	   221: ;        continue
                            	   222: ;      }
                            	   223: ;
                            	   224: ;      if directory entry[0xb] == 0xf { // record contains a long file name
                            	   225: ;        continue
                            	   226: ;      }
                            	   227: ;
                            	   228: ;      if strncmp(directory entry, "CPMDISK IMG", 11) {
                            	   229: ;        // found file, might have to ignore case here, lets see
                            	   230: ;        // record sector file starts and file length
                            	   231: ;        block = entry[20,21] << 16 + entry[26,27]
                            	   232: ;        // both of these are store lsb first eg length of 0x7e84 is stored 84 7e 00 00
                            	   233: ;        return success
                            	   234: ;      }
                            	   235: ;      entry++
                            	   236: ;    }
                            	   237: 
                            	   238: 
                            	   239:     ; search the FAT to try to find the CPM disk image
00:000000B4 7600            	   240:     moveq.l #0,D3                                       ; sector to read
00:000000B6 7800            	   241:     moveq.l #0,D4                                       ; directory entry in sector.  Sector is 512b, directory table i
                            	   242: 
                            	   243: .startDirectoryEntry:
00:000000B8 2A04            	   244:     move.l  D4,D5
00:000000BA CABC0000000F    	   245:     and.l   #15,D5                                      ; only look at last 4 bits, we want to calculate (directory ent
00:000000C0 6620            	   246:     bne     .noReadRequired                             ; we dont need to read a new sector from the sd card
                            	   247: 
                            	   248:     ; read the MBR from sector 0 so we can calculate position of the MBR and root diectory in the CPM image
00:000000C2 43FA0798        	   249:     lea     sd,A1
00:000000C6 7002            	   250:     moveq.l #2,D0                                       ; read sector trap
00:000000C8 323A07DA        	   251:     move.w  rootDirectorySector,D1
00:000000CC D243            	   252:     add.w   D3,D1                                       ; sector number to read plus offset to rootDirectoryCluster
00:000000CE 45FA058C        	   253:     lea     sdBuf,A2
00:000000D2 4E4D            	   254:     trap    #13
00:000000D4 4A80            	   255:     cmp.l   #0,D0                                       ; check return
00:000000D6 6606            	   256:     bne     .noReadError
00:000000D8 41FA082B        	   257:     lea     msgNoSdCardRead,A0
00:000000DC 6072            	   258:     jmp     .errExit
                            	   259: 
                            	   260: .noReadError:
00:000000DE 5283            	   261:     addq.l  #1,D3                                       ; increment next sector to read
00:000000E0 7800            	   262:     moveq.l #0,D4                                       ; reset directory entry to zero 
                            	   263: 
                            	   264: .noReadRequired:
00:000000E2 2A04            	   265:     move.l  D4,D5                                       ; D4 contains directory record
00:000000E4 EB8D            	   266:     lsl.l   #5,D5                                       ; multiply offset by 32 to get to start of directory record
00:000000E6 DABC0000065C    	   267:     add.l   #sdBuf,D5
00:000000EC 2A45            	   268:     movea.l D5,A5
00:000000EE 1C15            	   269:     move.b  (A5),D6
00:000000F0 4A06            	   270:     tst.b   D6                                          ; reached end of root directory entries
00:000000F2 6606            	   271:     bne     .notDirEnd
00:000000F4 41FA084C        	   272:     lea     msgNoCPMImage,A0
00:000000F8 6056            	   273:     jmp     .errExit
                            	   274: 
                            	   275: .notDirEnd:
00:000000FA 1C2D000B        	   276:     move.b  $b(A5),D6
00:000000FE BC3C0010        	   277:     cmp.b   #$10,D6
00:00000102 6746            	   278:     beq     .nextDir                                    ; skip subdirectories entries
00:00000104 BC3C000F        	   279:     cmp.b   #$f,D6
00:00000108 6740            	   280:     beq     .nextDir                                    ; skip long filename entries
                            	   281: 
                            	   282:     ; check to see if we have found the CPM Image file
                            	   283:     ; The name CPMDISK.IMG is stored as "CPMDISK " then "IMG" in FAT32
00:0000010A 49FA07A6        	   284:     LEA     imageName,A4
00:0000010E BB8C            	   285:     cmp.l   (A4)+,(A5)+
00:00000110 6638            	   286:     bne     .nextDir
                            	   287:     
00:00000112 BB8C            	   288:     cmp.l   (A4)+,(A5)+
00:00000114 6634            	   289:     bne     .nextDir
                            	   290:     
00:00000116 2C15            	   291:     move.l  (A5),D6                                      ; wipe last byte from FAT to compare to 0 from imageName
00:00000118 4206            	   292:     clr.b   D6
00:0000011A BC94            	   293:     cmp.l   (A4),D6
00:0000011C 662C            	   294:     bne     .nextDir
                            	   295: 
                            	   296:     ; found file, A5 will now be pointing at entry[8] so adjust offsets to compensate
                            	   297:     ;        block = entry[20,21] << 16 + entry[26,27]
                            	   298:     ; get starting block of CPMDISK.IMG
00:0000011E 3C2D000C        	   299:     move.w  $c(A5),D6                                   
00:00000122 E15E            	   300:     rol.w   #8,D6
00:00000124 4846            	   301:     swap    D6
00:00000126 3C2D0012        	   302:     move.w  $12(A5),D6
00:0000012A E15E            	   303:     rol.w   #8,D6
                            	   304: 
00:0000012C 9CBA0772        	   305:     sub.l   (rootDirectoryCluster),D6                   ; allow for the position of the root directory (usually 2)
00:00000130 CCFA0776        	   306:     mulu.w  (sectorsPerCluster),D6  
                            	   307: 
                            	   308:     ; for efficiency we will point CPMImageSector at the actual block on the sd card
00:00000134 DC7A076E        	   309:     add.w  (rootDirectorySector),D6
00:00000138 23C6000008AA    	   310:     move.l D6,CPMImageSector
                            	   311: 
00:0000013E 21FC00000158008C	   312:     move.l  #TRAPHNDL,$8c                               ; set up trap #3 handler
00:00000146 7000            	   313:     moveq.l #0,D0                                       ; log on disk A, user 0
00:00000148 4E75            	   314:     rts
                            	   315: 
                            	   316: .nextDir:
00:0000014A 5284            	   317:     addq.l  #1,D4                                       ; look at next directory entry
00:0000014C 6000FF6A        	   318:     jmp     .startDirectoryEntry
                            	   319: 
                            	   320: .errExit:
00:00000150 7201            	   321:     moveq.l #1,D1                                       ; Func code is 1 PRINTLN, A0 preloaded with address of error me
00:00000152 4E4E            	   322:     trap    #14                          
00:00000154 7001            	   323:     moveq.l #1,D0                                       ; signal error
00:00000156 4E75            	   324:     rts
                            	   325: 
                            	   326: TRAPHNDL:
00:00000158 0C400017        	   327:     cmpi    #23,D0                                      ; Function call in range ?
00:0000015C 6408            	   328:     bcc     TRAPNG
                            	   329: 
00:0000015E E588            	   330:     lsl.l   #2,D0                                       ; change function call to offset by multiplting by 4
00:00000160 207B0006        	   331:     move.l  BIOSBASE(PC,D0),A0          ; ... and calc offset into table...
00:00000164 4E90            	   332:     jsr     (A0)                        ; ... then jump there
                            	   333: 
                            	   334: TRAPNG:
00:00000166 4E73            	   335:     rte
                            	   336: 
                            	   337: BIOSBASE:
00:00000168 00000000        	   338:     dc.l    _init
00:0000016C 000001C4        	   339:     dc.l    WBOOT
00:00000170 000001CA        	   340:     dc.l    CONSTAT
00:00000174 000001D4        	   341:     dc.l    CONIN
00:00000178 000001E2        	   342:     dc.l    CONOUT
00:0000017C 000001E8        	   343:     dc.l    LSTOUT
00:00000180 000001E8        	   344:     dc.l    PUN
00:00000184 000001E8        	   345:     dc.l    RDR
00:00000188 000001F2        	   346:     dc.l    HOME
00:0000018C 000001FA        	   347:     dc.l    SELDSK
00:00000190 0000021E        	   348:     dc.l    SETTRK
00:00000194 00000226        	   349:     dc.l    SETSEC
00:00000198 00000232        	   350:     dc.l    SETDMA
00:0000019C 0000023C        	   351:     dc.l    READ
00:000001A0 000002EE        	   352:     dc.l    WRITE
00:000001A4 000001EC        	   353:     dc.l    LISTST
00:000001A8 0000022E        	   354:     dc.l    SECTRAN
00:000001AC 0000023A        	   355:     dc.l    SETDMA2
00:000001B0 00000340        	   356:     dc.l    GETSEG
00:000001B4 000001E8        	   357:     dc.l    GETIOB
00:000001B8 000001E8        	   358:     dc.l    SETIOB
00:000001BC 0000033C        	   359:     dc.l    FLUSH
00:000001C0 00000348        	   360:     dc.l    SETEXC
                            	   361: 
                            	   362: 
                            	   363: WBOOT:  
00:000001C4 4EF9000150BC    	   364:     jmp     _ccp
                            	   365: 
                            	   366: CONSTAT: 
                            	   367: ; Check for keyboard input. Set d0 to 1 if keyboard input is pending, otherwise set to 0.
00:000001CA 7007            	   368:     moveq.l #7,D0                        ; use EASy68k trap 15 task 7
00:000001CC 4E4F            	   369:     trap    #15                          ; d1.b = 1 if keyboard ready, otherwise = 0
00:000001CE 7000            	   370:     moveq.l #0,D0
00:000001D0 1001            	   371:     move.b  D1,D0
00:000001D2 4E75            	   372:     rts
                            	   373: 
                            	   374: CONIN:    
                            	   375: ; Read single ASCII character from the keyboard into d0
                            	   376: ; Rosco implementation of this trap waits for input
00:000001D4 7005            	   377:     moveq.l #5,D0                        ; use EASy68k trap 15 task 5
00:000001D6 4E4F            	   378:     trap    #15                          ; d1.b contains the ascii character
00:000001D8 1001            	   379:     move.b  D1,D0      
00:000001DA C0BC0000007F    	   380:     and.l   #$7f,D0                      ; only use 7 bit character set
00:000001E0 4E75            	   381:     rts
                            	   382: 
                            	   383: CONOUT: 
                            	   384: ; Display single ASCII character in d1
00:000001E2 7006            	   385:     moveq.l #6,D0                        ; use EASy68k trap 15 task 6
00:000001E4 4E4F            	   386:     trap    #15
00:000001E6 4E75            	   387:     rts                                  ; and exit
                            	   388: 
                            	   389: LSTOUT:    
                            	   390: PUN:
                            	   391: RDR:
                            	   392: GETIOB:
                            	   393: SETIOB:
00:000001E8 7000            	   394:     moveq.l #0,D0
00:000001EA 4E75            	   395:     rts
                            	   396: 
                            	   397: LISTST:    
00:000001EC 103C00FF        	   398:     move.b #$ff,D0
00:000001F0 4E75            	   399:     rts
                            	   400: 
                            	   401: HOME:    
00:000001F2 427900000372    	   402:     clr.w  TRACK
00:000001F8 4E75            	   403:     rts
                            	   404: 
                            	   405: SELDSK:    
                            	   406: ; drive should be in d1.b
00:000001FA B23C0001        	   407:     cmp.b   #1,D1
00:000001FE 670E            	   408:     beq     .seldrive1     
00:00000200 423900000370    	   409:     move.b  #0,SELDRV
00:00000206 203C00000386    	   410:     move.l  #DPH0,D0
00:0000020C 4E75            	   411:     rts
                            	   412: 
                            	   413: .seldrive1
00:0000020E 13FC000100000370	   414:     move.b  #1,SELDRV
00:00000216 203C000003B0    	   415:     move.l  #DPH1,D0
00:0000021C 4E75            	   416:     rts
                            	   417: 
                            	   418: SETTRK:    
00:0000021E 33C100000372    	   419:     move.w  D1,TRACK
00:00000224 4E75            	   420:     rts
                            	   421: 
                            	   422: SETSEC:    
00:00000226 33C100000374    	   423:     move.w  D1,SECTOR
00:0000022C 4E75            	   424:     rts
                            	   425: 
                            	   426: SECTRAN:
                            	   427: ;    no sector translate, put d1 into d0 and return
00:0000022E 3001            	   428:     move.w  D1,D0
00:00000230 4E75            	   429:     rts
                            	   430: 
                            	   431: SETDMA:
00:00000232 23C100000376    	   432:     move.l  D1,DMA
00:00000238 4E75            	   433:     rts
                            	   434: 
                            	   435: SETDMA2:
                            	   436:     debugPrintChar '*'
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         moveq.l #6,D0                                   
                            	     5M         move.b  #'*',D1                                     
                            	     6M         trap    #15
                            	     7M     
                            	     8M         movem.l (A7)+,D0-D3/A0-A3
                            	     9M     ENDIF
00:0000023A 4E75            	   437:     rts
                            	   438: 
                            	   439: READ:
                            	   440: ; Read one cpm sector from requested disk, track, sector to dma address
                            	   441: ; Can be a cpmimage on the sd card or the ram disk
00:0000023C 4A3900000370    	   442:     cmp.b   #0,SELDRV
00:00000242 6612            	   443:     bne     .readRAMDrive
                            	   444: 
00:00000244 6142            	   445:     bsr     setupReadDisk                               ; sets A0 to point to the right 128 bytes in memory, potentiall
00:00000246 227A012E        	   446:     move.l  DMA,A1
00:0000024A 701F            	   447:     move.l  #(128/4-1),D0  
                            	   448: 
                            	   449: .MOVE_LOOP1:
00:0000024C 22D8            	   450:     MOVE.L  (A0)+,(A1)+                                 ; copy long word from source to dest
00:0000024E 51C8FFFC        	   451:     dbra    D0,.MOVE_LOOP1
                            	   452:     
00:00000252 7000            	   453:     moveq.l #0,D0                                       ; return OK status         
00:00000254 4E75            	   454:     rts
                            	   455: 
                            	   456: .readRAMDrive:
00:00000256 6110            	   457:     bsr     setupReadRAM                                ; sets A0 to point to the right 128 bytes in memory to read
                            	   458:     debugPrintRAM 'R'
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         exg     A0,A3                                       ; save A0 as trap 15 trashes it
                            	     5M         moveq.l #6,D0                                   
                            	     6M         move.b  #'R',D1                                     
                            	     7M         trap    #15
                            	     8M         exg     A3,A0
                            	     9M 
                            	    10M         moveq.l #15,D0
                            	    11M         move.l  A0,D1                                       ; address in hex
                            	    12M         move.b  #16,D2
                            	    13M         trap    #15
                            	    14M 
                            	    15M         moveq.l #6,D0
                            	    16M         move.b  #'-',D1                                     
                            	    17M         trap    #15
                            	    18M 
                            	    19M         moveq.l #15,D0
                            	    20M         move.l  (DMA),D1                          ; sector in hex
                            	    21M         move.b  #16,D2
                            	    22M         trap    #15
                            	    23M 
                            	    24M         moveq.l #6,D0
                            	    25M         move.b  #' ',D1                                     
                            	    26M         trap    #15
                            	    27M 
                            	    28M         movem.l (A7)+,D0-D3/A0-A3
                            	    29M     ENDIF
00:00000258 227A011C        	   459:     move.l  DMA,A1
00:0000025C 701F            	   460:     move.l  #(128/4-1),d0  
                            	   461: 
                            	   462: .MOVE_LOOP2:
00:0000025E 22D8            	   463:     MOVE.L  (A0)+,(A1)+                                 ; copy long word from source to dest
00:00000260 51C8FFFC        	   464:     dbra    D0,.MOVE_LOOP2
                            	   465: 
00:00000264 7000            	   466:     moveq.l #0,D0                                       ; return OK status         
00:00000266 4E75            	   467:     rts         
                            	   468: 
                            	   469: setupReadRAM:
                            	   470: ; translate track/sector into RAM location on the RAM drive
00:00000268 7000            	   471:     moveq.l #0,D0
00:0000026A 303A0106        	   472:     move.w  TRACK,D0
00:0000026E 760C            	   473:     moveq.l #12,D3                                      ; much faster than shifting by 8 then 4 (40 versus 12 cycles)
00:00000270 E7A8            	   474:     lsl.l   D3,D0
                            	   475: 
00:00000272 7400            	   476:     moveq.l #0,D2
00:00000274 343A00FE        	   477:     move.w  SECTOR,D2
00:00000278 7607            	   478:     moveq.l #7,D3                                       ; much faster than shifting by 7 (22 versus 12 cycles)
00:0000027A E7AA            	   479:     lsl.l   D3,D2
                            	   480: 
00:0000027C D082            	   481:     add.l   D2,D0
00:0000027E D0BC000C0000    	   482:     add.l   #ramDriveLocation,D0                        ; add base address of RAM drive
00:00000284 2040            	   483:     movea.l D0,A0                                       ; point to the track/sector in RAM drive
00:00000286 4E75            	   484:     rts
                            	   485: 
                            	   486: setupReadDisk:
                            	   487: ;
                            	   488: ; algorithm
                            	   489: ;
                            	   490: ; keep 512b in a memory buffer
                            	   491: ; keep sector number of the data currently in the buffer
                            	   492: ;
                            	   493: ; if requested sector not in buffer {
                            	   494: ;     calcuate the sector and offset that the FAT entry for the sector is located in
                            	   495: ;     read sector pointed to in FAT table from disk into buffer
                            	   496: ;     note requested sector in buffer
                            	   497: ; }
                            	   498: ;
                            	   499: ; calculate offset of CPM 128b required in 512b buffer
                            	   500: ; copy the correct 12b across into the CPM dma area
                            	   501: 
                            	   502:     ; start by calculating the requested (FAT32) sector number from TRACK and SECTOR in D0
                            	   503:     ; also calculate the offset into that 512b buffer for the 128b CPM sector data in D3
00:00000288 7200            	   504:     moveq.l #0,D1
00:0000028A 323A00E6        	   505:     move.w  TRACK,D1
00:0000028E E789            	   506:     lsl.l   #3,D1
                            	   507: 
00:00000290 7400            	   508:     moveq.l #0,D2
00:00000292 343A00E0        	   509:     move.w  SECTOR,D2
                            	   510: 
00:00000296 2602            	   511:     move.l  D2,D3
00:00000298 C6BC00000003    	   512:     and.l   #3,D3                                       ; use D3 to calculate the offset of the 128b CPM sector in the 
00:0000029E 7807            	   513:     moveq.l #7,D4                                       ; much faster than shifting by 7 (22 versus 12 cycles)
00:000002A0 E9AB            	   514:     lsl.l   D4,D3
                            	   515: 
00:000002A2 E48A            	   516:     lsr.l   #2,D2
00:000002A4 D282            	   517:     add.l   D2,D1                                        ; D1 now has the requested sector number
00:000002A6 D2BA0602        	   518:     add.l   (CPMImageSector),D1                          ; D1 now has the actual sector on the SD card
                            	   519: 
                            	   520:     ; check to see if this FAT32 sector already in memory
00:000002AA B2BA0602        	   521:     cmp.l (lastFATSector),D1
00:000002AE 6736            	   522:     beq   .noDiskReadRequired
                            	   523: 
                            	   524:     ; we are going to read the sector (hopefully) so update the last read FAT sector before we lose the contents of D1
00:000002B0 23C1000008AE    	   525:     move.l D1,lastFATSector
                            	   526: 
                            	   527:     ; we assume that the FAT table is contiguous for the CP/M image
                            	   528:     ; file, this avoids a walk of the FAT table linked list .. but wont deal with any bad sectors on the sd card
                            	   529: 
00:000002B6 43FA05A4        	   530:     lea     sd,A1
00:000002BA 7002            	   531:     moveq.l #2,D0                                        ; read sector function code
00:000002BC 45FA039E        	   532:     lea     sdBuf,A2
00:000002C0 4E4D            	   533:     trap    #13
00:000002C2 4A80            	   534:     cmp.l   #0,D0                                        ; check return
00:000002C4 6620            	   535:     bne     .noDiskReadError
                            	   536: 
                            	   537:     ; if we get here we had a disk read error
                            	   538:     debugPrintSector 'E'
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         moveq.l #6,D0                                   
                            	     5M         move.b  #'E',D1                                     
                            	     6M         trap    #15
                            	     7M     
                            	     8M         moveq.l #15,D0
                            	     9M         move.l  (lastFATSector),D1                          ; sector in hex
                            	    10M         move.b  #16,D2
                            	    11M         trap    #15
                            	    12M 
                            	    13M         moveq.l #6,D0
                            	    14M         move.b  #'-',D1                                    
                            	    15M         trap    #15
                            	    16M 
                            	    17M         moveq.l #15,D0
                            	    18M         move.l  D3,D1                                       ; offset on sector in hex
                            	    19M         move.b  #16,D2
                            	    20M         trap    #15
                            	    21M 
                            	    22M         ;moveq.l #6,D0
                            	    23M         ;move.b  #'-',D1                                     
                            	    24M         ;trap    #15
                            	    25M 
                            	    26M         ;moveq.l #15,D0
                            	    27M         ;move.l  (DMA),D1                          ; DMA in hex
                            	    28M         ;move.b  #16,D2
                            	    29M         ;trap    #15
                            	    30M 
                            	    31M         moveq.l #6,D0
                            	    32M         move.b  #' ',D1                                     
                            	    33M         trap    #15
                            	    34M 
                            	    35M         movem.l (A7)+,D0-D3/A0-A3
                            	    36M     ENDIF
                            	   539:     
00:000002C6 41FA063D        	   540:     lea     msgNoSdCardRead,A0
00:000002CA 7201            	   541:     moveq.l #1,D1                                       ; Func code is 1 PRINTLN, A0 preloaded with address of error me
00:000002CC 4E4E            	   542:     trap    #14                         
00:000002CE 7001            	   543:     moveq.l #1,D0                                       ; signal error
                            	   544: 
00:000002D0 23FCFFFFFFFF0000	   545:     move.l  #-1,lastFATSector
00:000002D8 08AE
00:000002DA 243C000000FF    	   546:     move.l  #$ff,D2
00:000002E0 45BC0001        	   547:     chk     #1,D2                                       ; cause a trap to stop execution
00:000002E4 4E75            	   548:     rts                                                 ; should not get here .. 
                            	   549: 
                            	   550: .noDiskReadError:
                            	   551:     debugPrintSector 'R'
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         moveq.l #6,D0                                   
                            	     5M         move.b  #'R',D1                                     
                            	     6M         trap    #15
                            	     7M     
                            	     8M         moveq.l #15,D0
                            	     9M         move.l  (lastFATSector),D1                          ; sector in hex
                            	    10M         move.b  #16,D2
                            	    11M         trap    #15
                            	    12M 
                            	    13M         moveq.l #6,D0
                            	    14M         move.b  #'-',D1                                    
                            	    15M         trap    #15
                            	    16M 
                            	    17M         moveq.l #15,D0
                            	    18M         move.l  D3,D1                                       ; offset on sector in hex
                            	    19M         move.b  #16,D2
                            	    20M         trap    #15
                            	    21M 
                            	    22M         ;moveq.l #6,D0
                            	    23M         ;move.b  #'-',D1                                     
                            	    24M         ;trap    #15
                            	    25M 
                            	    26M         ;moveq.l #15,D0
                            	    27M         ;move.l  (DMA),D1                          ; DMA in hex
                            	    28M         ;move.b  #16,D2
                            	    29M         ;trap    #15
                            	    30M 
                            	    31M         moveq.l #6,D0
                            	    32M         move.b  #' ',D1                                     
                            	    33M         trap    #15
                            	    34M 
                            	    35M         movem.l (A7)+,D0-D3/A0-A3
                            	    36M     ENDIF
                            	   552:     ;jmp    .noCachePrint
                            	   553: 
                            	   554: .noDiskReadRequired:
                            	   555:     ;debugPrintSector 'C'
                            	   556:     
                            	   557: .noCachePrint:
00:000002E6 41FA0374        	   558:     lea    sdBuf,A0
00:000002EA D1C3            	   559:     add.l  D3,A0                                        ; add offset into 512b buffer
00:000002EC 4E75            	   560:     rts
                            	   561: 
                            	   562: WRITE:
                            	   563: ; Write one cpm sector from requested disk, track, sector to dma address
                            	   564: ; Can be a cpmimage on the sd card or the ram disk
00:000002EE 4A3900000370    	   565:     cmp.b   #0,SELDRV
00:000002F4 6632            	   566:     bne     .writeRAMDrive
                            	   567: 
                            	   568:     ; going to write to disk    
00:000002F6 6190            	   569:     bsr     setupReadDisk                               ; sets A0 to point to the right 128 bytes in memory, potentiall
                            	   570:     debugPrintSector 'W'
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         moveq.l #6,D0                                   
                            	     5M         move.b  #'W',D1                                     
                            	     6M         trap    #15
                            	     7M     
                            	     8M         moveq.l #15,D0
                            	     9M         move.l  (lastFATSector),D1                          ; sector in hex
                            	    10M         move.b  #16,D2
                            	    11M         trap    #15
                            	    12M 
                            	    13M         moveq.l #6,D0
                            	    14M         move.b  #'-',D1                                    
                            	    15M         trap    #15
                            	    16M 
                            	    17M         moveq.l #15,D0
                            	    18M         move.l  D3,D1                                       ; offset on sector in hex
                            	    19M         move.b  #16,D2
                            	    20M         trap    #15
                            	    21M 
                            	    22M         ;moveq.l #6,D0
                            	    23M         ;move.b  #'-',D1                                     
                            	    24M         ;trap    #15
                            	    25M 
                            	    26M         ;moveq.l #15,D0
                            	    27M         ;move.l  (DMA),D1                          ; DMA in hex
                            	    28M         ;move.b  #16,D2
                            	    29M         ;trap    #15
                            	    30M 
                            	    31M         moveq.l #6,D0
                            	    32M         move.b  #' ',D1                                     
                            	    33M         trap    #15
                            	    34M 
                            	    35M         movem.l (A7)+,D0-D3/A0-A3
                            	    36M     ENDIF
00:000002F8 227A007C        	   571:     move.l  DMA,A1
00:000002FC 701F            	   572:     move.l  #(128/4-1),d0  
                            	   573:     
                            	   574: .MOVE_LOOP3:
00:000002FE 20D9            	   575:     MOVE.L  (A1)+,(A0)+                                 ; copy long word from source to dest, reverse direction from re
00:00000300 51C8FFFC        	   576:     dbra    D0,.MOVE_LOOP3
                            	   577: 
                            	   578:     ; and write out the 512b buffer to disk
00:00000304 223A05A8        	   579:     move.l  (lastFATSector),D1                          ; set up in SETUPRD
00:00000308 43FA0552        	   580:     lea     sd,A1
00:0000030C 7003            	   581:     moveq.l #3,D0                                       ; write sector function call
00:0000030E 45FA034C        	   582:     lea     sdBuf,A2                                    ; write out sdBuf to disk
00:00000312 4E4D            	   583:     trap    #13
00:00000314 4A80            	   584:     cmp.l   #0,D0                                       ; check return
00:00000316 660C            	   585:     bne     .noWriteError
00:00000318 41FA0609        	   586:     lea     msgNoSdCardWrite,A0
00:0000031C 7201            	   587:     moveq.l #1,D1                                       ; Func code is 1 PRINTLN, A0 preloaded with address of error me
00:0000031E 4E4E            	   588:     trap    #14                                         ; TRAP to firmware    
00:00000320 7001            	   589:     moveq.l #1,D0                                       ; signal error
00:00000322 4E75            	   590:     rts
                            	   591:     
                            	   592: .noWriteError:
                            	   593:     ;move.l #-1,lastFATSector
00:00000324 7000            	   594:     moveq.l #0,D0                                       ; return success
00:00000326 4E75            	   595:     rts                    
                            	   596: 
                            	   597: .writeRAMDrive:
00:00000328 6100FF3E        	   598:     bsr     setupReadRAM                                ; sets A0 to point to the right 128 bytes in memory to read
                            	   599:     debugPrintRAM 'W'
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         exg     A0,A3                                       ; save A0 as trap 15 trashes it
                            	     5M         moveq.l #6,D0                                   
                            	     6M         move.b  #'W',D1                                     
                            	     7M         trap    #15
                            	     8M         exg     A3,A0
                            	     9M 
                            	    10M         moveq.l #15,D0
                            	    11M         move.l  A0,D1                                       ; address in hex
                            	    12M         move.b  #16,D2
                            	    13M         trap    #15
                            	    14M 
                            	    15M         moveq.l #6,D0
                            	    16M         move.b  #'-',D1                                     
                            	    17M         trap    #15
                            	    18M 
                            	    19M         moveq.l #15,D0
                            	    20M         move.l  (DMA),D1                          ; sector in hex
                            	    21M         move.b  #16,D2
                            	    22M         trap    #15
                            	    23M 
                            	    24M         moveq.l #6,D0
                            	    25M         move.b  #' ',D1                                     
                            	    26M         trap    #15
                            	    27M 
                            	    28M         movem.l (A7)+,D0-D3/A0-A3
                            	    29M     ENDIF
00:0000032C 227A0048        	   600:     move.l  DMA,A1
00:00000330 701F            	   601:     move.l  #(128/4-1),d0  
                            	   602: 
                            	   603: .MOVE_LOOP4:
00:00000332 20D9            	   604:     MOVE.L  (A1)+,(A0)+                                 ; copy long word from source to dest, reverse direction from re
00:00000334 51C8FFFC        	   605:     dbra    D0,.MOVE_LOOP4
                            	   606: 
00:00000338 7000            	   607:     moveq.l #0,D0
00:0000033A 4E75            	   608:     rts        
                            	   609: 
                            	   610: FLUSH:
00:0000033C 7000            	   611:     moveq.l #0,D0                                       ; return successful
00:0000033E 4E75            	   612:     rts
                            	   613: 
                            	   614: GETSEG:
00:00000340 203C0000037C    	   615:     move.l #MEMRGN,D0                                   ; return address of mem region table
00:00000346 4E75            	   616:     rts
                            	   617: 
                            	   618: SETEXC:
00:00000348 0281000000FF    	   619:     andi.l  #$ff,D1                                     ; do only for exceptions 0 - 255
                            	   620: 
00:0000034E 0C41002D        	   621:     cmpi    #45,D1
00:00000352 671A            	   622:     beq     NOSET                                       ; don't set trap 13,14,15 as used by rosco firmware
00:00000354 0C41002E        	   623:     cmpi    #46,D1
00:00000358 6714            	   624:     beq     NOSET                        
00:0000035A 0C41002F        	   625:     cmpi    #47,D1
00:0000035E 670E            	   626:     beq     NOSET                       
00:00000360 0C410009        	   627:     cmpi    #9,D1                                       ; don't set trace trap
00:00000364 6708            	   628:     beq     NOSET
00:00000366 E549            	   629:     lsl     #2,D1                                       ; multiply exception number by 4
00:00000368 2041            	   630:     movea.l D1,A0
00:0000036A 2010            	   631:     move.l  (A0),D0                                     ; return old vector value
00:0000036C 2082            	   632:     move.l  D2,(A0)                                     ; insert new vector
                            	   633: 
                            	   634: NOSET:    
00:0000036E 4E75            	   635:     rts
                            	   636: 
                            	   637: * ************************************************************************** *
                            	   638: ; Data
                            	   639: * ************************************************************************** *
                            	   640: 
                            	   641:               align 2                    ; DMA must be at even address
00:00000370 FF              	   642: SELDRV        dc.b        $ff            ; drive requested by seldsk
00:00000371 00              	   643: RESV          dc.b        0              ; reserve byte, padding
00:00000372 0000            	   644: TRACK         dc.w        0              ; track requested by settrk
00:00000374 0000            	   645: SECTOR        dc.w        0              ; max sector value is 0x3FF
00:00000376 00000000        	   646: DMA           dc.l        0
00:0000037A 00              	   647: SELCODE       dc.b        0              ; reserve byte
00:0000037B 00              	   648: RESV1         dc.b        0              ; reserve byte, padding
                            	   649: 
                            	   650: ; memory table must start on an even address
                            	   651:               align 2
00:0000037C 0001            	   652: MEMRGN        dc.w        1              ; 1 memory region
00:0000037E 00020000        	   653:               dc.l        $20000         ; after the CP/M 
00:00000382 000A0000        	   654: 			  dc.l        $A0000         ; 524K bytes, more than enough for bootstrapping  
                            	   655: 
                            	   656: ; disk parameter header - 4mb disk on sd card
                            	   657: DPH0:    
00:00000386 00000000        	   658:     dc.l      0                          ; no sector translation table
00:0000038A 0000            	   659:     dc.w      0                          ; dummy
00:0000038C 0000            	   660:     dc.w      0
00:0000038E 0000            	   661:     dc.w      0
00:00000390 000003DC        	   662:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000394 000003A0        	   663:     dc.l      DPB0                       ; ptr to disk parameter block
00:00000398 00000000        	   664:     dc.l      0                          ; permanent drive, no check vector
00:0000039C 0000045C        	   665:     dc.l      ALV0                       ; ptr to allocation vector
                            	   666: 
                            	   667: DPB0:    
00:000003A0 0020            	   668:     dc.w     32                          ; 32 sectors per track
00:000003A2 04              	   669:     dc.b     4                           ; block shift for BLS of 2048
00:000003A3 0F              	   670:     dc.b     15                          ; block mask for BLS of 2048
00:000003A4 00              	   671:     dc.b     0                           ; extent mask, EXM
00:000003A5 00              	   672:     dc.b     0                           ; dummy fill
00:000003A6 07FF            	   673:     dc.w     2047                        ; DSM, (1024 tracks * 32 sectors * 128 bytes /2048)-1
                            	   674:                            
00:000003A8 00FF            	   675:     dc.w     255                         ; DRM, 256 directory entries
00:000003AA 0000            	   676:     dc.w     0                           ; directory mask
00:000003AC 0000            	   677:     dc.w     0                           ; permanent mounted drive, check size is zero
00:000003AE 0000            	   678:     dc.w     0                           ; no track offset
                            	   679: 
                            	   680: 
                            	   681: ; disk parameter header - 128k ram disk 
                            	   682: DPH1:    
00:000003B0 00000000        	   683:     dc.l      0                          ; no sector translation table
00:000003B4 0000            	   684:     dc.w      0                          ; dummy
00:000003B6 0000            	   685:     dc.w      0
00:000003B8 0000            	   686:     dc.w      0
00:000003BA 000003DC        	   687:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000003BE 000003CA        	   688:     dc.l      DPB1                       ; ptr to disk parameter block
00:000003C2 00000000        	   689:     dc.l      0                          ; permanent drive, no check vector
00:000003C6 0000055C        	   690:     dc.l      ALV1                       ; ptr to allocation vector
                            	   691: 
                            	   692: DPB1:    
00:000003CA 0020            	   693:     dc.w     32                          ; 32 sectors per track
00:000003CC 04              	   694:     dc.b     4                           ; block shift for BLS of 2048
00:000003CD 0F              	   695:     dc.b     15                          ; block mask for BLS of 2048
00:000003CE 00              	   696:     dc.b     0                           ; extent mask, EXM
00:000003CF 00              	   697:     dc.b     0                           ; dummy fill
00:000003D0 003F            	   698:     dc.w     63                          ; DSM, (32 tracks * 32 sectors * 128 bytes /2048)-1
                            	   699:                            
00:000003D2 00FF            	   700:     dc.w     255                         ; DRM, 256 directory entries
00:000003D4 0000            	   701:     dc.w     0                           ; directory mask
00:000003D6 0000            	   702:     dc.w     0                           ; permanent mounted drive, check size is zero
00:000003D8 0000            	   703:     dc.w     0                           ; no track offset
                            	   704: 
                            	   705: 
                            	   706:     align 2
                            	   707: DIRBUF:    
00:000003DC 00              	   708:     ds.b     128                         ; directory buffer
00:000003DD *
                            	   709: 
                            	   710: ALV0:    
00:0000045C 00              	   711: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:0000045D *
                            	   712: 
                            	   713: ALV1:    
00:0000055C 00              	   714: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:0000055D *
                            	   715: 
                            	   716: sdBuf:    
00:0000065C 00              	   717: 	ds.b     512                         ; buffer to read/write sectors to sd card
00:0000065D *
                            	   718: 
                            	   719: sd:
00:0000085C 00              	   720:     ds.b     64                          ; needs to be large enough to hold a sd card structure
00:0000085D *
                            	   721: 
                            	   722: partStartSector:                         ; starting sector for partition 0 on the disk
00:0000089C 00000000        	   723:     dc.l     0
                            	   724: 
                            	   725: rootDirectoryCluster:                    ; cluster of root directory - usually 2
00:000008A0 00000000        	   726:     dc.l     0
                            	   727: 
                            	   728: rootDirectorySector:                     ; sector where root directory starts on sd card
00:000008A4 0000            	   729:     dc.w     0
                            	   730: 
                            	   731: reservedSectors:                         ; sector where FAT table starts on sd card
00:000008A6 0000            	   732:     dc.w     0
                            	   733: 
                            	   734: sectorsPerCluster:                       ; sectors per cluster in word format
00:000008A8 0000            	   735:     dc.w     0
                            	   736: 
                            	   737: CPMImageSector:                          ; sector number of CPM image
00:000008AA 00000000        	   738:     dc.l     0
                            	   739: 
                            	   740: lastFATSector:                           ; last FAT sector read (contents should be in sdBuf)
00:000008AE FFFFFFFF        	   741:     dc.l     -1
                            	   742: 
                            	   743: imageName:
00:000008B2 43504D4449534B20	   744:     dc.b     "CPMDISK IMG",0             ; Nameof CPM image file on SD card
00:000008BA 494D47
00:000008BD 00
                            	   745: 
                            	   746: msgNoSdCardSupport:
00:000008BE 6572726F723A204E	   747:     dc.b     "error: No SD card support detected",0
00:000008C6 6F20534420636172
00:000008CE 6420737570706F72
00:000008D6 7420646574656374
00:000008DE 6564
00:000008E0 00
                            	   748: 
                            	   749: msgNoSdCardInit:
00:000008E1 6572726F723A2055	   750:     dc.b     "error: Unable to initialize SD card",0
00:000008E9 6E61626C6520746F
00:000008F1 20696E697469616C
00:000008F9 697A652053442063
00:00000901 617264
00:00000904 00
                            	   751: 
                            	   752: msgNoSdCardRead:
00:00000905 6572726F723A2055	   753:     dc.b     "error: Unable to read SD card",0
00:0000090D 6E61626C6520746F
00:00000915 2072656164205344
00:0000091D 2063617264
00:00000922 00
                            	   754: 
                            	   755: msgNoSdCardWrite:
00:00000923 6572726F723A2055	   756:     dc.b     "error: Unable to write SD card",0
00:0000092B 6E61626C6520746F
00:00000933 2077726974652053
00:0000093B 442063617264
00:00000941 00
                            	   757: 
                            	   758: msgNoCPMImage:
00:00000942 6572726F723A2043	   759:     dc.b     "error: Cannot find CPMDISK.IMG in root directory of partition 0 on SD card",0
00:0000094A 616E6E6F74206669
00:00000952 6E642043504D4449
00:0000095A 534B2E494D472069
00:00000962 6E20726F6F742064
00:0000096A 69726563746F7279
00:00000972 206F662070617274
00:0000097A 6974696F6E203020
00:00000982 6F6E205344206361
00:0000098A 7264
00:0000098C 00
                            	   760: 


Symbols by name:
ALV0                            00:0000045C
ALV1                            00:0000055C
BIOSBASE                        00:00000168
CONIN                           00:000001D4
CONOUT                          00:000001E2
CONSTAT                         00:000001CA
CPMImageSector                  00:000008AA
DEBUG                            S:00000000
DIRBUF                          00:000003DC
DMA                             00:00000376
DPB0                            00:000003A0
DPB1                            00:000003CA
DPH0                            00:00000386
DPH1                            00:000003B0
FLUSH                           00:0000033C
GETIOB                          00:000001E8
GETSEG                          00:00000340
HOME                            00:000001F2
LISTST                          00:000001EC
LSTOUT                          00:000001E8
MEMRGN                          00:0000037C
NOSET                           00:0000036E
PUN                             00:000001E8
RDR                             00:000001E8
READ                            00:0000023C
RESV                            00:00000371
RESV1                           00:0000037B
SECTOR                          00:00000374
SECTRAN                         00:0000022E
SELCODE                         00:0000037A
SELDRV                          00:00000370
SELDSK                          00:000001FA
SETDMA                          00:00000232
SETDMA2                         00:0000023A
SETEXC                          00:00000348
SETIOB                          00:000001E8
SETSEC                          00:00000226
SETTRK                          00:0000021E
TRACK                           00:00000372
TRAPHNDL                        00:00000158
TRAPNG                          00:00000166
WBOOT                           00:000001C4
WRITE                           00:000002EE
_ccp                             E:000150BC
_init                           00:00000000 EXP
imageName                       00:000008B2
lastFATSector                   00:000008AE
msgNoCPMImage                   00:00000942
msgNoSdCardInit                 00:000008E1
msgNoSdCardRead                 00:00000905
msgNoSdCardSupport              00:000008BE
msgNoSdCardWrite                00:00000923
partStartSector                 00:0000089C
ramDriveLocation                 E:000C0000
reservedSectors                 00:000008A6
rootDirectoryCluster            00:000008A0
rootDirectorySector             00:000008A4
sd                              00:0000085C
sdBuf                           00:0000065C
sectorsPerCluster               00:000008A8
setupReadDisk                   00:00000288
setupReadRAM                    00:00000268

Symbols by value:
00000000 _init
00000000 DEBUG
00000158 TRAPHNDL
00000166 TRAPNG
00000168 BIOSBASE
000001C4 WBOOT
000001CA CONSTAT
000001D4 CONIN
000001E2 CONOUT
000001E8 SETIOB
000001E8 RDR
000001E8 PUN
000001E8 LSTOUT
000001E8 GETIOB
000001EC LISTST
000001F2 HOME
000001FA SELDSK
0000021E SETTRK
00000226 SETSEC
0000022E SECTRAN
00000232 SETDMA
0000023A SETDMA2
0000023C READ
00000268 setupReadRAM
00000288 setupReadDisk
000002EE WRITE
0000033C FLUSH
00000340 GETSEG
00000348 SETEXC
0000036E NOSET
00000370 SELDRV
00000371 RESV
00000372 TRACK
00000374 SECTOR
00000376 DMA
0000037A SELCODE
0000037B RESV1
0000037C MEMRGN
00000386 DPH0
000003A0 DPB0
000003B0 DPH1
000003CA DPB1
000003DC DIRBUF
0000045C ALV0
0000055C ALV1
0000065C sdBuf
0000085C sd
0000089C partStartSector
000008A0 rootDirectoryCluster
000008A4 rootDirectorySector
000008A6 reservedSectors
000008A8 sectorsPerCluster
000008AA CPMImageSector
000008AE lastFATSector
000008B2 imageName
000008BE msgNoSdCardSupport
000008E1 msgNoSdCardInit
00000905 msgNoSdCardRead
00000923 msgNoSdCardWrite
00000942 msgNoCPMImage
000150BC _ccp
000C0000 ramDriveLocation
