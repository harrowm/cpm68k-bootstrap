Sections:
00: "CODE" (0-1CB5)


Source: "bios.asm"
                            	     1: ; Very simple cpm68k bios
                            	     2: ; Malcolm Harrow August 2023 to June 2024
                            	     3: ; Yes, it wasn't that simple ..
                            	     4: 
                            	     5: _ccp               equ $150BC                           ; hard location for _ccp of CPM15000.SR
                            	     6: ramDriveLocation   equ $C0000                           ; memory location for RAM drive
                            	     7: DEBUG              set 0                                ; set to 1 to print debug messgae, 0 turns off  
                            	     8: DEBUG1             set 1                                ; set to 1 to print debug messgae, 0 turns off  
                            	     9: 
                            	    10: 
                            	    11: ; pass in a character to this routine and print it out
                            	    12: ; use to track progress through the code in debug ..
                            	    13: debugPrintChar MACRO
                            	    14:     IFNE DEBUG1
                            	    15:         movem.l D0-D3/A0-A3,-(A7)
                            	    16: 
                            	    17:         moveq.l #6,D0                                   
                            	    18:         move.b  #\1,D1                                     
                            	    19:         trap    #15
                            	    20:     
                            	    21:         movem.l (A7)+,D0-D3/A0-A3
                            	    22:     ENDIF
                            	    23: ENDM
                            	    24: 
                            	    25: ; print sector information read from / written to a SD disk image (or real SD card)
                            	    26: ; pass in a character to this routine to specify type of operation on the sector eg 'R' or 'W'
                            	    27: debugPrintSector MACRO
                            	    28:     IFNE DEBUG
                            	    29:         movem.l D0-D3/A0-A3,-(A7)
                            	    30: 
                            	    31:         moveq.l #6,D0                                   
                            	    32:         move.b  #\1,D1                                     
                            	    33:         trap    #15
                            	    34:     
                            	    35:         moveq.l #15,D0
                            	    36:         move.l  (lastFATSector),D1                          ; sector in hex
                            	    37:         move.b  #16,D2
                            	    38:         trap    #15
                            	    39: 
                            	    40:         moveq.l #6,D0
                            	    41:         move.b  #'-',D1                                    
                            	    42:         trap    #15
                            	    43: 
                            	    44:         moveq.l #15,D0
                            	    45:         move.l  D3,D1                                       ; offset on sector in hex
                            	    46:         move.b  #16,D2
                            	    47:         trap    #15
                            	    48: 
                            	    49:         moveq.l #6,D0
                            	    50:         move.b  #' ',D1                                     
                            	    51:         trap    #15
                            	    52: 
                            	    53:         movem.l (A7)+,D0-D3/A0-A3
                            	    54:     ENDIF
                            	    55: ENDM
                            	    56: 
                            	    57: ; print sector information read from / written to a RAM disk
                            	    58: ; pass in a character to this routine to specify type of operation on the RAM drive eg 'R' or 'W'
                            	    59: ; Assuem A0 is already set up to point to the RAM being moved
                            	    60: debugPrintRAM MACRO
                            	    61:     IFNE DEBUG
                            	    62:         movem.l D0-D3/A0-A3,-(A7)
                            	    63: 
                            	    64:         exg     A0,A3                                       ; save A0 as trap 15 trashes it
                            	    65:         moveq.l #6,D0                                   
                            	    66:         move.b  #\1,D1                                     
                            	    67:         trap    #15
                            	    68:         exg     A3,A0
                            	    69: 
                            	    70:         moveq.l #15,D0
                            	    71:         move.l  A0,D1                                       ; address in hex
                            	    72:         move.b  #16,D2
                            	    73:         trap    #15
                            	    74: 
                            	    75:         moveq.l #6,D0
                            	    76:         move.b  #'-',D1                                     
                            	    77:         trap    #15
                            	    78: 
                            	    79:         moveq.l #15,D0
                            	    80:         move.l  (DMA),D1                          ; sector in hex
                            	    81:         move.b  #16,D2
                            	    82:         trap    #15
                            	    83: 
                            	    84:         moveq.l #6,D0
                            	    85:         move.b  #' ',D1                                     
                            	    86:         trap    #15
                            	    87: 
                            	    88:         movem.l (A7)+,D0-D3/A0-A3
                            	    89:     ENDIF
                            	    90: ENDM
                            	    91: 
                            	    92: ; print the number at address \1 in hex
                            	    93: debugPrintNum MACRO
                            	    94:         movem.l D0-D3/A0-A3,-(A7)
                            	    95:         moveq.l #15,D0
                            	    96:         move.l  (\1),D1
                            	    97:         move.b  #16,D2
                            	    98:         trap    #15
                            	    99:         movem.l (A7)+,D0-D3/A0-A3
                            	   100: ENDM
                            	   101: 
                            	   102: ; Macros to call traps and save any registers that are changed
                            	   103: 
                            	   104: ; print a string using trap 14,1 whilst preseving register A0
                            	   105: PrintStr MACRO
                            	   106:     movem.l D0-D3/A0-A3,-(A7)
                            	   107:     lea     \1,A0
                            	   108:     moveq.l #1,D1                                       
                            	   109:     trap    #14  
                            	   110:     movem.l (A7)+,D0-D3/A0-A3
                            	   111: ENDM
                            	   112: 
                            	   113: 
                            	   114: _init::    
                            	   115:     ; at this stage, we have loaded from the SDCARD, so we know its valid, no need to re-init
                            	   116:     ; need to find the starting sector of the CPM disk image on the sd card.
                            	   117:     ; To do this we will trawl through the FAT32 boot record etc
                            	   118: 
                            	   119:     ; to do this:
                            	   120:     ;   - read the MBR, block 0 and note:
                            	   121:     ;     - number of reserved sectors, 0x0E, word (eg 20 00)
                            	   122:     ;     - logical sectors per FAT, 0x24, long  (eg f1 03 00 00)
                            	   123:     ;     - number of fats, 0x10, byte (eg 02)
                            	   124:     ;   - This enables us to calculate:
                            	   125:     ;     - start of FAT table (sector after number of reserved sectors - 32 or 0x4000
                            	   126:     ;     - start of root directory,  Logical sectors per FAT (0x24) * Number of FATs (0x10) + Reserved logical sectors
                            	   127:     ;   - The root directory is arranged 32 bytes per entry.  We will assume our CPM disk image is in the root and call
                            	   128:     
                            	   129:     ; check sd card support
00:00000000 48E7F0F0        	   130:     movem.l D0-D3/A0-A3,-(A7)
00:00000004 7000            	   131:     moveq.l #0,D0
00:00000006 4E4D            	   132:     trap    #13
00:00000008 B0BC1234FEDC    	   133:     cmp.l   #$1234FEDC,D0                               ; check magic return
00:0000000E 6600021E        	   134:     bne     .errNoSDsupport
00:00000012 4CDF0F0F        	   135:     movem.l (A7)+,D0-D3/A0-A3
                            	   136: 
                            	   137:     ; init the sd card and get sd card structure back
00:00000016 48E7F0F0        	   138:     movem.l D0-D3/A0-A3,-(A7)
00:0000001A 43FA1ACC        	   139:     lea     sd,A1
00:0000001E 7001            	   140:     moveq.l #1,D0                                       
00:00000020 4E4D            	   141:     trap    #13
00:00000022 4A80            	   142:     cmp.l   #0,D0                                       ; check return
00:00000024 66000220        	   143:     bne     .errNoSDinit
00:00000028 4CDF0F0F        	   144:     movem.l (A7)+,D0-D3/A0-A3
                            	   145: 
                            	   146:     ; read the MBR from sector 0 on the disk so we can read the partition table
00:0000002C 48E7F0F0        	   147:     movem.l D0-D3/A0-A3,-(A7)
00:00000030 43FA1AB6        	   148:     lea     sd,A1
00:00000034 7002            	   149:     moveq.l #2,D0                                       ; read the MBR from the sd card 
00:00000036 7200            	   150:     moveq.l #0,D1                                       ; sector number to read
00:00000038 45FA18AE        	   151:     lea     sdBuf,A2
00:0000003C 4E4D            	   152:     trap    #13
00:0000003E 4A80            	   153:     cmp.l   #0,D0                                       ; check return
00:00000040 6700021C        	   154:     beq     .errNoReadDiskMBR
00:00000044 4CDF0F0F        	   155:     movem.l (A7)+,D0-D3/A0-A3
                            	   156: 
                            	   157:     ; now we need to check the disk MBR for a partition table and get the offset to the first partition
                            	   158:     ; this is a bodge .. CPM has to be on the first partition, partiton 0 and 0x1BE on the disk MBR
                            	   159:     ; The code should really check all 4 partitions ..
                            	   160: 
                            	   161:     ; as we read longs and words off of the MBR we have to take endianess into account and switch the byte order 
                            	   162:     ; as we are on the 68000 CPU
00:00000048 2C3A1A64        	   163:     move.l  $1c6+sdBuf,D6                               ; read LBA start from partition 0
00:0000004C E15E            	   164:     rol.w   #8,D6
00:0000004E 4846            	   165:     swap    D6
00:00000050 E15E            	   166:     rol.w   #8,D6
00:00000052 23C600001B28    	   167:     move.l  D6,partStartSector
                            	   168: 
                            	   169:     ; read the MBR from sector 0 of the partition so we can calculate position of the root diectory and hence the CPM i
00:00000058 48E7F0F0        	   170:     movem.l D0-D3/A0-A3,-(A7)
00:0000005C 43FA1A8A        	   171:     lea     sd,A1
00:00000060 7002            	   172:     moveq.l #2,D0                                       ; read the MBR from the sd card 
00:00000062 2206            	   173:     move.l  D6,D1                                       ; sector number to read - partStartSector
00:00000064 45FA1882        	   174:     lea     sdBuf,A2
00:00000068 4E4D            	   175:     trap    #13
00:0000006A 4A80            	   176:     cmp.l   #0,D0                                       ; check return
00:0000006C 67000208        	   177:     beq     .errNoReadPartMBR
00:00000070 4CDF0F0F        	   178:     movem.l (A7)+,D0-D3/A0-A3
                            	   179: 
00:00000074 3C3A1880        	   180:     move.w  $e+sdBuf,D6                                 ; number of reserved sectors from MBR.  Reversed due to endiane
00:00000078 E15E            	   181:     rol.w   #8,D6
00:0000007A 33C600001B32    	   182:     move.w  D6,reservedSectors
                            	   183: 
00:00000080 2C3A1892        	   184:     move.l  $2c+sdBuf,D6                                ; read root director cluster (usually 2)
00:00000084 E15E            	   185:     rol.w   #8,D6
00:00000086 4846            	   186:     swap    D6
00:00000088 E15E            	   187:     rol.w   #8,D6
00:0000008A 23C600001B2C    	   188:     move.l  D6,rootDirectoryCluster
                            	   189: 
                            	   190:     ; up until the root directory, we use sectors; after the root directory we have to deal with clusters (groups of se
                            	   191:     ; see the diagram here: https://eric-lo.gitbook.io/lab9-filesystem/overview-of-fat32#
                            	   192:     ; we need to store the number of sectors per cluster for later use
00:00000090 7C00            	   193:     moveq.l #0,D6
00:00000092 1C3A1861        	   194:     move.b  $d+sdBuf,D6                                 ; read number of sectors per cluster
00:00000096 33C600001B34    	   195:     move.w  D6,sectorsPerCluster                        ; save as a word for later mulu
                            	   196: 
                            	   197:     ; Calculate the sector of the root directory: 
                            	   198:     ; = sectors per FAT * number of FATs + number of reserved sectors
                            	   199:     ; += partStartSector to allow for the start of the partition on the disk
00:0000009C 2A3A186E        	   200:     move.l  $24+sdBuf,D5                                ; read sectors per FAT
00:000000A0 E15D            	   201:     rol.w   #8,D5
00:000000A2 4845            	   202:     swap    D5
00:000000A4 E15D            	   203:     rol.w   #8,D5
                            	   204:     
00:000000A6 7C00            	   205:     moveq.l #0,D6                                       ; read number of FAT tables
00:000000A8 1C3A184E        	   206:     move.b  $10+sdBuf,D6
                            	   207: 
00:000000AC CCC5            	   208:     mulu.w  D5,D6
00:000000AE DC7A1A82        	   209:     add.w   reservedSectors,D6
00:000000B2 DCBA1A74        	   210:     add.l   partStartSector,D6                          ; partStartSector is a long
00:000000B6 33C600001B30    	   211:     move.w  D6,rootDirectorySector
                            	   212: 
                            	   213: 
                            	   214: ;    sector = sector of start of root directory
                            	   215: ;    entry = 0
                            	   216: ;    while (1) {
                            	   217: ;      offset = entry % 16
                            	   218: ;      if offset == 0 {
                            	   219: ;        // read next sector
                            	   220: ;        read next sector
                            	   221: ;        increment sector
                            	   222: ;      };;
                            	   223: ;
                            	   224: ;      directory_entry = offset * 32 plus buffer start
                            	   225: ;
                            	   226: ;      if directory_entry[0] == 0 { // end of root directory
                            	   227: ;        message failure
                            	   228: ;        return failure
                            	   229: ;      }
                            	   230: ;
                            	   231: ;      if directory_entry[0xb] & 0x10 { // subdirectory
                            	   232: ;        continue
                            	   233: ;      }
                            	   234: ;
                            	   235: ;      if directory entry[0xb] == 0xf { // record contains a long file name
                            	   236: ;        continue
                            	   237: ;      }
                            	   238: ;
                            	   239: ;      if strncmp(directory entry, "CPMDISK IMG", 11) {
                            	   240: ;        // found file, might have to ignore case here, lets see
                            	   241: ;        // record sector file starts and file length
                            	   242: ;        block = entry[20,21] << 16 + entry[26,27]
                            	   243: ;        // both of these are store lsb first eg length of 0x7e84 is stored 84 7e 00 00
                            	   244: ;        return success
                            	   245: ;      }
                            	   246: ;      entry++
                            	   247: ;    }
                            	   248: 
                            	   249: 
                            	   250:     ; search the FAT to try to find the CPM disk image
00:000000BC 7600            	   251:     moveq.l #0,D3                                       ; sector to read
00:000000BE 7800            	   252:     moveq.l #0,D4                                       ; directory entry in sector.  Sector is 512b, directory table i
                            	   253: 
                            	   254: .startDirectoryEntry:
00:000000C0 2A04            	   255:     move.l  D4,D5
00:000000C2 CABC0000000F    	   256:     and.l   #15,D5                                      ; only look at last 4 bits, we want to calculate (directory ent
00:000000C8 6628            	   257:     bne     .noReadRequired                             ; we dont need to read a new sector from the sd card
                            	   258: 
                            	   259:     ; read the MBR from sector 0 so we can calculate position of the MBR and root diectory in the CPM image
00:000000CA 48E7F0F0        	   260:     movem.l D0-D3/A0-A3,-(A7)
00:000000CE 43FA1A18        	   261:     lea     sd,A1
00:000000D2 7002            	   262:     moveq.l #2,D0                                       ; read sector trap
00:000000D4 7200            	   263:     moveq.l #0,D1                                       ; required for r68k to work correctly
00:000000D6 323A1A58        	   264:     move.w  rootDirectorySector,D1
00:000000DA D243            	   265:     add.w   D3,D1                                       ; sector number to read plus offset to rootDirectoryCluster
00:000000DC 45FA180A        	   266:     lea     sdBuf,A2
00:000000E0 4E4D            	   267:     trap    #13
00:000000E2 4A80            	   268:     cmp.l   #0,D0                                       ; check return
00:000000E4 4A80            	   269:     cmp.l   #0,D0                                       ; check return
00:000000E6 670001A6        	   270:     beq     .errReadError
00:000000EA 4CDF0F0F        	   271:     movem.l (A7)+,D0-D3/A0-A3
                            	   272: 
00:000000EE 5283            	   273:     addq.l  #1,D3                                       ; increment next sector to read
00:000000F0 7800            	   274:     moveq.l #0,D4                                       ; reset directory entry to zero 
                            	   275: 
                            	   276: .noReadRequired:
00:000000F2 2A04            	   277:     move.l  D4,D5                                       ; D4 contains directory record
00:000000F4 EB8D            	   278:     lsl.l   #5,D5                                       ; multiply offset by 32 to get to start of directory record
00:000000F6 DABC000018E8    	   279:     add.l   #sdBuf,D5
00:000000FC 2A45            	   280:     movea.l D5,A5
00:000000FE 1C15            	   281:     move.b  (A5),D6
00:00000100 4A06            	   282:     tst.b   D6                                          ; reached end of root directory entries
00:00000102 670000C0        	   283:     beq     .dirEnd
                            	   284: 
                            	   285: .notDirEnd:
00:00000106 1C2D000B        	   286:     move.b  $b(A5),D6
00:0000010A BC3C0010        	   287:     cmp.b   #$10,D6
00:0000010E 670000AE        	   288:     beq     .nextDir                                    ; skip subdirectories entries
00:00000112 BC3C000F        	   289:     cmp.b   #$f,D6
00:00000116 670000A6        	   290:     beq     .nextDir                                    ; skip long filename entries
                            	   291: 
                            	   292:     ; check to see if we have found the CPM Image file
                            	   293:     ; Check that name starts "CPMD"
00:0000011A 49FA1A22        	   294:     LEA     imageName,A4
00:0000011E BB8C            	   295:     cmp.l   (A4)+,(A5)+
00:00000120 6600009C        	   296:     bne     .nextDir
                            	   297: 
                            	   298:     ; Check that the name ends in "IMG*"    
00:00000124 584C            	   299:     addq    #4,A4
00:00000126 584D            	   300:     addq    #4,A5
00:00000128 2C15            	   301:     move.l  (A5),D6                                      ; wipe last byte from FAT to compare to 0 from imageName
00:0000012A 4206            	   302:     clr.b   D6
00:0000012C BC94            	   303:     cmp.l   (A4),D6
00:0000012E 6600008E        	   304:     bne     .nextDir
                            	   305: 
                            	   306:     ; Now look at the middle "ISK*"
                            	   307:     ; The * can be a space or A..P
00:00000132 594C            	   308:     subq    #4,A4
00:00000134 594D            	   309:     subq    #4,A5
                            	   310: 
00:00000136 2A14            	   311:     move.l  (A4),D5                                      ; save last characters
00:00000138 2C1D            	   312:     move.l  (A5)+,D6                                     ; increment A5 so that its aligned for below                  
00:0000013A 1A06            	   313:     move.b  D6,D5                                        ; make last byte the same
00:0000013C BC85            	   314:     cmp.l   D5,D6                                        ; Check that "ISK" is the same
00:0000013E 667E            	   315:     bne     .nextDir
                            	   316: 
00:00000140 CCBC000000FF    	   317:     and.l   #$FF,D6                                      ; clear top 3 bytes
                            	   318:     ; Now left to check last character
00:00000146 BC3C0020        	   319:     cmp.b   #' ',D6                                      ; CMPDISK.IMG found
00:0000014A 671E            	   320:     beq     .foundCMPDISK
                            	   321: 
                            	   322: .checkdriveletter
00:0000014C 9C3C0041        	   323:     sub.b   #'A',D6
00:00000150 6B06            	   324:     bmi     .notvaliddrive
00:00000152 BC3C000F        	   325:     cmp.b   #15,D6
00:00000156 6F16            	   326:     ble     .validdrive
                            	   327:  
                            	   328: .notvaliddrive
                            	   329:     ; MESSAGE IGNOREING
                            	   330:     PrintStr msgIgnoreMapDrive
00:00000158 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:0000015C 41FA1B27        	     2M     lea     msgIgnoreMapDrive,A0
00:00000160 7201            	     3M     moveq.l #1,D1                                       
00:00000162 4E4E            	     4M     trap    #14  
00:00000164 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
00:00000168 6654            	   331:     bne     .nextDir
                            	   332: 
                            	   333: .foundCMPDISK
                            	   334:     ; change D6 to 16 (one past end of CPMDRIVE table) and fall through
00:0000016A 1C3C0010        	   335:     move.b  #16,D6
                            	   336:    
                            	   337: .validdrive
                            	   338:     ; found file, A5 will now be pointing at entry[8] so adjust offsets to compensate
                            	   339:     ;        block = entry[20,21] << 16 + entry[26,27]
                            	   340:     ; get starting block of CPMDISK.IMG
00:0000016E 3A2D000C        	   341:     move.w  $c(A5),D5                                   
00:00000172 E15D            	   342:     rol.w   #8,D5
00:00000174 4845            	   343:     swap    D5
00:00000176 3A2D0012        	   344:     move.w  $12(A5),D5
00:0000017A E15D            	   345:     rol.w   #8,D5
                            	   346: 
00:0000017C 9ABA19AE        	   347:     sub.l   (rootDirectoryCluster),D5                   ; allow for the position of the root directory (usually 2)
00:00000180 CAFA19B2        	   348:     mulu.w  (sectorsPerCluster),D5  
                            	   349: 
                            	   350:     ; for efficiency we will point CPMImageSector at the actual block on the sd card
00:00000184 DA7A19AA        	   351:     add.w   (rootDirectorySector),D5
                            	   352: 
00:00000188 1406            	   353:     move.b  D6,D2                                       ; Save for printing drive later
                            	   354: 
00:0000018A 41FA03BA        	   355:     lea     CPMDISK,A0
00:0000018E DC06            	   356:     add.b   D6,D6
00:00000190 DC06            	   357:     add.b   D6,D6
00:00000192 D1C6            	   358:     add.l   D6,A0
00:00000194 2085            	   359:     move.l  D5,(A0)
                            	   360: 
                            	   361:     ; Print out a message about the mapping (if not CPMDISK.IMG, this printed later after other drives assigned)
                            	   362:     ; HACK sort this out msgMapDriveSource
                            	   363: 
00:00000196 B43C0010        	   364:     cmp.b   #16,D2                                      ; Skip over CPMDISK.IMG 
00:0000019A 6722            	   365:     beq     .nextDir
                            	   366: 
00:0000019C 123C0041        	   367:     move.b  #'A',D1                                      
00:000001A0 D202            	   368:     add.b   D2,D1
00:000001A2 13C100001C82    	   369:     move.b  D1,msgMapDriveLetter
00:000001A8 13C100001C79    	   370:     move.b  D1,msgMapDriveSource
                            	   371: 
                            	   372:     PrintStr msgMapDrive
00:000001AE 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:000001B2 41FA1AB7        	     2M     lea     msgMapDrive,A0
00:000001B6 7201            	     3M     moveq.l #1,D1                                       
00:000001B8 4E4E            	     4M     trap    #14  
00:000001BA 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
                            	   373: 
                            	   374: .nextDir:
00:000001BE 5284            	   375:     addq.l  #1,D4                                       ; look at next directory entry
00:000001C0 6000FEFE        	   376:     bra     .startDirectoryEntry
                            	   377: 
                            	   378:     ; So now we have read the whole directory and need to do some tidy up:
                            	   379:     ;   if we have found "CPMDISK.IMG" then we need to place this in the table if possible 
                            	   380:     ;   we need to try to place the RAMDISK in the mapping table
                            	   381:     ; Why have CPMDISK.IMG ? TO me most people will only want one disk .. and this is the best name :o
                            	   382: 
                            	   383: .dirEnd
00:000001C4 43FA0380        	   384:     lea     CPMDISK,A1
00:000001C8 223A03BC        	   385:     move.l  (CPMDISK+64),D1                             ; "CPMDISK.IMG" sector if found stored at 17th entry in table
00:000001CC 760F            	   386:     moveq   #15,D3                                      ; looping variable, 16=max number of drives, -1 for dbra
                            	   387: .nextdiskmap
00:000001CE 4A91            	   388:     tst.l   (A1)
00:000001D0 6624            	   389:     bne     .continue                                   ; not an empty slot, try to loop around
                            	   390: 
00:000001D2 4A01            	   391:     tst.b   D1                                          ; see if we need to map CPMDISK.IMG
00:000001D4 6728            	   392:     beq     .sortoutramdrive
00:000001D6 2281            	   393:     move.l  D1,(A1)
                            	   394: 
                            	   395:     ; format drive letter for message
00:000001D8 123C0050        	   396:     move.b  #'A'+15,D1                                      
00:000001DC 9203            	   397:     sub.b   D3,D1
00:000001DE 13C100001C51    	   398:     move.b  D1,msgMapCPMDriveLetter
                            	   399: 
                            	   400:     PrintStr msgMapCPMDrive
00:000001E4 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:000001E8 41FA1A51        	     2M     lea     msgMapCPMDrive,A0
00:000001EC 7201            	     3M     moveq.l #1,D1                                       
00:000001EE 4E4E            	     4M     trap    #14  
00:000001F0 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
00:000001F4 7200            	   401:     moveq   #0,D1                                       ; note that CPMDISK.IMG now mapped
                            	   402:     
                            	   403: .continue
00:000001F6 5849            	   404:     addq    #4,A1    
00:000001F8 51CBFFD4        	   405:     dbra    D3,.nextdiskmap
                            	   406: 
                            	   407:     ; Need to check is we failed to map CPMDRIVE.IMG and RAMDRIVE and message
00:000001FC 6024            	   408:     bra     .finish
                            	   409: 
                            	   410: .sortoutramdrive
00:000001FE 720F            	   411:     moveq   #15,D1                                      ; reuse D1
00:00000200 9203            	   412:     sub.b   D3,D1
00:00000202 13C10000058A    	   413:     move.b  D1,RAMDRIVE                                 ; now that we fix up RAMDRIVE we are done, so can fall out of l
                            	   414: 
                            	   415:     ; message RAM drive mapping
00:00000208 D23C0041        	   416:     add.b   #'A',D1
00:0000020C 13C100001C68    	   417:     move.b  D1,msgMapRAMDriveLetter
                            	   418:     PrintStr msgMapRAMDrive
00:00000212 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:00000216 41FA1A3C        	     2M     lea     msgMapRAMDrive,A0
00:0000021A 7201            	     3M     moveq.l #1,D1                                       
00:0000021C 4E4E            	     4M     trap    #14  
00:0000021E 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
                            	   419: 
                            	   420: .finish
00:00000222 21FC000002A6008C	   421:     move.l  #TRAPHNDL,$8c                               ; set up trap #3 handler
00:0000022A 7000            	   422:     moveq.l #0,D0                                       ; log on disk A, user 0
00:0000022C 4E75            	   423:     rts
                            	   424: 
                            	   425: ; errors during _init 
                            	   426: .errNoSDsupport
00:0000022E 4CDF0F0F        	   427:     movem.l (A7)+,D0-D3/A0-A3
                            	   428:     PrintStr msgNoSdCardSupport
00:00000232 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:00000236 41FA1912        	     2M     lea     msgNoSdCardSupport,A0
00:0000023A 7201            	     3M     moveq.l #1,D1                                       
00:0000023C 4E4E            	     4M     trap    #14  
00:0000023E 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
00:00000242 7001            	   429:     moveq.l #1,D0                                       ; signal error
00:00000244 4E75            	   430:     rts
                            	   431: 
                            	   432:  .errNoSDinit:
00:00000246 4CDF0F0F        	   433:     movem.l (A7)+,D0-D3/A0-A3
                            	   434:     PrintStr msgNoSdCardInit
00:0000024A 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:0000024E 41FA191D        	     2M     lea     msgNoSdCardInit,A0
00:00000252 7201            	     3M     moveq.l #1,D1                                       
00:00000254 4E4E            	     4M     trap    #14  
00:00000256 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
00:0000025A 7001            	   435:     moveq.l #1,D0                                       ; signal error
00:0000025C 4E75            	   436:     rts
                            	   437: 
                            	   438: .errNoReadDiskMBR:
00:0000025E 4CDF0F0F        	   439:     movem.l (A7)+,D0-D3/A0-A3
                            	   440:     PrintStr msgNoSdCardReadMBR
00:00000262 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:00000266 41FA1929        	     2M     lea     msgNoSdCardReadMBR,A0
00:0000026A 7201            	     3M     moveq.l #1,D1                                       
00:0000026C 4E4E            	     4M     trap    #14  
00:0000026E 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
00:00000272 7001            	   441:     moveq.l #1,D0                                       ; signal error
00:00000274 4E75            	   442:     rts
                            	   443: 
                            	   444: .errNoReadPartMBR:
00:00000276 4CDF0F0F        	   445:     movem.l (A7)+,D0-D3/A0-A3
                            	   446:     PrintStr msgNoSdCardRead
00:0000027A 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:0000027E 41FA1933        	     2M     lea     msgNoSdCardRead,A0
00:00000282 7201            	     3M     moveq.l #1,D1                                       
00:00000284 4E4E            	     4M     trap    #14  
00:00000286 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
00:0000028A 7001            	   447:     moveq.l #1,D0                                       ; signal error
00:0000028C 4E75            	   448:     rts
                            	   449: 
                            	   450: .errReadError:    
00:0000028E 4CDF0F0F        	   451:     movem.l (A7)+,D0-D3/A0-A3
                            	   452:     PrintStr msgNoSdCardRead
00:00000292 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:00000296 41FA191B        	     2M     lea     msgNoSdCardRead,A0
00:0000029A 7201            	     3M     moveq.l #1,D1                                       
00:0000029C 4E4E            	     4M     trap    #14  
00:0000029E 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
00:000002A2 7001            	   453:     moveq.l #1,D0                                       ; signal error
00:000002A4 4E75            	   454:     rts
                            	   455: 
                            	   456: 
                            	   457: TRAPHNDL:
00:000002A6 0C400017        	   458:     cmpi    #23,D0                                      ; Function call in range ?
00:000002AA 6408            	   459:     bcc     TRAPNG
                            	   460: 
00:000002AC E588            	   461:     lsl.l   #2,D0                                       ; change function call to offset by multiplting by 4
00:000002AE 207B0006        	   462:     move.l  BIOSBASE(PC,D0),A0          ; ... and calc offset into table...
00:000002B2 4E90            	   463:     jsr     (A0)                        ; ... then jump there
                            	   464: 
                            	   465: TRAPNG:
00:000002B4 4E73            	   466:     rte
                            	   467: 
                            	   468: BIOSBASE:
00:000002B6 00000000        	   469:     dc.l    _init
00:000002BA 00000312        	   470:     dc.l    WBOOT
00:000002BE 00000318        	   471:     dc.l    CONSTAT
00:000002C2 00000332        	   472:     dc.l    CONIN
00:000002C6 00000348        	   473:     dc.l    CONOUT
00:000002CA 00000356        	   474:     dc.l    LSTOUT
00:000002CE 00000358        	   475:     dc.l    PUN
00:000002D2 0000035C        	   476:     dc.l    RDR
00:000002D6 0000036C        	   477:     dc.l    HOME
00:000002DA 00000374        	   478:     dc.l    SELDSK
00:000002DE 000003BC        	   479:     dc.l    SETTRK
00:000002E2 000003C4        	   480:     dc.l    SETSEC
00:000002E6 000003D0        	   481:     dc.l    SETDMA
00:000002EA 000003DA        	   482:     dc.l    READ
00:000002EE 000004A2        	   483:     dc.l    WRITE
00:000002F2 00000366        	   484:     dc.l    LISTST
00:000002F6 000003CC        	   485:     dc.l    SECTRAN
00:000002FA 000003D8        	   486:     dc.l    MISSING
00:000002FE 00000500        	   487:     dc.l    GETSEG
00:00000302 00000362        	   488:     dc.l    GETIOB
00:00000306 00000362        	   489:     dc.l    SETIOB
00:0000030A 000004FC        	   490:     dc.l    FLUSH
00:0000030E 00000508        	   491:     dc.l    SETEXC
                            	   492: 
                            	   493: 
                            	   494: WBOOT:  
00:00000312 4EF9000150BC    	   495:     jmp     _ccp
                            	   496: 
                            	   497: CONSTAT: 
                            	   498: ; Check for keyboard input. Set d0 to 1 if keyboard input is pending, otherwise set to 0.
00:00000318 48E74000        	   499:     movem.l D1,-(A7)
00:0000031C 7007            	   500:     moveq.l #7,D0                        ; use EASy68k trap 15 task 7
00:0000031E 4E4F            	   501:     trap    #15                          ; d1.b = 1 if keyboard ready, otherwise = 0
00:00000320 7000            	   502:     moveq.l #0,D0
                            	   503: 
00:00000322 B23C0001        	   504:     cmp.b   #1,D1
00:00000326 6604            	   505:     bne     .end_constat
                            	   506: 
00:00000328 103C00FF        	   507:     move.b  #$FF,D0                      ; return 0xFF if keyboard ready according to CPM68k manual
                            	   508: .end_constat:
00:0000032C 4CDF0002        	   509:     movem.l (A7)+,D1
00:00000330 4E75            	   510:     rts
                            	   511: 
                            	   512: CONIN:    
                            	   513: ; Read single ASCII character from the keyboard into d0
                            	   514: ; Rosco implementation of this trap waits for input, which is what we need for CPM68k
00:00000332 48E77FFE        	   515:     movem.l D1-D7/A0-A6,-(A7)
00:00000336 7005            	   516:     moveq.l #5,D0                        ; use EASy68k trap 15 task 5
00:00000338 4E4F            	   517:     trap    #15                          ; d1.b contains the ascii character
00:0000033A 1001            	   518:     move.b  D1,D0      
00:0000033C C0BC0000007F    	   519:     and.l   #$7f,D0                      ; only use 7 bit character set
00:00000342 4CDF7FFE        	   520:     movem.l (A7)+,D1-D7/A0-A6
00:00000346 4E75            	   521:     rts
                            	   522: 
                            	   523: CONOUT: 
                            	   524: ; Display single ASCII character in d1
00:00000348 48E7FFFE        	   525:     movem.l D0-D7/A0-A6,-(A7)
00:0000034C 7006            	   526:     moveq.l #6,D0                        ; use EASy68k trap 15 task 6
00:0000034E 4E4F            	   527:     trap    #15
00:00000350 4CDF7FFF        	   528:     movem.l (A7)+,D0-D7/A0-A6
00:00000354 4E75            	   529:     rts                                  ; and exit
                            	   530: 
                            	   531: LSTOUT:    
00:00000356 4E75            	   532:     rts
                            	   533: 
                            	   534: PUN:
00:00000358 3001            	   535:     move.w  D1,D0
00:0000035A 4E75            	   536:     rts
                            	   537: 
                            	   538: RDR:
00:0000035C 303C001A        	   539:     move.w  #$1a,D0                      ; return end of file as per CPM68k manual
00:00000360 4E75            	   540:     rts
                            	   541: 
                            	   542: GETIOB:
                            	   543: SETIOB:
00:00000362 7000            	   544:     moveq.l #0,D0
00:00000364 4E75            	   545:     rts
                            	   546: 
                            	   547: LISTST:    
00:00000366 103C00FF        	   548:     move.b #$ff,D0
00:0000036A 4E75            	   549:     rts
                            	   550: 
                            	   551: HOME:    
00:0000036C 427900000532    	   552:     clr.w  TRACK
00:00000372 4E75            	   553:     rts
                            	   554: 
                            	   555: SELDSK:    
                            	   556: ; drive should be in d1.b
                            	   557: ; now trashes A0
                            	   558: 
                            	   559:     ; as spotted by jjlov, D1 can come in dirty, so clean
00:00000374 C2BC0000000F    	   560:     and.l   #15,D1
                            	   561: 
00:0000037A B23A020E        	   562:     cmp.b   (RAMDRIVE),D1
00:0000037E 672A            	   563:     beq     .selram
                            	   564: 
00:00000380 7000            	   565:     moveq   #0,D0
00:00000382 1001            	   566:     move.b  D1,D0                   ; save for later
                            	   567: 
00:00000384 D201            	   568:     add.b   D1,D1                   ; Multiply D1 by 4 to change to address
00:00000386 D201            	   569:     add.b   D1,D1
00:00000388 41FA01BC        	   570:     lea     CPMDISK,A0
00:0000038C 22301800        	   571:     move.l  (0,A0,D1.L),D1          ; move sector for the requested disk to D1
                            	   572:     
00:00000390 6726            	   573:     beq     .seldsk_error           ; zero so no disk mapped to this slot
                            	   574: 
00:00000392 23C100001B36    	   575:     move.l  D1,(CPMImageSector)     ; set up FAT32 sector for disk image for read/write routine
                            	   576:                                     
00:00000398 13C000000530    	   577:     move.b  D0,SELDRV               ; set up selected drive
00:0000039E C0FC001A        	   578:     mulu    #26,D0                  ; 26 is the size of the DPH 
00:000003A2 41FA01E8        	   579:     lea     DPH0,A0
00:000003A6 D088            	   580:     add.l   A0,D0                   ; return D0 pointing to the right DPH
00:000003A8 4E75            	   581:     rts
                            	   582: 
                            	   583: .selram
00:000003AA 13C100000530    	   584:     move.b  D1,SELDRV
00:000003B0 203C0000073C    	   585:     move.l  #DPH1,D0
00:000003B6 4E75            	   586:     rts
                            	   587:     
                            	   588: .seldsk_error
00:000003B8 7000            	   589:     moveq   #0,D0                   ; Signal error
00:000003BA 4E75            	   590:     rts
                            	   591: 
                            	   592: SETTRK:    
00:000003BC 33C100000532    	   593:     move.w  D1,TRACK
00:000003C2 4E75            	   594:     rts
                            	   595: 
                            	   596: SETSEC:    
00:000003C4 33C100000534    	   597:     move.w  D1,SECTOR
00:000003CA 4E75            	   598:     rts
                            	   599: 
                            	   600: SECTRAN:
                            	   601: ;    no sector translate, put d1 into d0 and return
00:000003CC 3001            	   602:     move.w  D1,D0
00:000003CE 4E75            	   603:     rts
                            	   604: 
                            	   605: SETDMA:
00:000003D0 23C100000536    	   606:     move.l  D1,DMA
00:000003D6 4E75            	   607:     rts
                            	   608: 
                            	   609: MISSING:
                            	   610:     ; this number is missing from the table in the
                            	   611:     ; CPM 68k documentation, doesn't seem to be ever called
00:000003D8 4E75            	   612:     rts
                            	   613: 
                            	   614: READ:
                            	   615: ; Read one cpm sector from requested disk, track, sector to dma address
                            	   616: ; Can be a cpmimage on the sd card or the ram disk
00:000003DA 103A01AE        	   617:     move.b  (RAMDRIVE),D0
00:000003DE B03A0150        	   618:     cmp.b   SELDRV,D0
00:000003E2 6712            	   619:     beq     .readRAMDrive
                            	   620: 
00:000003E4 6142            	   621:     bsr     setupReadDisk                               ; sets A0 to point to the right 128 bytes in memory, potentiall
00:000003E6 227A014E        	   622:     move.l  DMA,A1
00:000003EA 701F            	   623:     move.l  #(128/4-1),D0  
                            	   624: 
                            	   625: .MOVE_LOOP1:
00:000003EC 22D8            	   626:     MOVE.L  (A0)+,(A1)+                                 ; copy long word from source to dest
00:000003EE 51C8FFFC        	   627:     dbra    D0,.MOVE_LOOP1
                            	   628:     
00:000003F2 7000            	   629:     moveq.l #0,D0                                       ; return OK status         
00:000003F4 4E75            	   630:     rts
                            	   631: 
                            	   632: .readRAMDrive:
00:000003F6 6110            	   633:     bsr     setupReadRAM                                ; sets A0 to point to the right 128 bytes in memory to read
                            	   634:     debugPrintRAM 'R'
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         exg     A0,A3                                       ; save A0 as trap 15 trashes it
                            	     5M         moveq.l #6,D0                                   
                            	     6M         move.b  #'R',D1                                     
                            	     7M         trap    #15
                            	     8M         exg     A3,A0
                            	     9M 
                            	    10M         moveq.l #15,D0
                            	    11M         move.l  A0,D1                                       ; address in hex
                            	    12M         move.b  #16,D2
                            	    13M         trap    #15
                            	    14M 
                            	    15M         moveq.l #6,D0
                            	    16M         move.b  #'-',D1                                     
                            	    17M         trap    #15
                            	    18M 
                            	    19M         moveq.l #15,D0
                            	    20M         move.l  (DMA),D1                          ; sector in hex
                            	    21M         move.b  #16,D2
                            	    22M         trap    #15
                            	    23M 
                            	    24M         moveq.l #6,D0
                            	    25M         move.b  #' ',D1                                     
                            	    26M         trap    #15
                            	    27M 
                            	    28M         movem.l (A7)+,D0-D3/A0-A3
                            	    29M     ENDIF
00:000003F8 227A013C        	   635:     move.l  DMA,A1
00:000003FC 701F            	   636:     move.l  #(128/4-1),d0  
                            	   637: 
                            	   638: .MOVE_LOOP2:
00:000003FE 22D8            	   639:     MOVE.L  (A0)+,(A1)+                                 ; copy long word from source to dest
00:00000400 51C8FFFC        	   640:     dbra    D0,.MOVE_LOOP2
                            	   641: 
00:00000404 7000            	   642:     moveq.l #0,D0                                       ; return OK status         
00:00000406 4E75            	   643:     rts         
                            	   644: 
                            	   645: setupReadRAM:
                            	   646: ; translate track/sector into RAM location on the RAM drive
00:00000408 7000            	   647:     moveq.l #0,D0
00:0000040A 303A0126        	   648:     move.w  TRACK,D0
00:0000040E 760C            	   649:     moveq.l #12,D3                                      ; much faster than shifting by 8 then 4 (40 versus 12 cycles)
00:00000410 E7A8            	   650:     lsl.l   D3,D0
                            	   651: 
00:00000412 7400            	   652:     moveq.l #0,D2
00:00000414 343A011E        	   653:     move.w  SECTOR,D2
00:00000418 7607            	   654:     moveq.l #7,D3                                       ; much faster than shifting by 7 (22 versus 12 cycles)
00:0000041A E7AA            	   655:     lsl.l   D3,D2
                            	   656: 
00:0000041C D082            	   657:     add.l   D2,D0
00:0000041E D0BC000C0000    	   658:     add.l   #ramDriveLocation,D0                        ; add base address of RAM drive
00:00000424 2040            	   659:     movea.l D0,A0                                       ; point to the track/sector in RAM drive
00:00000426 4E75            	   660:     rts
                            	   661: 
                            	   662: setupReadDisk:
                            	   663: ;
                            	   664: ; algorithm
                            	   665: ;
                            	   666: ; keep 512b in a memory buffer
                            	   667: ; keep sector number of the data currently in the buffer
                            	   668: ;
                            	   669: ; if requested sector not in buffer {
                            	   670: ;     calcuate the sector and offset that the FAT entry for the sector is located in
                            	   671: ;     read sector pointed to in FAT table from disk into buffer
                            	   672: ;     note requested sector in buffer
                            	   673: ; }
                            	   674: ;
                            	   675: ; calculate offset of CPM 128b required in 512b buffer
                            	   676: ; copy the correct 12b across into the CPM dma area
                            	   677:     
                            	   678:     ; this routine returns the address of the 128 byte sector in the 512 FAT sector memory buffer in A0
00:00000428 48E7F870        	   679:     movem.l D0-D4/A1-A3,-(A7)
                            	   680:     
                            	   681:     ; start by calculating the requested (FAT32) sector number from TRACK and SECTOR in D0
                            	   682:     ; also calculate the offset into that 512b buffer for the 128b CPM sector data in D3
00:0000042C 7200            	   683:     moveq.l #0,D1
00:0000042E 323A0102        	   684:     move.w  TRACK,D1
00:00000432 E789            	   685:     lsl.l   #3,D1
                            	   686: 
00:00000434 7400            	   687:     moveq.l #0,D2
00:00000436 343A00FC        	   688:     move.w  SECTOR,D2
                            	   689: 
00:0000043A 2602            	   690:     move.l  D2,D3
00:0000043C C6BC00000003    	   691:     and.l   #3,D3                                       ; use D3 to calculate the offset of the 128b CPM sector in the 
00:00000442 7807            	   692:     moveq.l #7,D4                                       ; much faster than shifting by 7 (22 versus 12 cycles)
00:00000444 E9AB            	   693:     lsl.l   D4,D3
                            	   694: 
00:00000446 E48A            	   695:     lsr.l   #2,D2
00:00000448 D282            	   696:     add.l   D2,D1                                        ; D1 now has the requested sector number
00:0000044A D2BA16EA        	   697:     add.l   (CPMImageSector),D1                          ; D1 now has the actual sector on the SD card
                            	   698: 
                            	   699:     ; check to see if this FAT32 sector already in memory
00:0000044E B2BA16EA        	   700:     cmp.l (lastFATSector),D1
00:00000452 6716            	   701:     beq   .noDiskReadRequired
                            	   702: 
                            	   703:     ; we are going to read the sector (hopefully) so update the last read FAT sector before we lose the contents of D1
00:00000454 23C100001B3A    	   704:     move.l D1,lastFATSector
                            	   705: 
                            	   706:     ; we assume that the FAT table is contiguous for the CP/M image
                            	   707:     ; file, this avoids a walk of the FAT table linked list .. but wont deal with any bad sectors on the sd card
                            	   708: 
00:0000045A 43FA168C        	   709:     lea     sd,A1
00:0000045E 7002            	   710:     moveq.l #2,D0                                        ; read sector function code
00:00000460 45FA1486        	   711:     lea     sdBuf,A2
00:00000464 4E4D            	   712:     trap    #13
00:00000466 4A80            	   713:     cmp.l   #0,D0                                        ; check return
00:00000468 670C            	   714:     beq     .errDiskReadError
                            	   715: 
                            	   716:     debugPrintSector 'R'
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         moveq.l #6,D0                                   
                            	     5M         move.b  #'R',D1                                     
                            	     6M         trap    #15
                            	     7M     
                            	     8M         moveq.l #15,D0
                            	     9M         move.l  (lastFATSector),D1                          ; sector in hex
                            	    10M         move.b  #16,D2
                            	    11M         trap    #15
                            	    12M 
                            	    13M         moveq.l #6,D0
                            	    14M         move.b  #'-',D1                                    
                            	    15M         trap    #15
                            	    16M 
                            	    17M         moveq.l #15,D0
                            	    18M         move.l  D3,D1                                       ; offset on sector in hex
                            	    19M         move.b  #16,D2
                            	    20M         trap    #15
                            	    21M 
                            	    22M         moveq.l #6,D0
                            	    23M         move.b  #' ',D1                                     
                            	    24M         trap    #15
                            	    25M 
                            	    26M         movem.l (A7)+,D0-D3/A0-A3
                            	    27M     ENDIF
                            	   717:     ;jmp    .noCachePrint
                            	   718: 
                            	   719: .noDiskReadRequired:
                            	   720:     ;debugPrintSector 'C'
                            	   721:     
                            	   722: .noCachePrint:
00:0000046A 41FA147C        	   723:     lea    sdBuf,A0
00:0000046E D1C3            	   724:     add.l  D3,A0                                        ; add offset into 512b buffer
00:00000470 4CDF0E1F        	   725:     movem.l (A7)+,D0-D4/A1-A3
00:00000474 4E75            	   726:     rts
                            	   727: 
                            	   728: .errDiskReadError:
                            	   729:     ; if we get here we had a disk read error
00:00000476 4CDF0E1F        	   730:     movem.l (A7)+,D0-D4/A1-A3
                            	   731: 
                            	   732:     debugPrintSector 'E'    
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         moveq.l #6,D0                                   
                            	     5M         move.b  #'E',D1                                     
                            	     6M         trap    #15
                            	     7M     
                            	     8M         moveq.l #15,D0
                            	     9M         move.l  (lastFATSector),D1                          ; sector in hex
                            	    10M         move.b  #16,D2
                            	    11M         trap    #15
                            	    12M 
                            	    13M         moveq.l #6,D0
                            	    14M         move.b  #'-',D1                                    
                            	    15M         trap    #15
                            	    16M 
                            	    17M         moveq.l #15,D0
                            	    18M         move.l  D3,D1                                       ; offset on sector in hex
                            	    19M         move.b  #16,D2
                            	    20M         trap    #15
                            	    21M 
                            	    22M         moveq.l #6,D0
                            	    23M         move.b  #' ',D1                                     
                            	    24M         trap    #15
                            	    25M 
                            	    26M         movem.l (A7)+,D0-D3/A0-A3
                            	    27M     ENDIF
                            	   733:     PrintStr msgNoSdCardRead
00:0000047A 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:0000047E 41FA1733        	     2M     lea     msgNoSdCardRead,A0
00:00000482 7201            	     3M     moveq.l #1,D1                                       
00:00000484 4E4E            	     4M     trap    #14  
00:00000486 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
                            	   734: 
00:0000048A 7001            	   735:     moveq.l #1,D0                                       ; signal error
                            	   736: 
00:0000048C 23FCFFFFFFFF0000	   737:     move.l  #-1,lastFATSector
00:00000494 1B3A
00:00000496 243C000000FF    	   738:     move.l  #$ff,D2
00:0000049C 45BC0001        	   739:     chk     #1,D2                                       ; cause a trap to stop execution
00:000004A0 4E75            	   740:     rts                                                 ; should not get here .. 
                            	   741: 
                            	   742: WRITE:
                            	   743: ; Write one cpm sector from requested disk, track, sector to dma address
                            	   744: ; Can be a cpmimage on the sd card or the ram disk
                            	   745: ; We always write sectors immediately so no need to implement "write to directory sector"
00:000004A2 103A00E6        	   746:     move.b  (RAMDRIVE),D0
00:000004A6 B03A0088        	   747:     cmp.b   SELDRV,D0
00:000004AA 673C            	   748:     beq     .writeRAMDrive
                            	   749: 
                            	   750:     ; going to write to disk    
00:000004AC 6100FF7A        	   751:     bsr     setupReadDisk                               ; sets A0 to point to the right 128 bytes in memory, potentiall
                            	   752:     debugPrintSector 'W'
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         moveq.l #6,D0                                   
                            	     5M         move.b  #'W',D1                                     
                            	     6M         trap    #15
                            	     7M     
                            	     8M         moveq.l #15,D0
                            	     9M         move.l  (lastFATSector),D1                          ; sector in hex
                            	    10M         move.b  #16,D2
                            	    11M         trap    #15
                            	    12M 
                            	    13M         moveq.l #6,D0
                            	    14M         move.b  #'-',D1                                    
                            	    15M         trap    #15
                            	    16M 
                            	    17M         moveq.l #15,D0
                            	    18M         move.l  D3,D1                                       ; offset on sector in hex
                            	    19M         move.b  #16,D2
                            	    20M         trap    #15
                            	    21M 
                            	    22M         moveq.l #6,D0
                            	    23M         move.b  #' ',D1                                     
                            	    24M         trap    #15
                            	    25M 
                            	    26M         movem.l (A7)+,D0-D3/A0-A3
                            	    27M     ENDIF
00:000004B0 227A0084        	   753:     move.l  DMA,A1
00:000004B4 701F            	   754:     move.l  #(128/4-1),d0  
                            	   755:     
                            	   756: .MOVE_LOOP3:
00:000004B6 20D9            	   757:     MOVE.L  (A1)+,(A0)+                                 ; copy long word from source to dest, reverse direction from re
00:000004B8 51C8FFFC        	   758:     dbra    D0,.MOVE_LOOP3
                            	   759: 
                            	   760:     ; and write out the 512b buffer to disk
                            	   761:     ; tyhisi sthe last function for the CPM BIOS call, so we dont need to preserve the registers when we call the trap
00:000004BC 223A167C        	   762:     move.l  (lastFATSector),D1                          ; set up in SETUPRD
00:000004C0 43FA1626        	   763:     lea     sd,A1
00:000004C4 7003            	   764:     moveq.l #3,D0                                       ; write sector function call
00:000004C6 45FA1420        	   765:     lea     sdBuf,A2                                    ; write out sdBuf to disk
00:000004CA 4E4D            	   766:     trap    #13
00:000004CC 4A80            	   767:     cmp.l   #0,D0                                       ; check return
00:000004CE 6704            	   768:     beq     .errWriteError
                            	   769: 
00:000004D0 7000            	   770:     moveq.l #0,D0                                       ; return success
00:000004D2 4E75            	   771:     rts                    
                            	   772: 
                            	   773: .errWriteError:
                            	   774:     PrintStr msgNoSdCardWrite
00:000004D4 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:000004D8 41FA16F7        	     2M     lea     msgNoSdCardWrite,A0
00:000004DC 7201            	     3M     moveq.l #1,D1                                       
00:000004DE 4E4E            	     4M     trap    #14  
00:000004E0 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
00:000004E4 7001            	   775:     moveq.l #1,D0                                       ; signal error
00:000004E6 4E75            	   776:     rts
                            	   777:     
                            	   778: .writeRAMDrive:
00:000004E8 6100FF1E        	   779:     bsr     setupReadRAM                                ; sets A0 to point to the right 128 bytes in memory to read
                            	   780:     debugPrintRAM 'W'
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         exg     A0,A3                                       ; save A0 as trap 15 trashes it
                            	     5M         moveq.l #6,D0                                   
                            	     6M         move.b  #'W',D1                                     
                            	     7M         trap    #15
                            	     8M         exg     A3,A0
                            	     9M 
                            	    10M         moveq.l #15,D0
                            	    11M         move.l  A0,D1                                       ; address in hex
                            	    12M         move.b  #16,D2
                            	    13M         trap    #15
                            	    14M 
                            	    15M         moveq.l #6,D0
                            	    16M         move.b  #'-',D1                                     
                            	    17M         trap    #15
                            	    18M 
                            	    19M         moveq.l #15,D0
                            	    20M         move.l  (DMA),D1                          ; sector in hex
                            	    21M         move.b  #16,D2
                            	    22M         trap    #15
                            	    23M 
                            	    24M         moveq.l #6,D0
                            	    25M         move.b  #' ',D1                                     
                            	    26M         trap    #15
                            	    27M 
                            	    28M         movem.l (A7)+,D0-D3/A0-A3
                            	    29M     ENDIF
00:000004EC 227A0048        	   781:     move.l  DMA,A1
00:000004F0 701F            	   782:     move.l  #(128/4-1),d0  
                            	   783: 
                            	   784: .MOVE_LOOP4:
00:000004F2 20D9            	   785:     MOVE.L  (A1)+,(A0)+                                 ; copy long word from source to dest, reverse direction from re
00:000004F4 51C8FFFC        	   786:     dbra    D0,.MOVE_LOOP4
                            	   787: 
00:000004F8 7000            	   788:     moveq.l #0,D0
00:000004FA 4E75            	   789:     rts        
                            	   790: 
                            	   791: FLUSH:
                            	   792:     ; we always write each CPM sector immediatley, so no need to implement flush
00:000004FC 7000            	   793:     moveq.l #0,D0                                       ; return successful
00:000004FE 4E75            	   794:     rts
                            	   795: 
                            	   796: GETSEG:
00:00000500 203C0000053C    	   797:     move.l #MEMRGN,D0                                   ; return address of mem region table
00:00000506 4E75            	   798:     rts
                            	   799: 
                            	   800: SETEXC:
00:00000508 0281000000FF    	   801:     andi.l  #$ff,D1                                     ; do only for exceptions 0 - 255
                            	   802: 
00:0000050E 0C41002D        	   803:     cmpi    #45,D1
00:00000512 671A            	   804:     beq     NOSET                                       ; don't set trap 13,14,15 as used by rosco firmware
00:00000514 0C41002E        	   805:     cmpi    #46,D1
00:00000518 6714            	   806:     beq     NOSET                        
00:0000051A 0C41002F        	   807:     cmpi    #47,D1
00:0000051E 670E            	   808:     beq     NOSET                       
00:00000520 0C410009        	   809:     cmpi    #9,D1                                       ; don't set trace trap
00:00000524 6708            	   810:     beq     NOSET
00:00000526 E549            	   811:     lsl     #2,D1                                       ; multiply exception number by 4
00:00000528 2041            	   812:     movea.l D1,A0
00:0000052A 2010            	   813:     move.l  (A0),D0                                     ; return old vector value
00:0000052C 2082            	   814:     move.l  D2,(A0)                                     ; insert new vector
                            	   815: 
                            	   816: NOSET:    
00:0000052E 4E75            	   817:     rts
                            	   818: 
                            	   819: * ************************************************************************** *
                            	   820: ; Data
                            	   821: * ************************************************************************** *
                            	   822: 
                            	   823:               align 2                    ; DMA must be at even address
00:00000530 FF              	   824: SELDRV        dc.b        $ff            ; drive requested by seldsk
00:00000531 00              	   825: RESV          dc.b        0              ; reserve byte, padding
00:00000532 0000            	   826: TRACK         dc.w        0              ; track requested by settrk
00:00000534 0000            	   827: SECTOR        dc.w        0              ; max sector value is 0x3FF
00:00000536 00000000        	   828: DMA           dc.l        0
00:0000053A 00              	   829: SELCODE       dc.b        0              ; reserve byte
00:0000053B 00              	   830: RESV1         dc.b        0              ; reserve byte, padding
                            	   831: 
                            	   832: ; memory table must start on an even address
                            	   833:               align 2
00:0000053C 0001            	   834: MEMRGN        dc.w        1              ; 1 memory region
00:0000053E 00020000        	   835:               dc.l        $20000         ; after the CP/M 
00:00000542 000A0000        	   836: 			  dc.l        $A0000         ; 524K bytes, more than enough for bootstrapping  
                            	   837: 
                            	   838: ; Drive mapping; 0xFFFFFFFF means mapped to Ram disk, 0 not present otherwise records
                            	   839: ; the sector of the logical file on the FAT32 SD Card
                            	   840: ; Max of 16 disks 
                            	   841: CPMDISK:
00:00000546 00000000        	   842:     ds.l      17,0                       ; 16 drives plus one slot for "CPMDISK.IMG" which gets mapped to one of the ot
00:0000054A *
                            	   843: RAMDRIVE:
00:0000058A 00              	   844:     dc.b      0                          ; mappimg for RAM disk
00:0000058B 00              	   845:     dc.b      0                          ; padding
                            	   846: 
                            	   847: ; disk parameter header - 4mb disk on sd card
                            	   848: ; set this up for 16 disks .. DPB and DIRBUF can be reused, ALV cannot ..
                            	   849: DPH0:  
00:0000058C 00000000        	   850:     dc.l      0                          ; no sector translation table
00:00000590 0000            	   851:     dc.w      0                          ; dummy
00:00000592 0000            	   852:     dc.w      0
00:00000594 0000            	   853:     dc.w      0
00:00000596 00000768        	   854:     dc.l      DIRBUF                     ; ptr to directory buffer
00:0000059A 0000072C        	   855:     dc.l      DPB0                       ; ptr to disk parameter block
00:0000059E 00000000        	   856:     dc.l      0                          ; permanent drive, no check vector
00:000005A2 000007E8        	   857:     dc.l      ALV0                       ; ptr to allocation vector
                            	   858: 
00:000005A6 00000000        	   859:     dc.l      0                          ; no sector translation table
00:000005AA 0000            	   860:     dc.w      0                          ; dummy
00:000005AC 0000            	   861:     dc.w      0
00:000005AE 0000            	   862:     dc.w      0
00:000005B0 00000768        	   863:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000005B4 0000072C        	   864:     dc.l      DPB0                       ; ptr to disk parameter block
00:000005B8 00000000        	   865:     dc.l      0                          ; permanent drive, no check vector
00:000005BC 000008E8        	   866:     dc.l      ALV1                       ; ptr to allocation vector
                            	   867: 
00:000005C0 00000000        	   868:     dc.l      0                          ; no sector translation table
00:000005C4 0000            	   869:     dc.w      0                          ; dummy
00:000005C6 0000            	   870:     dc.w      0
00:000005C8 0000            	   871:     dc.w      0
00:000005CA 00000768        	   872:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000005CE 0000072C        	   873:     dc.l      DPB0                       ; ptr to disk parameter block
00:000005D2 00000000        	   874:     dc.l      0                          ; permanent drive, no check vector
00:000005D6 000009E8        	   875:     dc.l      ALV2                       ; ptr to allocation vector
                            	   876: 
00:000005DA 00000000        	   877:     dc.l      0                          ; no sector translation table
00:000005DE 0000            	   878:     dc.w      0                          ; dummy
00:000005E0 0000            	   879:     dc.w      0
00:000005E2 0000            	   880:     dc.w      0
00:000005E4 00000768        	   881:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000005E8 0000072C        	   882:     dc.l      DPB0                       ; ptr to disk parameter block
00:000005EC 00000000        	   883:     dc.l      0                          ; permanent drive, no check vector
00:000005F0 00000AE8        	   884:     dc.l      ALV3                       ; ptr to allocation vector
                            	   885: 
00:000005F4 00000000        	   886:     dc.l      0                          ; no sector translation table
00:000005F8 0000            	   887:     dc.w      0                          ; dummy
00:000005FA 0000            	   888:     dc.w      0
00:000005FC 0000            	   889:     dc.w      0
00:000005FE 00000768        	   890:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000602 0000072C        	   891:     dc.l      DPB0                       ; ptr to disk parameter block
00:00000606 00000000        	   892:     dc.l      0                          ; permanent drive, no check vector
00:0000060A 00000BE8        	   893:     dc.l      ALV4                       ; ptr to allocation vector
                            	   894: 
00:0000060E 00000000        	   895:     dc.l      0                          ; no sector translation table
00:00000612 0000            	   896:     dc.w      0                          ; dummy
00:00000614 0000            	   897:     dc.w      0
00:00000616 0000            	   898:     dc.w      0
00:00000618 00000768        	   899:     dc.l      DIRBUF                     ; ptr to directory buffer
00:0000061C 0000072C        	   900:     dc.l      DPB0                       ; ptr to disk parameter block
00:00000620 00000000        	   901:     dc.l      0                          ; permanent drive, no check vector
00:00000624 00000CE8        	   902:     dc.l      ALV5                       ; ptr to allocation vector
                            	   903: 
00:00000628 00000000        	   904:     dc.l      0                          ; no sector translation table
00:0000062C 0000            	   905:     dc.w      0                          ; dummy
00:0000062E 0000            	   906:     dc.w      0
00:00000630 0000            	   907:     dc.w      0
00:00000632 00000768        	   908:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000636 0000072C        	   909:     dc.l      DPB0                       ; ptr to disk parameter block
00:0000063A 00000000        	   910:     dc.l      0                          ; permanent drive, no check vector
00:0000063E 00000DE8        	   911:     dc.l      ALV6                       ; ptr to allocation vector
                            	   912: 
00:00000642 00000000        	   913:     dc.l      0                          ; no sector translation table
00:00000646 0000            	   914:     dc.w      0                          ; dummy
00:00000648 0000            	   915:     dc.w      0
00:0000064A 0000            	   916:     dc.w      0
00:0000064C 00000768        	   917:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000650 0000072C        	   918:     dc.l      DPB0                       ; ptr to disk parameter block
00:00000654 00000000        	   919:     dc.l      0                          ; permanent drive, no check vector
00:00000658 00000EE8        	   920:     dc.l      ALV7                       ; ptr to allocation vector
                            	   921: 
00:0000065C 00000000        	   922:     dc.l      0                          ; no sector translation table
00:00000660 0000            	   923:     dc.w      0                          ; dummy
00:00000662 0000            	   924:     dc.w      0
00:00000664 0000            	   925:     dc.w      0
00:00000666 00000768        	   926:     dc.l      DIRBUF                     ; ptr to directory buffer
00:0000066A 0000072C        	   927:     dc.l      DPB0                       ; ptr to disk parameter block
00:0000066E 00000000        	   928:     dc.l      0                          ; permanent drive, no check vector
00:00000672 00000FE8        	   929:     dc.l      ALV8                       ; ptr to allocation vector
                            	   930: 
00:00000676 00000000        	   931:     dc.l      0                          ; no sector translation table
00:0000067A 0000            	   932:     dc.w      0                          ; dummy
00:0000067C 0000            	   933:     dc.w      0
00:0000067E 0000            	   934:     dc.w      0
00:00000680 00000768        	   935:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000684 0000072C        	   936:     dc.l      DPB0                       ; ptr to disk parameter block
00:00000688 00000000        	   937:     dc.l      0                          ; permanent drive, no check vector
00:0000068C 000010E8        	   938:     dc.l      ALV9                       ; ptr to allocation vector
                            	   939: 
00:00000690 00000000        	   940:     dc.l      0                          ; no sector translation table
00:00000694 0000            	   941:     dc.w      0                          ; dummy
00:00000696 0000            	   942:     dc.w      0
00:00000698 0000            	   943:     dc.w      0
00:0000069A 00000768        	   944:     dc.l      DIRBUF                     ; ptr to directory buffer
00:0000069E 0000072C        	   945:     dc.l      DPB0                       ; ptr to disk parameter block
00:000006A2 00000000        	   946:     dc.l      0                          ; permanent drive, no check vector
00:000006A6 000011E8        	   947:     dc.l      ALV10                      ; ptr to allocation vector
                            	   948: 
00:000006AA 00000000        	   949:     dc.l      0                          ; no sector translation table
00:000006AE 0000            	   950:     dc.w      0                          ; dummy
00:000006B0 0000            	   951:     dc.w      0
00:000006B2 0000            	   952:     dc.w      0
00:000006B4 00000768        	   953:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000006B8 0000072C        	   954:     dc.l      DPB0                       ; ptr to disk parameter block
00:000006BC 00000000        	   955:     dc.l      0                          ; permanent drive, no check vector
00:000006C0 000012E8        	   956:     dc.l      ALV11                      ; ptr to allocation vector
                            	   957: 
00:000006C4 00000000        	   958:     dc.l      0                          ; no sector translation table
00:000006C8 0000            	   959:     dc.w      0                          ; dummy
00:000006CA 0000            	   960:     dc.w      0
00:000006CC 0000            	   961:     dc.w      0
00:000006CE 00000768        	   962:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000006D2 0000072C        	   963:     dc.l      DPB0                       ; ptr to disk parameter block
00:000006D6 00000000        	   964:     dc.l      0                          ; permanent drive, no check vector
00:000006DA 000013E8        	   965:     dc.l      ALV12                      ; ptr to allocation vector
                            	   966: 
00:000006DE 00000000        	   967:     dc.l      0                          ; no sector translation table
00:000006E2 0000            	   968:     dc.w      0                          ; dummy
00:000006E4 0000            	   969:     dc.w      0
00:000006E6 0000            	   970:     dc.w      0
00:000006E8 00000768        	   971:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000006EC 0000072C        	   972:     dc.l      DPB0                       ; ptr to disk parameter block
00:000006F0 00000000        	   973:     dc.l      0                          ; permanent drive, no check vector
00:000006F4 000014E8        	   974:     dc.l      ALV13                      ; ptr to allocation vector
                            	   975: 
00:000006F8 00000000        	   976:     dc.l      0                          ; no sector translation table
00:000006FC 0000            	   977:     dc.w      0                          ; dummy
00:000006FE 0000            	   978:     dc.w      0
00:00000700 0000            	   979:     dc.w      0
00:00000702 00000768        	   980:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000706 0000072C        	   981:     dc.l      DPB0                       ; ptr to disk parameter block
00:0000070A 00000000        	   982:     dc.l      0                          ; permanent drive, no check vector
00:0000070E 000015E8        	   983:     dc.l      ALV14                      ; ptr to allocation vector
                            	   984: 
00:00000712 00000000        	   985:     dc.l      0                          ; no sector translation table
00:00000716 0000            	   986:     dc.w      0                          ; dummy
00:00000718 0000            	   987:     dc.w      0
00:0000071A 0000            	   988:     dc.w      0
00:0000071C 00000768        	   989:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000720 0000072C        	   990:     dc.l      DPB0                       ; ptr to disk parameter block
00:00000724 00000000        	   991:     dc.l      0                          ; permanent drive, no check vector
00:00000728 000016E8        	   992:     dc.l      ALV15                      ; ptr to allocation vector
                            	   993: 
                            	   994: 
                            	   995: DPB0:    
00:0000072C 0020            	   996:     dc.w     32                          ; 32 sectors per track
00:0000072E 04              	   997:     dc.b     4                           ; block shift for BLS of 2048
00:0000072F 0F              	   998:     dc.b     15                          ; block mask for BLS of 2048
00:00000730 00              	   999:     dc.b     0                           ; extent mask, EXM
00:00000731 00              	  1000:     dc.b     0                           ; dummy fill
00:00000732 07FF            	  1001:     dc.w     2047                        ; DSM, (1024 tracks * 32 sectors * 128 bytes /2048)-1
                            	  1002:                            
00:00000734 00FF            	  1003:     dc.w     255                         ; DRM, 256 directory entries
00:00000736 0000            	  1004:     dc.w     0                           ; directory mask
00:00000738 0000            	  1005:     dc.w     0                           ; permanent mounted drive, check size is zero
00:0000073A 0000            	  1006:     dc.w     0                           ; no track offset
                            	  1007: 
                            	  1008: 
                            	  1009: ; disk parameter header - 128k ram disk 
                            	  1010: DPH1:    
00:0000073C 00000000        	  1011:     dc.l      0                          ; no sector translation table
00:00000740 0000            	  1012:     dc.w      0                          ; dummy
00:00000742 0000            	  1013:     dc.w      0
00:00000744 0000            	  1014:     dc.w      0
00:00000746 00000768        	  1015:     dc.l      DIRBUF                     ; ptr to directory buffer
00:0000074A 00000756        	  1016:     dc.l      DPB1                       ; ptr to disk parameter block
00:0000074E 00000000        	  1017:     dc.l      0                          ; permanent drive, no check vector
00:00000752 000017E8        	  1018:     dc.l      ALV16                      ; ptr to allocation vector
                            	  1019: 
                            	  1020: DPB1:    
00:00000756 0020            	  1021:     dc.w     32                          ; 32 sectors per track
00:00000758 04              	  1022:     dc.b     4                           ; block shift for BLS of 2048
00:00000759 0F              	  1023:     dc.b     15                          ; block mask for BLS of 2048
00:0000075A 00              	  1024:     dc.b     0                           ; extent mask, EXM
00:0000075B 00              	  1025:     dc.b     0                           ; dummy fill
00:0000075C 003F            	  1026:     dc.w     63                          ; DSM, (32 tracks * 32 sectors * 128 bytes /2048)-1
                            	  1027:                            
00:0000075E 00FF            	  1028:     dc.w     255                         ; DRM, 256 directory entries
00:00000760 0000            	  1029:     dc.w     0                           ; directory mask
00:00000762 0000            	  1030:     dc.w     0                           ; permanent mounted drive, check size is zero
00:00000764 0000            	  1031:     dc.w     0                           ; no track offset
                            	  1032: 
                            	  1033: 
                            	  1034:     align 2
                            	  1035: DIRBUF:    
00:00000768 00              	  1036:     ds.b     128                         ; directory buffer
00:00000769 *
                            	  1037: 
                            	  1038: ALV0:    
00:000007E8 00              	  1039: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000007E9 *
                            	  1040: 
                            	  1041: ALV1:    
00:000008E8 00              	  1042: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000008E9 *
                            	  1043: 
                            	  1044: ALV2:    
00:000009E8 00              	  1045: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000009E9 *
                            	  1046: 
                            	  1047: ALV3:    
00:00000AE8 00              	  1048: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000AE9 *
                            	  1049: 
                            	  1050: ALV4:    
00:00000BE8 00              	  1051: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000BE9 *
                            	  1052: 
                            	  1053: ALV5:    
00:00000CE8 00              	  1054: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000CE9 *
                            	  1055: 
                            	  1056: ALV6:    
00:00000DE8 00              	  1057: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000DE9 *
                            	  1058: 
                            	  1059: ALV7:    
00:00000EE8 00              	  1060: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000EE9 *
                            	  1061: 
                            	  1062: ALV8:    
00:00000FE8 00              	  1063: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000FE9 *
                            	  1064: 
                            	  1065: ALV9:    
00:000010E8 00              	  1066: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000010E9 *
                            	  1067: 
                            	  1068: ALV10:    
00:000011E8 00              	  1069: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000011E9 *
                            	  1070: 
                            	  1071: ALV11:    
00:000012E8 00              	  1072: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000012E9 *
                            	  1073: 
                            	  1074: ALV12:    
00:000013E8 00              	  1075: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000013E9 *
                            	  1076: 
                            	  1077: ALV13:    
00:000014E8 00              	  1078: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000014E9 *
                            	  1079: 
                            	  1080: ALV14:    
00:000015E8 00              	  1081: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000015E9 *
                            	  1082: 
                            	  1083: ALV15:    
00:000016E8 00              	  1084: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000016E9 *
                            	  1085: 
                            	  1086: ALV16:    
00:000017E8 00              	  1087: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000017E9 *
                            	  1088: 
                            	  1089: sdBuf:    
00:000018E8 00              	  1090: 	ds.b     512                         ; buffer to read/write sectors to sd card
00:000018E9 *
                            	  1091: 
                            	  1092: sd:
00:00001AE8 00              	  1093:     ds.b     64                          ; needs to be large enough to hold a sd card structure
00:00001AE9 *
                            	  1094: 
                            	  1095: partStartSector:                         ; starting sector for partition 0 on the disk
00:00001B28 00000000        	  1096:     dc.l     0
                            	  1097: 
                            	  1098: rootDirectoryCluster:                    ; cluster of root directory - usually 2
00:00001B2C 00000000        	  1099:     dc.l     0
                            	  1100: 
                            	  1101: rootDirectorySector:                     ; sector where root directory starts on sd card
00:00001B30 0000            	  1102:     dc.w     0
                            	  1103: 
                            	  1104: reservedSectors:                         ; sector where FAT table starts on sd card
00:00001B32 0000            	  1105:     dc.w     0
                            	  1106: 
                            	  1107: sectorsPerCluster:                       ; sectors per cluster in word format
00:00001B34 0000            	  1108:     dc.w     0
                            	  1109: 
                            	  1110: CPMImageSector:                          ; sector number of CPM image for the current disk
00:00001B36 00000000        	  1111:     dc.l     0
                            	  1112: 
                            	  1113: lastFATSector:                           ; last FAT sector read (contents should be in sdBuf)
00:00001B3A FFFFFFFF        	  1114:     dc.l     -1
                            	  1115: 
                            	  1116: imageName:
00:00001B3E 43504D4449534B20	  1117:     dc.b     "CPMDISK IMG",0             ; Nameof CPM image file on SD card
00:00001B46 494D47
00:00001B49 00
                            	  1118: 
                            	  1119: msgNoSdCardSupport:
00:00001B4A 6572726F723A204E	  1120:     dc.b     "error: No SD card support detected",0
00:00001B52 6F20534420636172
00:00001B5A 6420737570706F72
00:00001B62 7420646574656374
00:00001B6A 6564
00:00001B6C 00
                            	  1121: 
                            	  1122: msgNoSdCardInit:
00:00001B6D 6572726F723A2055	  1123:     dc.b     "error: Unable to initialize SD card",0
00:00001B75 6E61626C6520746F
00:00001B7D 20696E697469616C
00:00001B85 697A652053442063
00:00001B8D 617264
00:00001B90 00
                            	  1124: 
                            	  1125: msgNoSdCardReadMBR:
00:00001B91 6572726F723A2055	  1126:     dc.b     "error: Unable to read SD card MBR",0
00:00001B99 6E61626C6520746F
00:00001BA1 2072656164205344
00:00001BA9 2063617264204D42
00:00001BB1 52
00:00001BB2 00
                            	  1127: 
                            	  1128: msgNoSdCardRead:
00:00001BB3 6572726F723A2055	  1129:     dc.b     "error: Unable to read SD card",0
00:00001BBB 6E61626C6520746F
00:00001BC3 2072656164205344
00:00001BCB 2063617264
00:00001BD0 00
                            	  1130: 
                            	  1131: msgNoSdCardWrite:
00:00001BD1 6572726F723A2055	  1132:     dc.b     "error: Unable to write SD card",0
00:00001BD9 6E61626C6520746F
00:00001BE1 2077726974652053
00:00001BE9 442063617264
00:00001BEF 00
                            	  1133: 
                            	  1134: msgNoCPMImage:
00:00001BF0 6572726F723A2043	  1135:     dc.b     "error: Cannot find CPMDISK.IMG in root directory of partition 0 on SD card",0
00:00001BF8 616E6E6F74206669
00:00001C00 6E642043504D4449
00:00001C08 534B2E494D472069
00:00001C10 6E20726F6F742064
00:00001C18 69726563746F7279
00:00001C20 206F662070617274
00:00001C28 6974696F6E203020
00:00001C30 6F6E205344206361
00:00001C38 7264
00:00001C3A 00
                            	  1136: msgMapCPMDrive:
00:00001C3B 4D61707065642043	  1137:     dc.b     "Mapped CPMDISK.IMG to "
00:00001C43 504D4449534B2E49
00:00001C4B 4D4720746F20
                            	  1138: msgMapCPMDriveLetter:
00:00001C51 513A            	  1139:     dc.b     "Q:",0
00:00001C53 00
                            	  1140: msgMapRAMDrive:
00:00001C54 4D61707065642052	  1141:     dc.b     "Mapped RAM drive to "
00:00001C5C 414D206472697665
00:00001C64 20746F20
                            	  1142: msgMapRAMDriveLetter:
00:00001C68 513A            	  1143:     dc.b     "Q:",0
00:00001C6A 00
                            	  1144: msgMapDrive:
00:00001C6B 4D61707065642043	  1145:     dc.b     "Mapped CPMDISK"
00:00001C73 504D4449534B
                            	  1146: msgMapDriveSource:
00:00001C79 512E494D4720746F	  1147:     dc.b     "Q.IMG to "
00:00001C81 20
                            	  1148: msgMapDriveLetter:
00:00001C82 513A            	  1149:     dc.b     "Q:",0
00:00001C84 00
                            	  1150: msgIgnoreMapDrive:
00:00001C85 49676E6F72696E67	  1151:     dc.b     "Ignoring CPMDISK file with drive letter after P",0
00:00001C8D 2043504D4449534B
00:00001C95 2066696C65207769
00:00001C9D 7468206472697665
00:00001CA5 206C657474657220
00:00001CAD 61667465722050
00:00001CB4 00


Symbols by name:
ALV0                            00:000007E8
ALV1                            00:000008E8
ALV10                           00:000011E8
ALV11                           00:000012E8
ALV12                           00:000013E8
ALV13                           00:000014E8
ALV14                           00:000015E8
ALV15                           00:000016E8
ALV16                           00:000017E8
ALV2                            00:000009E8
ALV3                            00:00000AE8
ALV4                            00:00000BE8
ALV5                            00:00000CE8
ALV6                            00:00000DE8
ALV7                            00:00000EE8
ALV8                            00:00000FE8
ALV9                            00:000010E8
BIOSBASE                        00:000002B6
CONIN                           00:00000332
CONOUT                          00:00000348
CONSTAT                         00:00000318
CPMDISK                         00:00000546
CPMImageSector                  00:00001B36
DEBUG                            S:00000000
DIRBUF                          00:00000768
DMA                             00:00000536
DPB0                            00:0000072C
DPB1                            00:00000756
DPH0                            00:0000058C
DPH1                            00:0000073C
FLUSH                           00:000004FC
GETIOB                          00:00000362
GETSEG                          00:00000500
HOME                            00:0000036C
LISTST                          00:00000366
LSTOUT                          00:00000356
MEMRGN                          00:0000053C
MISSING                         00:000003D8
NOSET                           00:0000052E
PUN                             00:00000358
RAMDRIVE                        00:0000058A
RDR                             00:0000035C
READ                            00:000003DA
RESV                            00:00000531
RESV1                           00:0000053B
SECTOR                          00:00000534
SECTRAN                         00:000003CC
SELCODE                         00:0000053A
SELDRV                          00:00000530
SELDSK                          00:00000374
SETDMA                          00:000003D0
SETEXC                          00:00000508
SETIOB                          00:00000362
SETSEC                          00:000003C4
SETTRK                          00:000003BC
TRACK                           00:00000532
TRAPHNDL                        00:000002A6
TRAPNG                          00:000002B4
WBOOT                           00:00000312
WRITE                           00:000004A2
_ccp                             E:000150BC
_init                           00:00000000 EXP
imageName                       00:00001B3E
lastFATSector                   00:00001B3A
msgIgnoreMapDrive               00:00001C85
msgMapCPMDrive                  00:00001C3B
msgMapCPMDriveLetter            00:00001C51
msgMapDrive                     00:00001C6B
msgMapDriveLetter               00:00001C82
msgMapDriveSource               00:00001C79
msgMapRAMDrive                  00:00001C54
msgMapRAMDriveLetter            00:00001C68
msgNoCPMImage                   00:00001BF0
msgNoSdCardInit                 00:00001B6D
msgNoSdCardRead                 00:00001BB3
msgNoSdCardReadMBR              00:00001B91
msgNoSdCardSupport              00:00001B4A
msgNoSdCardWrite                00:00001BD1
partStartSector                 00:00001B28
ramDriveLocation                 E:000C0000
reservedSectors                 00:00001B32
rootDirectoryCluster            00:00001B2C
rootDirectorySector             00:00001B30
sd                              00:00001AE8
sdBuf                           00:000018E8
sectorsPerCluster               00:00001B34
setupReadDisk                   00:00000428
setupReadRAM                    00:00000408

Symbols by value:
00000000 DEBUG
00000000 _init
000002A6 TRAPHNDL
000002B4 TRAPNG
000002B6 BIOSBASE
00000312 WBOOT
00000318 CONSTAT
00000332 CONIN
00000348 CONOUT
00000356 LSTOUT
00000358 PUN
0000035C RDR
00000362 GETIOB
00000362 SETIOB
00000366 LISTST
0000036C HOME
00000374 SELDSK
000003BC SETTRK
000003C4 SETSEC
000003CC SECTRAN
000003D0 SETDMA
000003D8 MISSING
000003DA READ
00000408 setupReadRAM
00000428 setupReadDisk
000004A2 WRITE
000004FC FLUSH
00000500 GETSEG
00000508 SETEXC
0000052E NOSET
00000530 SELDRV
00000531 RESV
00000532 TRACK
00000534 SECTOR
00000536 DMA
0000053A SELCODE
0000053B RESV1
0000053C MEMRGN
00000546 CPMDISK
0000058A RAMDRIVE
0000058C DPH0
0000072C DPB0
0000073C DPH1
00000756 DPB1
00000768 DIRBUF
000007E8 ALV0
000008E8 ALV1
000009E8 ALV2
00000AE8 ALV3
00000BE8 ALV4
00000CE8 ALV5
00000DE8 ALV6
00000EE8 ALV7
00000FE8 ALV8
000010E8 ALV9
000011E8 ALV10
000012E8 ALV11
000013E8 ALV12
000014E8 ALV13
000015E8 ALV14
000016E8 ALV15
000017E8 ALV16
000018E8 sdBuf
00001AE8 sd
00001B28 partStartSector
00001B2C rootDirectoryCluster
00001B30 rootDirectorySector
00001B32 reservedSectors
00001B34 sectorsPerCluster
00001B36 CPMImageSector
00001B3A lastFATSector
00001B3E imageName
00001B4A msgNoSdCardSupport
00001B6D msgNoSdCardInit
00001B91 msgNoSdCardReadMBR
00001BB3 msgNoSdCardRead
00001BD1 msgNoSdCardWrite
00001BF0 msgNoCPMImage
00001C3B msgMapCPMDrive
00001C51 msgMapCPMDriveLetter
00001C54 msgMapRAMDrive
00001C68 msgMapRAMDriveLetter
00001C6B msgMapDrive
00001C79 msgMapDriveSource
00001C82 msgMapDriveLetter
00001C85 msgIgnoreMapDrive
000150BC _ccp
000C0000 ramDriveLocation
