Sections:
00: "CODE" (0-1C31)


Source: "bios.asm"
                            	     1: ; Very simple cpm68k bios
                            	     2: ; Malcolm Harrow August 2023
                            	     3: 
                            	     4: _ccp               equ $150BC                           ; hard location for _ccp of CPM15000.SR
                            	     5: ramDriveLocation   equ $C0000                           ; memory location for RAM drive
                            	     6: DEBUG              set 0                                ; set to 1 to print debug messgae, 0 turns off  
                            	     7: DEBUG1             set 1                                ; set to 1 to print debug messgae, 0 turns off  
                            	     8: 
                            	     9: 
                            	    10: ; pass in a character to this routine and print it out
                            	    11: ; use to track progress through the code in debug ..
                            	    12: debugPrintChar MACRO
                            	    13:     IFNE DEBUG1
                            	    14:         movem.l D0-D3/A0-A3,-(A7)
                            	    15: 
                            	    16:         moveq.l #6,D0                                   
                            	    17:         move.b  #\1,D1                                     
                            	    18:         trap    #15
                            	    19:     
                            	    20:         movem.l (A7)+,D0-D3/A0-A3
                            	    21:     ENDIF
                            	    22: ENDM
                            	    23: 
                            	    24: ; print sector information read from / written to a SD disk image (or real SD card)
                            	    25: ; pass in a character to this routine to specify type of operation on the sector eg 'R' or 'W'
                            	    26: debugPrintSector MACRO
                            	    27:     IFNE DEBUG
                            	    28:         movem.l D0-D3/A0-A3,-(A7)
                            	    29: 
                            	    30:         moveq.l #6,D0                                   
                            	    31:         move.b  #\1,D1                                     
                            	    32:         trap    #15
                            	    33:     
                            	    34:         moveq.l #15,D0
                            	    35:         move.l  (lastFATSector),D1                          ; sector in hex
                            	    36:         move.b  #16,D2
                            	    37:         trap    #15
                            	    38: 
                            	    39:         moveq.l #6,D0
                            	    40:         move.b  #'-',D1                                    
                            	    41:         trap    #15
                            	    42: 
                            	    43:         moveq.l #15,D0
                            	    44:         move.l  D3,D1                                       ; offset on sector in hex
                            	    45:         move.b  #16,D2
                            	    46:         trap    #15
                            	    47: 
                            	    48:         moveq.l #6,D0
                            	    49:         move.b  #' ',D1                                     
                            	    50:         trap    #15
                            	    51: 
                            	    52:         movem.l (A7)+,D0-D3/A0-A3
                            	    53:     ENDIF
                            	    54: ENDM
                            	    55: 
                            	    56: ; print sector information read from / written to a RAM disk
                            	    57: ; pass in a character to this routine to specify type of operation on the RAM drive eg 'R' or 'W'
                            	    58: ; Assuem A0 is already set up to point to the RAM being moved
                            	    59: debugPrintRAM MACRO
                            	    60:     IFNE DEBUG
                            	    61:         movem.l D0-D3/A0-A3,-(A7)
                            	    62: 
                            	    63:         exg     A0,A3                                       ; save A0 as trap 15 trashes it
                            	    64:         moveq.l #6,D0                                   
                            	    65:         move.b  #\1,D1                                     
                            	    66:         trap    #15
                            	    67:         exg     A3,A0
                            	    68: 
                            	    69:         moveq.l #15,D0
                            	    70:         move.l  A0,D1                                       ; address in hex
                            	    71:         move.b  #16,D2
                            	    72:         trap    #15
                            	    73: 
                            	    74:         moveq.l #6,D0
                            	    75:         move.b  #'-',D1                                     
                            	    76:         trap    #15
                            	    77: 
                            	    78:         moveq.l #15,D0
                            	    79:         move.l  (DMA),D1                          ; sector in hex
                            	    80:         move.b  #16,D2
                            	    81:         trap    #15
                            	    82: 
                            	    83:         moveq.l #6,D0
                            	    84:         move.b  #' ',D1                                     
                            	    85:         trap    #15
                            	    86: 
                            	    87:         movem.l (A7)+,D0-D3/A0-A3
                            	    88:     ENDIF
                            	    89: ENDM
                            	    90: 
                            	    91: ; print the number at address \1 in hex
                            	    92: debugPrintNum MACRO
                            	    93:         movem.l D0-D3/A0-A3,-(A7)
                            	    94:         moveq.l #15,D0
                            	    95:         move.l  (\1),D1
                            	    96:         move.b  #16,D2
                            	    97:         trap    #15
                            	    98:         movem.l (A7)+,D0-D3/A0-A3
                            	    99: ENDM
                            	   100: 
                            	   101: ; Macros to call traps and save any registers that are changed
                            	   102: 
                            	   103: ; print a string using trap 14,1 whilst preseving register A0
                            	   104: PrintStr MACRO
                            	   105:     movem.l D0-D3/A0-A3,-(A7)
                            	   106:     lea     \1,A0
                            	   107:     moveq.l #1,D1                                       
                            	   108:     trap    #14  
                            	   109:     movem.l (A7)+,D0-D3/A0-A3
                            	   110: ENDM
                            	   111: 
                            	   112: 
                            	   113: _init::    
                            	   114:     ; at this stage, we have loaded from the SDCARD, so we know its valid, no need to re-init
                            	   115:     ; need to find the starting sector of the CPM disk image on the sd card.
                            	   116:     ; To do this we will trawl through the FAT32 boot record etc
                            	   117: 
                            	   118:     ; to do this:
                            	   119:     ;   - read the MBR, block 0 and note:
                            	   120:     ;     - number of reserved sectors, 0x0E, word (eg 20 00)
                            	   121:     ;     - logical sectors per FAT, 0x24, long  (eg f1 03 00 00)
                            	   122:     ;     - number of fats, 0x10, byte (eg 02)
                            	   123:     ;   - This enables us to calculate:
                            	   124:     ;     - start of FAT table (sector after number of reserved sectors - 32 or 0x4000
                            	   125:     ;     - start of root directory,  Logical sectors per FAT (0x24) * Number of FATs (0x10) + Reserved logical sectors
                            	   126:     ;   - The root directory is arranged 32 bytes per entry.  We will assume our CPM disk image is in the root and call
                            	   127:     
                            	   128:     ; check sd card support
00:00000000 48E7F0F0        	   129:     movem.l D0-D3/A0-A3,-(A7)
00:00000004 7000            	   130:     moveq.l #0,D0
00:00000006 4E4D            	   131:     trap    #13
00:00000008 B0BC1234FEDC    	   132:     cmp.l   #$1234FEDC,D0                               ; check magic return
00:0000000E 66000214        	   133:     bne     .errNoSDsupport
00:00000012 4CDF0F0F        	   134:     movem.l (A7)+,D0-D3/A0-A3
                            	   135: 
                            	   136:     ; init the sd card and get sd card structure back
00:00000016 48E7F0F0        	   137:     movem.l D0-D3/A0-A3,-(A7)
00:0000001A 43FA1A78        	   138:     lea     sd,A1
00:0000001E 7001            	   139:     moveq.l #1,D0                                       
00:00000020 4E4D            	   140:     trap    #13
00:00000022 4A80            	   141:     cmp.l   #0,D0                                       ; check return
00:00000024 66000216        	   142:     bne     .errNoSDinit
00:00000028 4CDF0F0F        	   143:     movem.l (A7)+,D0-D3/A0-A3
                            	   144: 
                            	   145:     ; read the MBR from sector 0 on the disk so we can read the partition table
00:0000002C 48E7F0F0        	   146:     movem.l D0-D3/A0-A3,-(A7)
00:00000030 43FA1A62        	   147:     lea     sd,A1
00:00000034 7002            	   148:     moveq.l #2,D0                                       ; read the MBR from the sd card 
00:00000036 7200            	   149:     moveq.l #0,D1                                       ; sector number to read
00:00000038 45FA185A        	   150:     lea     sdBuf,A2
00:0000003C 4E4D            	   151:     trap    #13
00:0000003E 4A80            	   152:     cmp.l   #0,D0                                       ; check return
00:00000040 67000212        	   153:     beq     .errNoReadDiskMBR
00:00000044 4CDF0F0F        	   154:     movem.l (A7)+,D0-D3/A0-A3
                            	   155: 
                            	   156:     ; now we need to check the disk MBR for a partition table and get the offset to the first partition
                            	   157:     ; this is a bodge .. CPM has to be on the first partition, partiton 0 and 0x1BE on the disk MBR
                            	   158:     ; The code should really check all 4 partitions ..
                            	   159: 
                            	   160:     ; as we read longs and words off of the MBR we have to take endianess into account and switch the byte order 
                            	   161:     ; as we are on the 68000 CPU
00:00000048 2C3A1A10        	   162:     move.l  $1c6+sdBuf,D6                               ; read LBA start from partition 0
00:0000004C E15E            	   163:     rol.w   #8,D6
00:0000004E 4846            	   164:     swap    D6
00:00000050 E15E            	   165:     rol.w   #8,D6
00:00000052 23C600001AD4    	   166:     move.l  D6,partStartSector
                            	   167: 
                            	   168:     ; read the MBR from sector 0 of the partition so we can calculate position of the root diectory and hence the CPM i
00:00000058 48E7F0F0        	   169:     movem.l D0-D3/A0-A3,-(A7)
00:0000005C 43FA1A36        	   170:     lea     sd,A1
00:00000060 7002            	   171:     moveq.l #2,D0                                       ; read the MBR from the sd card 
00:00000062 2206            	   172:     move.l  D6,D1                                       ; sector number to read - partStartSector
00:00000064 45FA182E        	   173:     lea     sdBuf,A2
00:00000068 4E4D            	   174:     trap    #13
00:0000006A 4A80            	   175:     cmp.l   #0,D0                                       ; check return
00:0000006C 670001FE        	   176:     beq     .errNoReadPartMBR
00:00000070 4CDF0F0F        	   177:     movem.l (A7)+,D0-D3/A0-A3
                            	   178: 
00:00000074 3C3A182C        	   179:     move.w  $e+sdBuf,D6                                 ; number of reserved sectors from MBR.  Reversed due to endiane
00:00000078 E15E            	   180:     rol.w   #8,D6
00:0000007A 33C600001ADE    	   181:     move.w  D6,reservedSectors
                            	   182: 
00:00000080 2C3A183E        	   183:     move.l  $2c+sdBuf,D6                                ; read root director cluster (usually 2)
00:00000084 E15E            	   184:     rol.w   #8,D6
00:00000086 4846            	   185:     swap    D6
00:00000088 E15E            	   186:     rol.w   #8,D6
00:0000008A 23C600001AD8    	   187:     move.l  D6,rootDirectoryCluster
                            	   188: 
                            	   189:     ; up until the root directory, we use sectors; after the root directory we have to deal with clusters (groups of se
                            	   190:     ; see the diagram here: https://eric-lo.gitbook.io/lab9-filesystem/overview-of-fat32#
                            	   191:     ; we need to store the number of sectors per cluster for later use
00:00000090 7C00            	   192:     moveq.l #0,D6
00:00000092 1C3A180D        	   193:     move.b  $d+sdBuf,D6                                 ; read number of sectors per cluster
00:00000096 33C600001AE0    	   194:     move.w  D6,sectorsPerCluster                        ; save as a word for later mulu
                            	   195: 
                            	   196:     ; Calculate the sector of the root directory: 
                            	   197:     ; = sectors per FAT * number of FATs + number of reserved sectors
                            	   198:     ; += partStartSector to allow for the start of the partition on the disk
00:0000009C 2A3A181A        	   199:     move.l  $24+sdBuf,D5                                ; read sectors per FAT
00:000000A0 E15D            	   200:     rol.w   #8,D5
00:000000A2 4845            	   201:     swap    D5
00:000000A4 E15D            	   202:     rol.w   #8,D5
                            	   203:     
00:000000A6 7C00            	   204:     moveq.l #0,D6                                       ; read number of FAT tables
00:000000A8 1C3A17FA        	   205:     move.b  $10+sdBuf,D6
                            	   206: 
00:000000AC CCC5            	   207:     mulu.w  D5,D6
00:000000AE DC7A1A2E        	   208:     add.w   reservedSectors,D6
00:000000B2 DCBA1A20        	   209:     add.l   partStartSector,D6                          ; partStartSector is a long
00:000000B6 33C600001ADC    	   210:     move.w  D6,rootDirectorySector
                            	   211: 
                            	   212: 
                            	   213: ;    sector = sector of start of root directory
                            	   214: ;    entry = 0
                            	   215: ;    while (1) {
                            	   216: ;      offset = entry % 16
                            	   217: ;      if offset == 0 {
                            	   218: ;        // read next sector
                            	   219: ;        read next sector
                            	   220: ;        increment sector
                            	   221: ;      };;
                            	   222: ;
                            	   223: ;      directory_entry = offset * 32 plus buffer start
                            	   224: ;
                            	   225: ;      if directory_entry[0] == 0 { // end of root directory
                            	   226: ;        message failure
                            	   227: ;        return failure
                            	   228: ;      }
                            	   229: ;
                            	   230: ;      if directory_entry[0xb] & 0x10 { // subdirectory
                            	   231: ;        continue
                            	   232: ;      }
                            	   233: ;
                            	   234: ;      if directory entry[0xb] == 0xf { // record contains a long file name
                            	   235: ;        continue
                            	   236: ;      }
                            	   237: ;
                            	   238: ;      if strncmp(directory entry, "CPMDISK IMG", 11) {
                            	   239: ;        // found file, might have to ignore case here, lets see
                            	   240: ;        // record sector file starts and file length
                            	   241: ;        block = entry[20,21] << 16 + entry[26,27]
                            	   242: ;        // both of these are store lsb first eg length of 0x7e84 is stored 84 7e 00 00
                            	   243: ;        return success
                            	   244: ;      }
                            	   245: ;      entry++
                            	   246: ;    }
                            	   247: 
                            	   248: 
                            	   249:     ; search the FAT to try to find the CPM disk image
00:000000BC 7600            	   250:     moveq.l #0,D3                                       ; sector to read
00:000000BE 7800            	   251:     moveq.l #0,D4                                       ; directory entry in sector.  Sector is 512b, directory table i
                            	   252: 
                            	   253: .startDirectoryEntry:
00:000000C0 2A04            	   254:     move.l  D4,D5
00:000000C2 CABC0000000F    	   255:     and.l   #15,D5                                      ; only look at last 4 bits, we want to calculate (directory ent
00:000000C8 6630            	   256:     bne     .noReadRequired                             ; we dont need to read a new sector from the sd card
                            	   257: 
                            	   258:     ; read the MBR from sector 0 so we can calculate position of the MBR and root diectory in the CPM image
00:000000CA 43FA19C8        	   259:     lea     sd,A1
00:000000CE 7002            	   260:     moveq.l #2,D0                                       ; read sector trap
00:000000D0 7200            	   261:     moveq.l #0,D1                                       ; required for r68k to work correctly
00:000000D2 323A1A08        	   262:     move.w  rootDirectorySector,D1
00:000000D6 D243            	   263:     add.w   D3,D1                                       ; sector number to read plus offset to rootDirectoryCluster
00:000000D8 45FA17BA        	   264:     lea     sdBuf,A2
00:000000DC 4E4D            	   265:     trap    #13
00:000000DE 4A80            	   266:     cmp.l   #0,D0                                       ; check return
00:000000E0 6614            	   267:     bne     .noReadError
                            	   268:     
                            	   269:     PrintStr msgNoSdCardRead
00:000000E2 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:000000E6 41FA1A77        	     2M     lea     msgNoSdCardRead,A0
00:000000EA 7201            	     3M     moveq.l #1,D1                                       
00:000000EC 4E4E            	     4M     trap    #14  
00:000000EE 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
00:000000F2 7001            	   270:     moveq.l #1,D0                                       ; signal error
00:000000F4 4E75            	   271:     rts
                            	   272: 
                            	   273: .noReadError:
00:000000F6 5283            	   274:     addq.l  #1,D3                                       ; increment next sector to read
00:000000F8 7800            	   275:     moveq.l #0,D4                                       ; reset directory entry to zero 
                            	   276: 
                            	   277: .noReadRequired:
00:000000FA 2A04            	   278:     move.l  D4,D5                                       ; D4 contains directory record
00:000000FC EB8D            	   279:     lsl.l   #5,D5                                       ; multiply offset by 32 to get to start of directory record
00:000000FE DABC00001894    	   280:     add.l   #sdBuf,D5
00:00000104 2A45            	   281:     movea.l D5,A5
00:00000106 1C15            	   282:     move.b  (A5),D6
00:00000108 4A06            	   283:     tst.b   D6                                          ; reached end of root directory entries
00:0000010A 670000AE        	   284:     beq     .dirEnd
                            	   285: 
                            	   286: .notDirEnd:
00:0000010E 1C2D000B        	   287:     move.b  $b(A5),D6
00:00000112 BC3C0010        	   288:     cmp.b   #$10,D6
00:00000116 6700009C        	   289:     beq     .nextDir                                    ; skip subdirectories entries
00:0000011A BC3C000F        	   290:     cmp.b   #$f,D6
00:0000011E 67000094        	   291:     beq     .nextDir                                    ; skip long filename entries
                            	   292: 
                            	   293:     ; check to see if we have found the CPM Image file
                            	   294:     ; Check that name starts "CPMD"
00:00000122 49FA19C6        	   295:     LEA     imageName,A4
00:00000126 BB8C            	   296:     cmp.l   (A4)+,(A5)+
00:00000128 6600008A        	   297:     bne     .nextDir
                            	   298: 
                            	   299:     ; Check that the name ends in "IMG*"    
00:0000012C 584C            	   300:     addq    #4,A4
00:0000012E 584D            	   301:     addq    #4,A5
00:00000130 2C15            	   302:     move.l  (A5),D6                                      ; wipe last byte from FAT to compare to 0 from imageName
00:00000132 4206            	   303:     clr.b   D6
00:00000134 BC94            	   304:     cmp.l   (A4),D6
00:00000136 667C            	   305:     bne     .nextDir
                            	   306: 
                            	   307:     ; Now look at the middle "ISK*"
                            	   308:     ; The * can be a space or A..P
00:00000138 594C            	   309:     subq    #4,A4
00:0000013A 594D            	   310:     subq    #4,A5
                            	   311: 
00:0000013C 2A14            	   312:     move.l  (A4),D5                                      ; save last characters
00:0000013E 2C1D            	   313:     move.l  (A5)+,D6                                     ; increment A5 so that its aligned for below                  
00:00000140 1A06            	   314:     move.b  D6,D5                                        ; make last byte the same
00:00000142 BC85            	   315:     cmp.l   D5,D6                                        ; Check that "ISK" is the same
00:00000144 666E            	   316:     bne     .nextDir
                            	   317: 
00:00000146 CCBC000000FF    	   318:     and.l   #$FF,D6                                      ; clear top 3 bytes
                            	   319:     ; Now left to check last character
00:0000014C BC3C0020        	   320:     cmp.b   #' ',D6                                      ; CMPDISK.IMG found
00:00000150 670E            	   321:     beq     .foundCMPDISK
                            	   322: 
                            	   323: .checkdriveletter
00:00000152 9C3C0041        	   324:     sub.b   #'A',D6
00:00000156 6B06            	   325:     bmi     .notvaliddrive
00:00000158 BC3C000F        	   326:     cmp.b   #15,D6
00:0000015C 6F06            	   327:     ble     .validdrive
                            	   328:  
                            	   329: .notvaliddrive
                            	   330:     ; MESSAGE IGNOREING
00:0000015E 6654            	   331:     bne     .nextDir
                            	   332: 
                            	   333: .foundCMPDISK
                            	   334:     ; change D6 to 16 (one past end of CPMDRIVE table) and fall through
00:00000160 1C3C0010        	   335:     move.b  #16,D6
                            	   336:    
                            	   337: .validdrive
                            	   338:     ; found file, A5 will now be pointing at entry[8] so adjust offsets to compensate
                            	   339:     ;        block = entry[20,21] << 16 + entry[26,27]
                            	   340:     ; get starting block of CPMDISK.IMG
00:00000164 3A2D000C        	   341:     move.w  $c(A5),D5                                   
00:00000168 E15D            	   342:     rol.w   #8,D5
00:0000016A 4845            	   343:     swap    D5
00:0000016C 3A2D0012        	   344:     move.w  $12(A5),D5
00:00000170 E15D            	   345:     rol.w   #8,D5
                            	   346: 
00:00000172 9ABA1964        	   347:     sub.l   (rootDirectoryCluster),D5                   ; allow for the position of the root directory (usually 2)
00:00000176 CAFA1968        	   348:     mulu.w  (sectorsPerCluster),D5  
                            	   349: 
                            	   350:     ; for efficiency we will point CPMImageSector at the actual block on the sd card
00:0000017A DA7A1960        	   351:     add.w   (rootDirectorySector),D5
                            	   352: 
00:0000017E 1406            	   353:     move.b  D6,D2                                       ; Save for printing drive later
                            	   354: 
00:00000180 41FA0370        	   355:     lea     CPMDISK,A0
00:00000184 DC06            	   356:     add.b   D6,D6
00:00000186 DC06            	   357:     add.b   D6,D6
00:00000188 D1C6            	   358:     add.l   D6,A0
00:0000018A 2085            	   359:     move.l  D5,(A0)
                            	   360: 
                            	   361:     ; Print out a message about the mapping (if not CPMDISK.IMG, this printed later after other drives assigned)
                            	   362:     ; HACK sort this out msgMapDriveSource
                            	   363: 
00:0000018C B43C0010        	   364:     cmp.b   #16,D2                                      ; Skip over CPMDISK.IMG 
00:00000190 6722            	   365:     beq     .nextDir
                            	   366: 
00:00000192 123C0041        	   367:     move.b  #'A',D1                                      
00:00000196 D202            	   368:     add.b   D2,D1
00:00000198 13C100001C2E    	   369:     move.b  D1,msgMapDriveLetter
00:0000019E 13C100001C25    	   370:     move.b  D1,msgMapDriveSource
                            	   371: 
                            	   372:     PrintStr msgMapDrive
00:000001A4 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:000001A8 41FA1A6D        	     2M     lea     msgMapDrive,A0
00:000001AC 7201            	     3M     moveq.l #1,D1                                       
00:000001AE 4E4E            	     4M     trap    #14  
00:000001B0 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
                            	   373: 
                            	   374: .nextDir:
00:000001B4 5284            	   375:     addq.l  #1,D4                                       ; look at next directory entry
00:000001B6 6000FF08        	   376:     bra     .startDirectoryEntry
                            	   377: 
                            	   378:     ; So now we have read the whole directory and need to do some tidy up:
                            	   379:     ;   if we have found "CPMDISK.IMG" then we need to place this in the table if possible 
                            	   380:     ;   we need to try to place the RAMDISK in the mapping table
                            	   381:     ; Why have CPMDISK.IMG ? TO me most people will only want one disk .. and this is the best name :o
                            	   382: 
                            	   383: .dirEnd
00:000001BA 43FA0336        	   384:     lea     CPMDISK,A1
00:000001BE 223A0372        	   385:     move.l  (CPMDISK+64),D1                             ; "CPMDISK.IMG" sector if found stored at 17th entry in table
00:000001C2 760F            	   386:     moveq   #15,D3                                      ; looping variable, 16=max number of drives, -1 for dbra
                            	   387: .nextdiskmap
00:000001C4 4A91            	   388:     tst.l   (A1)
00:000001C6 6624            	   389:     bne     .continue                                   ; not an empty slot, try to loop around
                            	   390: 
00:000001C8 4A01            	   391:     tst.b   D1                                          ; see if we need to map CPMDISK.IMG
00:000001CA 6728            	   392:     beq     .sortoutramdrive
00:000001CC 2281            	   393:     move.l  D1,(A1)
                            	   394: 
                            	   395:     ; format drive letter for message
00:000001CE 123C0050        	   396:     move.b  #'A'+15,D1                                      
00:000001D2 9203            	   397:     sub.b   D3,D1
00:000001D4 13C100001BFD    	   398:     move.b  D1,msgMapCPMDriveLetter
                            	   399: 
                            	   400:     PrintStr msgMapCPMDrive
00:000001DA 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:000001DE 41FA1A07        	     2M     lea     msgMapCPMDrive,A0
00:000001E2 7201            	     3M     moveq.l #1,D1                                       
00:000001E4 4E4E            	     4M     trap    #14  
00:000001E6 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
00:000001EA 7200            	   401:     moveq   #0,D1                                       ; note that CPMDISK.IMG now mapped
                            	   402:     
                            	   403: .continue
00:000001EC 5849            	   404:     addq    #4,A1    
00:000001EE 51CBFFD4        	   405:     dbra    D3,.nextdiskmap
                            	   406: 
                            	   407:     ; Need to check is we failed to map CPMDRIVE.IMG and RAMDRIVE and message
00:000001F2 6024            	   408:     bra     .finish
                            	   409: 
                            	   410: .sortoutramdrive
00:000001F4 720F            	   411:     moveq   #15,D1                                      ; reuse D1
00:000001F6 9203            	   412:     sub.b   D3,D1
00:000001F8 13C100000536    	   413:     move.b  D1,RAMDRIVE                                 ; now that we fix up RAMDRIVE we are done, so can fall out of l
                            	   414: 
                            	   415:     ; message RAM drive mapping
00:000001FE D23C0041        	   416:     add.b   #'A',D1
00:00000202 13C100001C14    	   417:     move.b  D1,msgMapRAMDriveLetter
                            	   418:     PrintStr msgMapRAMDrive
00:00000208 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:0000020C 41FA19F2        	     2M     lea     msgMapRAMDrive,A0
00:00000210 7201            	     3M     moveq.l #1,D1                                       
00:00000212 4E4E            	     4M     trap    #14  
00:00000214 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
                            	   419: 
                            	   420: .finish
00:00000218 21FC00000284008C	   421:     move.l  #TRAPHNDL,$8c                               ; set up trap #3 handler
00:00000220 7000            	   422:     moveq.l #0,D0                                       ; log on disk A, user 0
00:00000222 4E75            	   423:     rts
                            	   424: 
                            	   425: ; errors during _init 
                            	   426: .errNoSDsupport
00:00000224 4CDF0F0F        	   427:     movem.l (A7)+,D0-D3/A0-A3
                            	   428:     PrintStr msgNoSdCardSupport
00:00000228 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:0000022C 41FA18C8        	     2M     lea     msgNoSdCardSupport,A0
00:00000230 7201            	     3M     moveq.l #1,D1                                       
00:00000232 4E4E            	     4M     trap    #14  
00:00000234 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
00:00000238 7001            	   429:     moveq.l #1,D0                                       ; signal error
00:0000023A 4E75            	   430:     rts
                            	   431: 
                            	   432:  .errNoSDinit:
00:0000023C 4CDF0F0F        	   433:     movem.l (A7)+,D0-D3/A0-A3
                            	   434:     PrintStr msgNoSdCardInit
00:00000240 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:00000244 41FA18D3        	     2M     lea     msgNoSdCardInit,A0
00:00000248 7201            	     3M     moveq.l #1,D1                                       
00:0000024A 4E4E            	     4M     trap    #14  
00:0000024C 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
00:00000250 7001            	   435:     moveq.l #1,D0                                       ; signal error
00:00000252 4E75            	   436:     rts
                            	   437: 
                            	   438: .errNoReadDiskMBR:
00:00000254 4CDF0F0F        	   439:     movem.l (A7)+,D0-D3/A0-A3
                            	   440:     PrintStr msgNoSdCardReadMBR
00:00000258 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:0000025C 41FA18DF        	     2M     lea     msgNoSdCardReadMBR,A0
00:00000260 7201            	     3M     moveq.l #1,D1                                       
00:00000262 4E4E            	     4M     trap    #14  
00:00000264 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
00:00000268 7001            	   441:     moveq.l #1,D0                                       ; signal error
00:0000026A 4E75            	   442:     rts
                            	   443: 
                            	   444: .errNoReadPartMBR:
00:0000026C 4CDF0F0F        	   445:     movem.l (A7)+,D0-D3/A0-A3
                            	   446:     PrintStr msgNoSdCardRead
00:00000270 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:00000274 41FA18E9        	     2M     lea     msgNoSdCardRead,A0
00:00000278 7201            	     3M     moveq.l #1,D1                                       
00:0000027A 4E4E            	     4M     trap    #14  
00:0000027C 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
00:00000280 7001            	   447:     moveq.l #1,D0                                       ; signal error
00:00000282 4E75            	   448:     rts
                            	   449: 
                            	   450: 
                            	   451: 
                            	   452: TRAPHNDL:
00:00000284 0C400017        	   453:     cmpi    #23,D0                                      ; Function call in range ?
00:00000288 6408            	   454:     bcc     TRAPNG
                            	   455: 
00:0000028A E588            	   456:     lsl.l   #2,D0                                       ; change function call to offset by multiplting by 4
00:0000028C 207B0006        	   457:     move.l  BIOSBASE(PC,D0),A0          ; ... and calc offset into table...
00:00000290 4E90            	   458:     jsr     (A0)                        ; ... then jump there
                            	   459: 
                            	   460: TRAPNG:
00:00000292 4E73            	   461:     rte
                            	   462: 
                            	   463: BIOSBASE:
00:00000294 00000000        	   464:     dc.l    _init
00:00000298 000002F0        	   465:     dc.l    WBOOT
00:0000029C 000002F6        	   466:     dc.l    CONSTAT
00:000002A0 00000300        	   467:     dc.l    CONIN
00:000002A4 0000030E        	   468:     dc.l    CONOUT
00:000002A8 00000314        	   469:     dc.l    LSTOUT
00:000002AC 00000314        	   470:     dc.l    PUN
00:000002B0 00000314        	   471:     dc.l    RDR
00:000002B4 0000031E        	   472:     dc.l    HOME
00:000002B8 00000326        	   473:     dc.l    SELDSK
00:000002BC 00000374        	   474:     dc.l    SETTRK
00:000002C0 0000037C        	   475:     dc.l    SETSEC
00:000002C4 00000388        	   476:     dc.l    SETDMA
00:000002C8 00000392        	   477:     dc.l    READ
00:000002CC 0000044E        	   478:     dc.l    WRITE
00:000002D0 00000318        	   479:     dc.l    LISTST
00:000002D4 00000384        	   480:     dc.l    SECTRAN
00:000002D8 00000390        	   481:     dc.l    MISSING
00:000002DC 000004AA        	   482:     dc.l    GETSEG
00:000002E0 00000314        	   483:     dc.l    GETIOB
00:000002E4 00000314        	   484:     dc.l    SETIOB
00:000002E8 000004A6        	   485:     dc.l    FLUSH
00:000002EC 000004B2        	   486:     dc.l    SETEXC
                            	   487: 
                            	   488: 
                            	   489: WBOOT:  
00:000002F0 4EF9000150BC    	   490:     jmp     _ccp
                            	   491: 
                            	   492: CONSTAT: 
                            	   493: ; Check for keyboard input. Set d0 to 1 if keyboard input is pending, otherwise set to 0.
00:000002F6 7007            	   494:     moveq.l #7,D0                        ; use EASy68k trap 15 task 7
00:000002F8 4E4F            	   495:     trap    #15                          ; d1.b = 1 if keyboard ready, otherwise = 0
00:000002FA 7000            	   496:     moveq.l #0,D0
00:000002FC 1001            	   497:     move.b  D1,D0
00:000002FE 4E75            	   498:     rts
                            	   499: 
                            	   500: CONIN:    
                            	   501: ; Read single ASCII character from the keyboard into d0
                            	   502: ; Rosco implementation of this trap waits for input
00:00000300 7005            	   503:     moveq.l #5,D0                        ; use EASy68k trap 15 task 5
00:00000302 4E4F            	   504:     trap    #15                          ; d1.b contains the ascii character
00:00000304 1001            	   505:     move.b  D1,D0      
00:00000306 C0BC0000007F    	   506:     and.l   #$7f,D0                      ; only use 7 bit character set
00:0000030C 4E75            	   507:     rts
                            	   508: 
                            	   509: CONOUT: 
                            	   510: ; Display single ASCII character in d1
00:0000030E 7006            	   511:     moveq.l #6,D0                        ; use EASy68k trap 15 task 6
00:00000310 4E4F            	   512:     trap    #15
00:00000312 4E75            	   513:     rts                                  ; and exit
                            	   514: 
                            	   515: LSTOUT:    
                            	   516: PUN:
                            	   517: RDR:
                            	   518: GETIOB:
                            	   519: SETIOB:
00:00000314 7000            	   520:     moveq.l #0,D0
00:00000316 4E75            	   521:     rts
                            	   522: 
                            	   523: LISTST:    
00:00000318 103C00FF        	   524:     move.b #$ff,D0
00:0000031C 4E75            	   525:     rts
                            	   526: 
                            	   527: HOME:    
00:0000031E 4279000004DE    	   528:     clr.w  TRACK
00:00000324 4E75            	   529:     rts
                            	   530: 
                            	   531: SELDSK:    
                            	   532: ; drive should be in d1.b
                            	   533: ; now trashes A0
                            	   534: 
                            	   535:     ; as spotted by jjlov, D1 can come in dirty, so clean
00:00000326 C2BC0000000F    	   536:     and.l   #15,D1
                            	   537: 
00:0000032C B23A0208        	   538:     cmp.b   (RAMDRIVE),D1
00:00000330 6730            	   539:     beq     .selram
                            	   540: 
00:00000332 B23C000F        	   541:     cmp.b   #15,D1                  ; 16 max drives for cpm68k
00:00000336 6E38            	   542:     bgt     .seldsk_error           ; .. return without changing anything
                            	   543: 
00:00000338 7000            	   544:     moveq   #0,D0
00:0000033A 1001            	   545:     move.b  D1,D0                   ; save for later
                            	   546: 
00:0000033C D201            	   547:     add.b   D1,D1                   ; Multiply D1 by 4 to change to address
00:0000033E D201            	   548:     add.b   D1,D1
00:00000340 41FA01B0        	   549:     lea     CPMDISK,A0
00:00000344 22301800        	   550:     move.l  (0,A0,D1.L),D1            ; move sector for the requested disk to D1
                            	   551:     
00:00000348 6726            	   552:     beq     .seldsk_error           ; zero so no disk mapped to this slot
                            	   553: 
00:0000034A 23C100001AE2    	   554:     move.l  D1,(CPMImageSector)     ; set up FAT32 sector for disk image for read/write routine
                            	   555:                                     
00:00000350 13C0000004DC    	   556:     move.b  D0,SELDRV               ; set up selected drive
00:00000356 C0FC001A        	   557:     mulu    #26,D0                  ; 26 is the size of the DPH 
00:0000035A 41FA01DC        	   558:     lea     DPH0,A0
00:0000035E D088            	   559:     add.l   A0,D0                   ; return D0 pointing to the right DPH
00:00000360 4E75            	   560:     rts
                            	   561: 
                            	   562: .selram
00:00000362 13C1000004DC    	   563:     move.b  D1,SELDRV
00:00000368 203C000006E8    	   564:     move.l  #DPH1,D0
00:0000036E 4E75            	   565:     rts
                            	   566:     
                            	   567: .seldsk_error
00:00000370 7000            	   568:     moveq   #0,D0                   ; Signal error
00:00000372 4E75            	   569:     rts
                            	   570: 
                            	   571: SETTRK:    
00:00000374 33C1000004DE    	   572:     move.w  D1,TRACK
00:0000037A 4E75            	   573:     rts
                            	   574: 
                            	   575: SETSEC:    
00:0000037C 33C1000004E0    	   576:     move.w  D1,SECTOR
00:00000382 4E75            	   577:     rts
                            	   578: 
                            	   579: SECTRAN:
                            	   580: ;    no sector translate, put d1 into d0 and return
00:00000384 3001            	   581:     move.w  D1,D0
00:00000386 4E75            	   582:     rts
                            	   583: 
                            	   584: SETDMA:
00:00000388 23C1000004E2    	   585:     move.l  D1,DMA
00:0000038E 4E75            	   586:     rts
                            	   587: 
                            	   588: MISSING:
                            	   589:     ; this number is missing from the table in the
                            	   590:     ; CPM 68k documentation, doesn't seem to be ever called
00:00000390 4E75            	   591:     rts
                            	   592: 
                            	   593: READ:
                            	   594: ; Read one cpm sector from requested disk, track, sector to dma address
                            	   595: ; Can be a cpmimage on the sd card or the ram disk
                            	   596:     ;cmp.b   #0,SELDRV
                            	   597:     ;bne     .readRAMDrive
00:00000392 103A01A2        	   598:     move.b  (RAMDRIVE),D0
00:00000396 B03A0144        	   599:     cmp.b   SELDRV,D0
00:0000039A 6712            	   600:     beq     .readRAMDrive
                            	   601: 
00:0000039C 6142            	   602:     bsr     setupReadDisk                               ; sets A0 to point to the right 128 bytes in memory, potentiall
00:0000039E 227A0142        	   603:     move.l  DMA,A1
00:000003A2 701F            	   604:     move.l  #(128/4-1),D0  
                            	   605: 
                            	   606: .MOVE_LOOP1:
00:000003A4 22D8            	   607:     MOVE.L  (A0)+,(A1)+                                 ; copy long word from source to dest
00:000003A6 51C8FFFC        	   608:     dbra    D0,.MOVE_LOOP1
                            	   609:     
00:000003AA 7000            	   610:     moveq.l #0,D0                                       ; return OK status         
00:000003AC 4E75            	   611:     rts
                            	   612: 
                            	   613: .readRAMDrive:
00:000003AE 6110            	   614:     bsr     setupReadRAM                                ; sets A0 to point to the right 128 bytes in memory to read
                            	   615:     debugPrintRAM 'R'
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         exg     A0,A3                                       ; save A0 as trap 15 trashes it
                            	     5M         moveq.l #6,D0                                   
                            	     6M         move.b  #'R',D1                                     
                            	     7M         trap    #15
                            	     8M         exg     A3,A0
                            	     9M 
                            	    10M         moveq.l #15,D0
                            	    11M         move.l  A0,D1                                       ; address in hex
                            	    12M         move.b  #16,D2
                            	    13M         trap    #15
                            	    14M 
                            	    15M         moveq.l #6,D0
                            	    16M         move.b  #'-',D1                                     
                            	    17M         trap    #15
                            	    18M 
                            	    19M         moveq.l #15,D0
                            	    20M         move.l  (DMA),D1                          ; sector in hex
                            	    21M         move.b  #16,D2
                            	    22M         trap    #15
                            	    23M 
                            	    24M         moveq.l #6,D0
                            	    25M         move.b  #' ',D1                                     
                            	    26M         trap    #15
                            	    27M 
                            	    28M         movem.l (A7)+,D0-D3/A0-A3
                            	    29M     ENDIF
00:000003B0 227A0130        	   616:     move.l  DMA,A1
00:000003B4 701F            	   617:     move.l  #(128/4-1),d0  
                            	   618: 
                            	   619: .MOVE_LOOP2:
00:000003B6 22D8            	   620:     MOVE.L  (A0)+,(A1)+                                 ; copy long word from source to dest
00:000003B8 51C8FFFC        	   621:     dbra    D0,.MOVE_LOOP2
                            	   622: 
00:000003BC 7000            	   623:     moveq.l #0,D0                                       ; return OK status         
00:000003BE 4E75            	   624:     rts         
                            	   625: 
                            	   626: setupReadRAM:
                            	   627: ; translate track/sector into RAM location on the RAM drive
00:000003C0 7000            	   628:     moveq.l #0,D0
00:000003C2 303A011A        	   629:     move.w  TRACK,D0
00:000003C6 760C            	   630:     moveq.l #12,D3                                      ; much faster than shifting by 8 then 4 (40 versus 12 cycles)
00:000003C8 E7A8            	   631:     lsl.l   D3,D0
                            	   632: 
00:000003CA 7400            	   633:     moveq.l #0,D2
00:000003CC 343A0112        	   634:     move.w  SECTOR,D2
00:000003D0 7607            	   635:     moveq.l #7,D3                                       ; much faster than shifting by 7 (22 versus 12 cycles)
00:000003D2 E7AA            	   636:     lsl.l   D3,D2
                            	   637: 
00:000003D4 D082            	   638:     add.l   D2,D0
00:000003D6 D0BC000C0000    	   639:     add.l   #ramDriveLocation,D0                        ; add base address of RAM drive
00:000003DC 2040            	   640:     movea.l D0,A0                                       ; point to the track/sector in RAM drive
00:000003DE 4E75            	   641:     rts
                            	   642: 
                            	   643: setupReadDisk:
                            	   644: ;
                            	   645: ; algorithm
                            	   646: ;
                            	   647: ; keep 512b in a memory buffer
                            	   648: ; keep sector number of the data currently in the buffer
                            	   649: ;
                            	   650: ; if requested sector not in buffer {
                            	   651: ;     calcuate the sector and offset that the FAT entry for the sector is located in
                            	   652: ;     read sector pointed to in FAT table from disk into buffer
                            	   653: ;     note requested sector in buffer
                            	   654: ; }
                            	   655: ;
                            	   656: ; calculate offset of CPM 128b required in 512b buffer
                            	   657: ; copy the correct 12b across into the CPM dma area
                            	   658: 
                            	   659:     ; start by calculating the requested (FAT32) sector number from TRACK and SECTOR in D0
                            	   660:     ; also calculate the offset into that 512b buffer for the 128b CPM sector data in D3
00:000003E0 7200            	   661:     moveq.l #0,D1
00:000003E2 323A00FA        	   662:     move.w  TRACK,D1
00:000003E6 E789            	   663:     lsl.l   #3,D1
                            	   664: 
00:000003E8 7400            	   665:     moveq.l #0,D2
00:000003EA 343A00F4        	   666:     move.w  SECTOR,D2
                            	   667: 
00:000003EE 2602            	   668:     move.l  D2,D3
00:000003F0 C6BC00000003    	   669:     and.l   #3,D3                                       ; use D3 to calculate the offset of the 128b CPM sector in the 
00:000003F6 7807            	   670:     moveq.l #7,D4                                       ; much faster than shifting by 7 (22 versus 12 cycles)
00:000003F8 E9AB            	   671:     lsl.l   D4,D3
                            	   672: 
00:000003FA E48A            	   673:     lsr.l   #2,D2
00:000003FC D282            	   674:     add.l   D2,D1                                        ; D1 now has the requested sector number
00:000003FE D2BA16E2        	   675:     add.l   (CPMImageSector),D1                          ; D1 now has the actual sector on the SD card
                            	   676: 
                            	   677:     ; check to see if this FAT32 sector already in memory
00:00000402 B2BA16E2        	   678:     cmp.l (lastFATSector),D1
00:00000406 673E            	   679:     beq   .noDiskReadRequired
                            	   680: 
                            	   681:     ; we are going to read the sector (hopefully) so update the last read FAT sector before we lose the contents of D1
00:00000408 23C100001AE6    	   682:     move.l D1,lastFATSector
                            	   683: 
                            	   684:     ; we assume that the FAT table is contiguous for the CP/M image
                            	   685:     ; file, this avoids a walk of the FAT table linked list .. but wont deal with any bad sectors on the sd card
                            	   686: 
00:0000040E 43FA1684        	   687:     lea     sd,A1
00:00000412 7002            	   688:     moveq.l #2,D0                                        ; read sector function code
00:00000414 45FA147E        	   689:     lea     sdBuf,A2
00:00000418 4E4D            	   690:     trap    #13
00:0000041A 4A80            	   691:     cmp.l   #0,D0                                        ; check return
00:0000041C 6628            	   692:     bne     .noDiskReadError
                            	   693: 
                            	   694:     ; if we get here we had a disk read error
                            	   695:     debugPrintSector 'E'    
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         moveq.l #6,D0                                   
                            	     5M         move.b  #'E',D1                                     
                            	     6M         trap    #15
                            	     7M     
                            	     8M         moveq.l #15,D0
                            	     9M         move.l  (lastFATSector),D1                          ; sector in hex
                            	    10M         move.b  #16,D2
                            	    11M         trap    #15
                            	    12M 
                            	    13M         moveq.l #6,D0
                            	    14M         move.b  #'-',D1                                    
                            	    15M         trap    #15
                            	    16M 
                            	    17M         moveq.l #15,D0
                            	    18M         move.l  D3,D1                                       ; offset on sector in hex
                            	    19M         move.b  #16,D2
                            	    20M         trap    #15
                            	    21M 
                            	    22M         moveq.l #6,D0
                            	    23M         move.b  #' ',D1                                     
                            	    24M         trap    #15
                            	    25M 
                            	    26M         movem.l (A7)+,D0-D3/A0-A3
                            	    27M     ENDIF
                            	   696:     PrintStr msgNoSdCardRead
00:0000041E 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:00000422 41FA173B        	     2M     lea     msgNoSdCardRead,A0
00:00000426 7201            	     3M     moveq.l #1,D1                                       
00:00000428 4E4E            	     4M     trap    #14  
00:0000042A 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
                            	   697: 
00:0000042E 7001            	   698:     moveq.l #1,D0                                       ; signal error
                            	   699: 
00:00000430 23FCFFFFFFFF0000	   700:     move.l  #-1,lastFATSector
00:00000438 1AE6
00:0000043A 243C000000FF    	   701:     move.l  #$ff,D2
00:00000440 45BC0001        	   702:     chk     #1,D2                                       ; cause a trap to stop execution
00:00000444 4E75            	   703:     rts                                                 ; should not get here .. 
                            	   704: 
                            	   705: .noDiskReadError:
                            	   706:     debugPrintSector 'R'
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         moveq.l #6,D0                                   
                            	     5M         move.b  #'R',D1                                     
                            	     6M         trap    #15
                            	     7M     
                            	     8M         moveq.l #15,D0
                            	     9M         move.l  (lastFATSector),D1                          ; sector in hex
                            	    10M         move.b  #16,D2
                            	    11M         trap    #15
                            	    12M 
                            	    13M         moveq.l #6,D0
                            	    14M         move.b  #'-',D1                                    
                            	    15M         trap    #15
                            	    16M 
                            	    17M         moveq.l #15,D0
                            	    18M         move.l  D3,D1                                       ; offset on sector in hex
                            	    19M         move.b  #16,D2
                            	    20M         trap    #15
                            	    21M 
                            	    22M         moveq.l #6,D0
                            	    23M         move.b  #' ',D1                                     
                            	    24M         trap    #15
                            	    25M 
                            	    26M         movem.l (A7)+,D0-D3/A0-A3
                            	    27M     ENDIF
                            	   707:     ;jmp    .noCachePrint
                            	   708: 
                            	   709: .noDiskReadRequired:
                            	   710:     ;debugPrintSector 'C'
                            	   711:     
                            	   712: .noCachePrint:
00:00000446 41FA144C        	   713:     lea    sdBuf,A0
00:0000044A D1C3            	   714:     add.l  D3,A0                                        ; add offset into 512b buffer
00:0000044C 4E75            	   715:     rts
                            	   716: 
                            	   717: WRITE:
                            	   718: ; Write one cpm sector from requested disk, track, sector to dma address
                            	   719: ; Can be a cpmimage on the sd card or the ram disk
                            	   720:     ;cmp.b   #0,SELDRV
                            	   721:     ;bne     .writeRAMDrive
00:0000044E 103A00E6        	   722:     move.b  (RAMDRIVE),D0
00:00000452 B03A0088        	   723:     cmp.b   SELDRV,D0
00:00000456 673A            	   724:     beq     .writeRAMDrive
                            	   725: 
                            	   726: 
                            	   727:     ; going to write to disk    
00:00000458 6186            	   728:     bsr     setupReadDisk                               ; sets A0 to point to the right 128 bytes in memory, potentiall
                            	   729:     debugPrintSector 'W'
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         moveq.l #6,D0                                   
                            	     5M         move.b  #'W',D1                                     
                            	     6M         trap    #15
                            	     7M     
                            	     8M         moveq.l #15,D0
                            	     9M         move.l  (lastFATSector),D1                          ; sector in hex
                            	    10M         move.b  #16,D2
                            	    11M         trap    #15
                            	    12M 
                            	    13M         moveq.l #6,D0
                            	    14M         move.b  #'-',D1                                    
                            	    15M         trap    #15
                            	    16M 
                            	    17M         moveq.l #15,D0
                            	    18M         move.l  D3,D1                                       ; offset on sector in hex
                            	    19M         move.b  #16,D2
                            	    20M         trap    #15
                            	    21M 
                            	    22M         moveq.l #6,D0
                            	    23M         move.b  #' ',D1                                     
                            	    24M         trap    #15
                            	    25M 
                            	    26M         movem.l (A7)+,D0-D3/A0-A3
                            	    27M     ENDIF
00:0000045A 227A0086        	   730:     move.l  DMA,A1
00:0000045E 701F            	   731:     move.l  #(128/4-1),d0  
                            	   732:     
                            	   733: .MOVE_LOOP3:
00:00000460 20D9            	   734:     MOVE.L  (A1)+,(A0)+                                 ; copy long word from source to dest, reverse direction from re
00:00000462 51C8FFFC        	   735:     dbra    D0,.MOVE_LOOP3
                            	   736: 
                            	   737:     ; and write out the 512b buffer to disk
00:00000466 223A167E        	   738:     move.l  (lastFATSector),D1                          ; set up in SETUPRD
00:0000046A 43FA1628        	   739:     lea     sd,A1
00:0000046E 7003            	   740:     moveq.l #3,D0                                       ; write sector function call
00:00000470 45FA1422        	   741:     lea     sdBuf,A2                                    ; write out sdBuf to disk
00:00000474 4E4D            	   742:     trap    #13
00:00000476 4A80            	   743:     cmp.l   #0,D0                                       ; check return
00:00000478 6614            	   744:     bne     .noWriteError
                            	   745: 
                            	   746:     PrintStr msgNoSdCardWrite
00:0000047A 48E7F0F0        	     1M     movem.l D0-D3/A0-A3,-(A7)
00:0000047E 41FA16FD        	     2M     lea     msgNoSdCardWrite,A0
00:00000482 7201            	     3M     moveq.l #1,D1                                       
00:00000484 4E4E            	     4M     trap    #14  
00:00000486 4CDF0F0F        	     5M     movem.l (A7)+,D0-D3/A0-A3
00:0000048A 7001            	   747:     moveq.l #1,D0                                       ; signal error
00:0000048C 4E75            	   748:     rts
                            	   749:     
                            	   750: .noWriteError:
                            	   751:     ;move.l #-1,lastFATSector
00:0000048E 7000            	   752:     moveq.l #0,D0                                       ; return success
00:00000490 4E75            	   753:     rts                    
                            	   754: 
                            	   755: .writeRAMDrive:
00:00000492 6100FF2C        	   756:     bsr     setupReadRAM                                ; sets A0 to point to the right 128 bytes in memory to read
                            	   757:     debugPrintRAM 'W'
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         exg     A0,A3                                       ; save A0 as trap 15 trashes it
                            	     5M         moveq.l #6,D0                                   
                            	     6M         move.b  #'W',D1                                     
                            	     7M         trap    #15
                            	     8M         exg     A3,A0
                            	     9M 
                            	    10M         moveq.l #15,D0
                            	    11M         move.l  A0,D1                                       ; address in hex
                            	    12M         move.b  #16,D2
                            	    13M         trap    #15
                            	    14M 
                            	    15M         moveq.l #6,D0
                            	    16M         move.b  #'-',D1                                     
                            	    17M         trap    #15
                            	    18M 
                            	    19M         moveq.l #15,D0
                            	    20M         move.l  (DMA),D1                          ; sector in hex
                            	    21M         move.b  #16,D2
                            	    22M         trap    #15
                            	    23M 
                            	    24M         moveq.l #6,D0
                            	    25M         move.b  #' ',D1                                     
                            	    26M         trap    #15
                            	    27M 
                            	    28M         movem.l (A7)+,D0-D3/A0-A3
                            	    29M     ENDIF
00:00000496 227A004A        	   758:     move.l  DMA,A1
00:0000049A 701F            	   759:     move.l  #(128/4-1),d0  
                            	   760: 
                            	   761: .MOVE_LOOP4:
00:0000049C 20D9            	   762:     MOVE.L  (A1)+,(A0)+                                 ; copy long word from source to dest, reverse direction from re
00:0000049E 51C8FFFC        	   763:     dbra    D0,.MOVE_LOOP4
                            	   764: 
00:000004A2 7000            	   765:     moveq.l #0,D0
00:000004A4 4E75            	   766:     rts        
                            	   767: 
                            	   768: FLUSH:
00:000004A6 7000            	   769:     moveq.l #0,D0                                       ; return successful
00:000004A8 4E75            	   770:     rts
                            	   771: 
                            	   772: GETSEG:
00:000004AA 203C000004E8    	   773:     move.l #MEMRGN,D0                                   ; return address of mem region table
00:000004B0 4E75            	   774:     rts
                            	   775: 
                            	   776: SETEXC:
00:000004B2 0281000000FF    	   777:     andi.l  #$ff,D1                                     ; do only for exceptions 0 - 255
                            	   778: 
00:000004B8 0C41002D        	   779:     cmpi    #45,D1
00:000004BC 671A            	   780:     beq     NOSET                                       ; don't set trap 13,14,15 as used by rosco firmware
00:000004BE 0C41002E        	   781:     cmpi    #46,D1
00:000004C2 6714            	   782:     beq     NOSET                        
00:000004C4 0C41002F        	   783:     cmpi    #47,D1
00:000004C8 670E            	   784:     beq     NOSET                       
00:000004CA 0C410009        	   785:     cmpi    #9,D1                                       ; don't set trace trap
00:000004CE 6708            	   786:     beq     NOSET
00:000004D0 E549            	   787:     lsl     #2,D1                                       ; multiply exception number by 4
00:000004D2 2041            	   788:     movea.l D1,A0
00:000004D4 2010            	   789:     move.l  (A0),D0                                     ; return old vector value
00:000004D6 2082            	   790:     move.l  D2,(A0)                                     ; insert new vector
                            	   791: 
                            	   792: NOSET:    
00:000004D8 4E75            	   793:     rts
                            	   794: 
                            	   795: * ************************************************************************** *
                            	   796: ; Data
                            	   797: * ************************************************************************** *
                            	   798: 
                            	   799:               align 2                    ; DMA must be at even address
00:000004DC FF              	   800: SELDRV        dc.b        $ff            ; drive requested by seldsk
00:000004DD 00              	   801: RESV          dc.b        0              ; reserve byte, padding
00:000004DE 0000            	   802: TRACK         dc.w        0              ; track requested by settrk
00:000004E0 0000            	   803: SECTOR        dc.w        0              ; max sector value is 0x3FF
00:000004E2 00000000        	   804: DMA           dc.l        0
00:000004E6 00              	   805: SELCODE       dc.b        0              ; reserve byte
00:000004E7 00              	   806: RESV1         dc.b        0              ; reserve byte, padding
                            	   807: 
                            	   808: ; memory table must start on an even address
                            	   809:               align 2
00:000004E8 0001            	   810: MEMRGN        dc.w        1              ; 1 memory region
00:000004EA 00020000        	   811:               dc.l        $20000         ; after the CP/M 
00:000004EE 000A0000        	   812: 			  dc.l        $A0000         ; 524K bytes, more than enough for bootstrapping  
                            	   813: 
                            	   814: ; Drive mapping; 0xFFFFFFFF means mapped to Ram disk, 0 not present otherwise records
                            	   815: ; the sector of the logical file on the FAT32 SD Card
                            	   816: ; Max of 16 disks 
                            	   817: CPMDISK:
00:000004F2 00000000        	   818:     ds.l      17,0                       ; 16 drives plus one slot for "CPMDISK.IMG" which gets mapped to one of the ot
00:000004F6 *
                            	   819: RAMDRIVE:
00:00000536 00              	   820:     dc.b      0                          ; mappimg for RAM disk
00:00000537 00              	   821:     dc.b      0                          ; padding
                            	   822: 
                            	   823: ; disk parameter header - 4mb disk on sd card
                            	   824: ; set this up for 16 disks .. DPB and DIRBUF can be reused, ALV cannot ..
                            	   825: DPH0:  
00:00000538 00000000        	   826:     dc.l      0                          ; no sector translation table
00:0000053C 0000            	   827:     dc.w      0                          ; dummy
00:0000053E 0000            	   828:     dc.w      0
00:00000540 0000            	   829:     dc.w      0
00:00000542 00000714        	   830:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000546 000006D8        	   831:     dc.l      DPB0                       ; ptr to disk parameter block
00:0000054A 00000000        	   832:     dc.l      0                          ; permanent drive, no check vector
00:0000054E 00000794        	   833:     dc.l      ALV0                       ; ptr to allocation vector
                            	   834: 
00:00000552 00000000        	   835:     dc.l      0                          ; no sector translation table
00:00000556 0000            	   836:     dc.w      0                          ; dummy
00:00000558 0000            	   837:     dc.w      0
00:0000055A 0000            	   838:     dc.w      0
00:0000055C 00000714        	   839:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000560 000006D8        	   840:     dc.l      DPB0                       ; ptr to disk parameter block
00:00000564 00000000        	   841:     dc.l      0                          ; permanent drive, no check vector
00:00000568 00000894        	   842:     dc.l      ALV1                       ; ptr to allocation vector
                            	   843: 
00:0000056C 00000000        	   844:     dc.l      0                          ; no sector translation table
00:00000570 0000            	   845:     dc.w      0                          ; dummy
00:00000572 0000            	   846:     dc.w      0
00:00000574 0000            	   847:     dc.w      0
00:00000576 00000714        	   848:     dc.l      DIRBUF                     ; ptr to directory buffer
00:0000057A 000006D8        	   849:     dc.l      DPB0                       ; ptr to disk parameter block
00:0000057E 00000000        	   850:     dc.l      0                          ; permanent drive, no check vector
00:00000582 00000994        	   851:     dc.l      ALV2                       ; ptr to allocation vector
                            	   852: 
00:00000586 00000000        	   853:     dc.l      0                          ; no sector translation table
00:0000058A 0000            	   854:     dc.w      0                          ; dummy
00:0000058C 0000            	   855:     dc.w      0
00:0000058E 0000            	   856:     dc.w      0
00:00000590 00000714        	   857:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000594 000006D8        	   858:     dc.l      DPB0                       ; ptr to disk parameter block
00:00000598 00000000        	   859:     dc.l      0                          ; permanent drive, no check vector
00:0000059C 00000A94        	   860:     dc.l      ALV3                       ; ptr to allocation vector
                            	   861: 
00:000005A0 00000000        	   862:     dc.l      0                          ; no sector translation table
00:000005A4 0000            	   863:     dc.w      0                          ; dummy
00:000005A6 0000            	   864:     dc.w      0
00:000005A8 0000            	   865:     dc.w      0
00:000005AA 00000714        	   866:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000005AE 000006D8        	   867:     dc.l      DPB0                       ; ptr to disk parameter block
00:000005B2 00000000        	   868:     dc.l      0                          ; permanent drive, no check vector
00:000005B6 00000B94        	   869:     dc.l      ALV4                       ; ptr to allocation vector
                            	   870: 
00:000005BA 00000000        	   871:     dc.l      0                          ; no sector translation table
00:000005BE 0000            	   872:     dc.w      0                          ; dummy
00:000005C0 0000            	   873:     dc.w      0
00:000005C2 0000            	   874:     dc.w      0
00:000005C4 00000714        	   875:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000005C8 000006D8        	   876:     dc.l      DPB0                       ; ptr to disk parameter block
00:000005CC 00000000        	   877:     dc.l      0                          ; permanent drive, no check vector
00:000005D0 00000C94        	   878:     dc.l      ALV5                       ; ptr to allocation vector
                            	   879: 
00:000005D4 00000000        	   880:     dc.l      0                          ; no sector translation table
00:000005D8 0000            	   881:     dc.w      0                          ; dummy
00:000005DA 0000            	   882:     dc.w      0
00:000005DC 0000            	   883:     dc.w      0
00:000005DE 00000714        	   884:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000005E2 000006D8        	   885:     dc.l      DPB0                       ; ptr to disk parameter block
00:000005E6 00000000        	   886:     dc.l      0                          ; permanent drive, no check vector
00:000005EA 00000D94        	   887:     dc.l      ALV6                       ; ptr to allocation vector
                            	   888: 
00:000005EE 00000000        	   889:     dc.l      0                          ; no sector translation table
00:000005F2 0000            	   890:     dc.w      0                          ; dummy
00:000005F4 0000            	   891:     dc.w      0
00:000005F6 0000            	   892:     dc.w      0
00:000005F8 00000714        	   893:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000005FC 000006D8        	   894:     dc.l      DPB0                       ; ptr to disk parameter block
00:00000600 00000000        	   895:     dc.l      0                          ; permanent drive, no check vector
00:00000604 00000E94        	   896:     dc.l      ALV7                       ; ptr to allocation vector
                            	   897: 
00:00000608 00000000        	   898:     dc.l      0                          ; no sector translation table
00:0000060C 0000            	   899:     dc.w      0                          ; dummy
00:0000060E 0000            	   900:     dc.w      0
00:00000610 0000            	   901:     dc.w      0
00:00000612 00000714        	   902:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000616 000006D8        	   903:     dc.l      DPB0                       ; ptr to disk parameter block
00:0000061A 00000000        	   904:     dc.l      0                          ; permanent drive, no check vector
00:0000061E 00000F94        	   905:     dc.l      ALV8                       ; ptr to allocation vector
                            	   906: 
00:00000622 00000000        	   907:     dc.l      0                          ; no sector translation table
00:00000626 0000            	   908:     dc.w      0                          ; dummy
00:00000628 0000            	   909:     dc.w      0
00:0000062A 0000            	   910:     dc.w      0
00:0000062C 00000714        	   911:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000630 000006D8        	   912:     dc.l      DPB0                       ; ptr to disk parameter block
00:00000634 00000000        	   913:     dc.l      0                          ; permanent drive, no check vector
00:00000638 00001094        	   914:     dc.l      ALV9                       ; ptr to allocation vector
                            	   915: 
00:0000063C 00000000        	   916:     dc.l      0                          ; no sector translation table
00:00000640 0000            	   917:     dc.w      0                          ; dummy
00:00000642 0000            	   918:     dc.w      0
00:00000644 0000            	   919:     dc.w      0
00:00000646 00000714        	   920:     dc.l      DIRBUF                     ; ptr to directory buffer
00:0000064A 000006D8        	   921:     dc.l      DPB0                       ; ptr to disk parameter block
00:0000064E 00000000        	   922:     dc.l      0                          ; permanent drive, no check vector
00:00000652 00001194        	   923:     dc.l      ALV10                      ; ptr to allocation vector
                            	   924: 
00:00000656 00000000        	   925:     dc.l      0                          ; no sector translation table
00:0000065A 0000            	   926:     dc.w      0                          ; dummy
00:0000065C 0000            	   927:     dc.w      0
00:0000065E 0000            	   928:     dc.w      0
00:00000660 00000714        	   929:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000664 000006D8        	   930:     dc.l      DPB0                       ; ptr to disk parameter block
00:00000668 00000000        	   931:     dc.l      0                          ; permanent drive, no check vector
00:0000066C 00001294        	   932:     dc.l      ALV11                      ; ptr to allocation vector
                            	   933: 
00:00000670 00000000        	   934:     dc.l      0                          ; no sector translation table
00:00000674 0000            	   935:     dc.w      0                          ; dummy
00:00000676 0000            	   936:     dc.w      0
00:00000678 0000            	   937:     dc.w      0
00:0000067A 00000714        	   938:     dc.l      DIRBUF                     ; ptr to directory buffer
00:0000067E 000006D8        	   939:     dc.l      DPB0                       ; ptr to disk parameter block
00:00000682 00000000        	   940:     dc.l      0                          ; permanent drive, no check vector
00:00000686 00001394        	   941:     dc.l      ALV12                      ; ptr to allocation vector
                            	   942: 
00:0000068A 00000000        	   943:     dc.l      0                          ; no sector translation table
00:0000068E 0000            	   944:     dc.w      0                          ; dummy
00:00000690 0000            	   945:     dc.w      0
00:00000692 0000            	   946:     dc.w      0
00:00000694 00000714        	   947:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000698 000006D8        	   948:     dc.l      DPB0                       ; ptr to disk parameter block
00:0000069C 00000000        	   949:     dc.l      0                          ; permanent drive, no check vector
00:000006A0 00001494        	   950:     dc.l      ALV13                      ; ptr to allocation vector
                            	   951: 
00:000006A4 00000000        	   952:     dc.l      0                          ; no sector translation table
00:000006A8 0000            	   953:     dc.w      0                          ; dummy
00:000006AA 0000            	   954:     dc.w      0
00:000006AC 0000            	   955:     dc.w      0
00:000006AE 00000714        	   956:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000006B2 000006D8        	   957:     dc.l      DPB0                       ; ptr to disk parameter block
00:000006B6 00000000        	   958:     dc.l      0                          ; permanent drive, no check vector
00:000006BA 00001594        	   959:     dc.l      ALV14                      ; ptr to allocation vector
                            	   960: 
00:000006BE 00000000        	   961:     dc.l      0                          ; no sector translation table
00:000006C2 0000            	   962:     dc.w      0                          ; dummy
00:000006C4 0000            	   963:     dc.w      0
00:000006C6 0000            	   964:     dc.w      0
00:000006C8 00000714        	   965:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000006CC 000006D8        	   966:     dc.l      DPB0                       ; ptr to disk parameter block
00:000006D0 00000000        	   967:     dc.l      0                          ; permanent drive, no check vector
00:000006D4 00001694        	   968:     dc.l      ALV15                      ; ptr to allocation vector
                            	   969: 
                            	   970: 
                            	   971: DPB0:    
00:000006D8 0020            	   972:     dc.w     32                          ; 32 sectors per track
00:000006DA 04              	   973:     dc.b     4                           ; block shift for BLS of 2048
00:000006DB 0F              	   974:     dc.b     15                          ; block mask for BLS of 2048
00:000006DC 00              	   975:     dc.b     0                           ; extent mask, EXM
00:000006DD 00              	   976:     dc.b     0                           ; dummy fill
00:000006DE 07FF            	   977:     dc.w     2047                        ; DSM, (1024 tracks * 32 sectors * 128 bytes /2048)-1
                            	   978:                            
00:000006E0 00FF            	   979:     dc.w     255                         ; DRM, 256 directory entries
00:000006E2 0000            	   980:     dc.w     0                           ; directory mask
00:000006E4 0000            	   981:     dc.w     0                           ; permanent mounted drive, check size is zero
00:000006E6 0000            	   982:     dc.w     0                           ; no track offset
                            	   983: 
                            	   984: 
                            	   985: ; disk parameter header - 128k ram disk 
                            	   986: DPH1:    
00:000006E8 00000000        	   987:     dc.l      0                          ; no sector translation table
00:000006EC 0000            	   988:     dc.w      0                          ; dummy
00:000006EE 0000            	   989:     dc.w      0
00:000006F0 0000            	   990:     dc.w      0
00:000006F2 00000714        	   991:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000006F6 00000702        	   992:     dc.l      DPB1                       ; ptr to disk parameter block
00:000006FA 00000000        	   993:     dc.l      0                          ; permanent drive, no check vector
00:000006FE 00001794        	   994:     dc.l      ALV16                      ; ptr to allocation vector
                            	   995: 
                            	   996: DPB1:    
00:00000702 0020            	   997:     dc.w     32                          ; 32 sectors per track
00:00000704 04              	   998:     dc.b     4                           ; block shift for BLS of 2048
00:00000705 0F              	   999:     dc.b     15                          ; block mask for BLS of 2048
00:00000706 00              	  1000:     dc.b     0                           ; extent mask, EXM
00:00000707 00              	  1001:     dc.b     0                           ; dummy fill
00:00000708 003F            	  1002:     dc.w     63                          ; DSM, (32 tracks * 32 sectors * 128 bytes /2048)-1
                            	  1003:                            
00:0000070A 00FF            	  1004:     dc.w     255                         ; DRM, 256 directory entries
00:0000070C 0000            	  1005:     dc.w     0                           ; directory mask
00:0000070E 0000            	  1006:     dc.w     0                           ; permanent mounted drive, check size is zero
00:00000710 0000            	  1007:     dc.w     0                           ; no track offset
                            	  1008: 
                            	  1009: 
                            	  1010:     align 2
                            	  1011: DIRBUF:    
00:00000714 00              	  1012:     ds.b     128                         ; directory buffer
00:00000715 *
                            	  1013: 
                            	  1014: ALV0:    
00:00000794 00              	  1015: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000795 *
                            	  1016: 
                            	  1017: ALV1:    
00:00000894 00              	  1018: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000895 *
                            	  1019: 
                            	  1020: ALV2:    
00:00000994 00              	  1021: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000995 *
                            	  1022: 
                            	  1023: ALV3:    
00:00000A94 00              	  1024: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000A95 *
                            	  1025: 
                            	  1026: ALV4:    
00:00000B94 00              	  1027: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000B95 *
                            	  1028: 
                            	  1029: ALV5:    
00:00000C94 00              	  1030: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000C95 *
                            	  1031: 
                            	  1032: ALV6:    
00:00000D94 00              	  1033: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000D95 *
                            	  1034: 
                            	  1035: ALV7:    
00:00000E94 00              	  1036: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000E95 *
                            	  1037: 
                            	  1038: ALV8:    
00:00000F94 00              	  1039: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000F95 *
                            	  1040: 
                            	  1041: ALV9:    
00:00001094 00              	  1042: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00001095 *
                            	  1043: 
                            	  1044: ALV10:    
00:00001194 00              	  1045: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00001195 *
                            	  1046: 
                            	  1047: ALV11:    
00:00001294 00              	  1048: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00001295 *
                            	  1049: 
                            	  1050: ALV12:    
00:00001394 00              	  1051: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00001395 *
                            	  1052: 
                            	  1053: ALV13:    
00:00001494 00              	  1054: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00001495 *
                            	  1055: 
                            	  1056: ALV14:    
00:00001594 00              	  1057: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00001595 *
                            	  1058: 
                            	  1059: ALV15:    
00:00001694 00              	  1060: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00001695 *
                            	  1061: 
                            	  1062: ALV16:    
00:00001794 00              	  1063: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00001795 *
                            	  1064: 
                            	  1065: sdBuf:    
00:00001894 00              	  1066: 	ds.b     512                         ; buffer to read/write sectors to sd card
00:00001895 *
                            	  1067: 
                            	  1068: sd:
00:00001A94 00              	  1069:     ds.b     64                          ; needs to be large enough to hold a sd card structure
00:00001A95 *
                            	  1070: 
                            	  1071: partStartSector:                         ; starting sector for partition 0 on the disk
00:00001AD4 00000000        	  1072:     dc.l     0
                            	  1073: 
                            	  1074: rootDirectoryCluster:                    ; cluster of root directory - usually 2
00:00001AD8 00000000        	  1075:     dc.l     0
                            	  1076: 
                            	  1077: rootDirectorySector:                     ; sector where root directory starts on sd card
00:00001ADC 0000            	  1078:     dc.w     0
                            	  1079: 
                            	  1080: reservedSectors:                         ; sector where FAT table starts on sd card
00:00001ADE 0000            	  1081:     dc.w     0
                            	  1082: 
                            	  1083: sectorsPerCluster:                       ; sectors per cluster in word format
00:00001AE0 0000            	  1084:     dc.w     0
                            	  1085: 
                            	  1086: CPMImageSector:                          ; sector number of CPM image for the current disk
00:00001AE2 00000000        	  1087:     dc.l     0
                            	  1088: 
                            	  1089: lastFATSector:                           ; last FAT sector read (contents should be in sdBuf)
00:00001AE6 FFFFFFFF        	  1090:     dc.l     -1
                            	  1091: 
                            	  1092: imageName:
00:00001AEA 43504D4449534B20	  1093:     dc.b     "CPMDISK IMG",0             ; Nameof CPM image file on SD card
00:00001AF2 494D47
00:00001AF5 00
                            	  1094: 
                            	  1095: msgNoSdCardSupport:
00:00001AF6 6572726F723A204E	  1096:     dc.b     "error: No SD card support detected",0
00:00001AFE 6F20534420636172
00:00001B06 6420737570706F72
00:00001B0E 7420646574656374
00:00001B16 6564
00:00001B18 00
                            	  1097: 
                            	  1098: msgNoSdCardInit:
00:00001B19 6572726F723A2055	  1099:     dc.b     "error: Unable to initialize SD card",0
00:00001B21 6E61626C6520746F
00:00001B29 20696E697469616C
00:00001B31 697A652053442063
00:00001B39 617264
00:00001B3C 00
                            	  1100: 
                            	  1101: msgNoSdCardReadMBR:
00:00001B3D 6572726F723A2055	  1102:     dc.b     "error: Unable to read SD card MBR",0
00:00001B45 6E61626C6520746F
00:00001B4D 2072656164205344
00:00001B55 2063617264204D42
00:00001B5D 52
00:00001B5E 00
                            	  1103: 
                            	  1104: msgNoSdCardRead:
00:00001B5F 6572726F723A2055	  1105:     dc.b     "error: Unable to read SD card",0
00:00001B67 6E61626C6520746F
00:00001B6F 2072656164205344
00:00001B77 2063617264
00:00001B7C 00
                            	  1106: 
                            	  1107: msgNoSdCardWrite:
00:00001B7D 6572726F723A2055	  1108:     dc.b     "error: Unable to write SD card",0
00:00001B85 6E61626C6520746F
00:00001B8D 2077726974652053
00:00001B95 442063617264
00:00001B9B 00
                            	  1109: 
                            	  1110: msgNoCPMImage:
00:00001B9C 6572726F723A2043	  1111:     dc.b     "error: Cannot find CPMDISK.IMG in root directory of partition 0 on SD card",0
00:00001BA4 616E6E6F74206669
00:00001BAC 6E642043504D4449
00:00001BB4 534B2E494D472069
00:00001BBC 6E20726F6F742064
00:00001BC4 69726563746F7279
00:00001BCC 206F662070617274
00:00001BD4 6974696F6E203020
00:00001BDC 6F6E205344206361
00:00001BE4 7264
00:00001BE6 00
                            	  1112: msgMapCPMDrive:
00:00001BE7 4D61707065642043	  1113:     dc.b     "Mapped CPMDISK.IMG to "
00:00001BEF 504D4449534B2E49
00:00001BF7 4D4720746F20
                            	  1114: msgMapCPMDriveLetter:
00:00001BFD 513A            	  1115:     dc.b     "Q:",0
00:00001BFF 00
                            	  1116: msgMapRAMDrive:
00:00001C00 4D61707065642052	  1117:     dc.b     "Mapped RAM drive to "
00:00001C08 414D206472697665
00:00001C10 20746F20
                            	  1118: msgMapRAMDriveLetter:
00:00001C14 513A            	  1119:     dc.b     "Q:",0
00:00001C16 00
                            	  1120: msgMapDrive:
00:00001C17 4D61707065642043	  1121:     dc.b     "Mapped CPMDISK"
00:00001C1F 504D4449534B
                            	  1122: msgMapDriveSource:
00:00001C25 512E494D4720746F	  1123:     dc.b     "Q.IMG to "
00:00001C2D 20
                            	  1124: msgMapDriveLetter:
00:00001C2E 513A            	  1125:     dc.b     "Q:",0
00:00001C30 00


Symbols by name:
ALV0                            00:00000794
ALV1                            00:00000894
ALV10                           00:00001194
ALV11                           00:00001294
ALV12                           00:00001394
ALV13                           00:00001494
ALV14                           00:00001594
ALV15                           00:00001694
ALV16                           00:00001794
ALV2                            00:00000994
ALV3                            00:00000A94
ALV4                            00:00000B94
ALV5                            00:00000C94
ALV6                            00:00000D94
ALV7                            00:00000E94
ALV8                            00:00000F94
ALV9                            00:00001094
BIOSBASE                        00:00000294
CONIN                           00:00000300
CONOUT                          00:0000030E
CONSTAT                         00:000002F6
CPMDISK                         00:000004F2
CPMImageSector                  00:00001AE2
DEBUG                            S:00000000
DIRBUF                          00:00000714
DMA                             00:000004E2
DPB0                            00:000006D8
DPB1                            00:00000702
DPH0                            00:00000538
DPH1                            00:000006E8
FLUSH                           00:000004A6
GETIOB                          00:00000314
GETSEG                          00:000004AA
HOME                            00:0000031E
LISTST                          00:00000318
LSTOUT                          00:00000314
MEMRGN                          00:000004E8
MISSING                         00:00000390
NOSET                           00:000004D8
PUN                             00:00000314
RAMDRIVE                        00:00000536
RDR                             00:00000314
READ                            00:00000392
RESV                            00:000004DD
RESV1                           00:000004E7
SECTOR                          00:000004E0
SECTRAN                         00:00000384
SELCODE                         00:000004E6
SELDRV                          00:000004DC
SELDSK                          00:00000326
SETDMA                          00:00000388
SETEXC                          00:000004B2
SETIOB                          00:00000314
SETSEC                          00:0000037C
SETTRK                          00:00000374
TRACK                           00:000004DE
TRAPHNDL                        00:00000284
TRAPNG                          00:00000292
WBOOT                           00:000002F0
WRITE                           00:0000044E
_ccp                             E:000150BC
_init                           00:00000000 EXP
imageName                       00:00001AEA
lastFATSector                   00:00001AE6
msgMapCPMDrive                  00:00001BE7
msgMapCPMDriveLetter            00:00001BFD
msgMapDrive                     00:00001C17
msgMapDriveLetter               00:00001C2E
msgMapDriveSource               00:00001C25
msgMapRAMDrive                  00:00001C00
msgMapRAMDriveLetter            00:00001C14
msgNoCPMImage                   00:00001B9C
msgNoSdCardInit                 00:00001B19
msgNoSdCardRead                 00:00001B5F
msgNoSdCardReadMBR              00:00001B3D
msgNoSdCardSupport              00:00001AF6
msgNoSdCardWrite                00:00001B7D
partStartSector                 00:00001AD4
ramDriveLocation                 E:000C0000
reservedSectors                 00:00001ADE
rootDirectoryCluster            00:00001AD8
rootDirectorySector             00:00001ADC
sd                              00:00001A94
sdBuf                           00:00001894
sectorsPerCluster               00:00001AE0
setupReadDisk                   00:000003E0
setupReadRAM                    00:000003C0

Symbols by value:
00000000 _init
00000000 DEBUG
00000284 TRAPHNDL
00000292 TRAPNG
00000294 BIOSBASE
000002F0 WBOOT
000002F6 CONSTAT
00000300 CONIN
0000030E CONOUT
00000314 RDR
00000314 SETIOB
00000314 GETIOB
00000314 LSTOUT
00000314 PUN
00000318 LISTST
0000031E HOME
00000326 SELDSK
00000374 SETTRK
0000037C SETSEC
00000384 SECTRAN
00000388 SETDMA
00000390 MISSING
00000392 READ
000003C0 setupReadRAM
000003E0 setupReadDisk
0000044E WRITE
000004A6 FLUSH
000004AA GETSEG
000004B2 SETEXC
000004D8 NOSET
000004DC SELDRV
000004DD RESV
000004DE TRACK
000004E0 SECTOR
000004E2 DMA
000004E6 SELCODE
000004E7 RESV1
000004E8 MEMRGN
000004F2 CPMDISK
00000536 RAMDRIVE
00000538 DPH0
000006D8 DPB0
000006E8 DPH1
00000702 DPB1
00000714 DIRBUF
00000794 ALV0
00000894 ALV1
00000994 ALV2
00000A94 ALV3
00000B94 ALV4
00000C94 ALV5
00000D94 ALV6
00000E94 ALV7
00000F94 ALV8
00001094 ALV9
00001194 ALV10
00001294 ALV11
00001394 ALV12
00001494 ALV13
00001594 ALV14
00001694 ALV15
00001794 ALV16
00001894 sdBuf
00001A94 sd
00001AD4 partStartSector
00001AD8 rootDirectoryCluster
00001ADC rootDirectorySector
00001ADE reservedSectors
00001AE0 sectorsPerCluster
00001AE2 CPMImageSector
00001AE6 lastFATSector
00001AEA imageName
00001AF6 msgNoSdCardSupport
00001B19 msgNoSdCardInit
00001B3D msgNoSdCardReadMBR
00001B5F msgNoSdCardRead
00001B7D msgNoSdCardWrite
00001B9C msgNoCPMImage
00001BE7 msgMapCPMDrive
00001BFD msgMapCPMDriveLetter
00001C00 msgMapRAMDrive
00001C14 msgMapRAMDriveLetter
00001C17 msgMapDrive
00001C25 msgMapDriveSource
00001C2E msgMapDriveLetter
000150BC _ccp
000C0000 ramDriveLocation
