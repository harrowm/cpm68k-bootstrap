Sections:
00: "CODE" (0-1B73)


Source: "bios.asm"
                            	     1: ; Very simple cpm68k bios
                            	     2: ; Malcolm Harrow August 2023
                            	     3: 
                            	     4: _ccp               equ $150BC                           ; hard location for _ccp of CPM15000.SR
                            	     5: ramDriveLocation   equ $C0000                           ; memory location for RAM drive
                            	     6: DEBUG              set 0                                ; set to 1 to print debug messgae, 0 turns off  
                            	     7: 
                            	     8: ; pass in a character to this routine and print it out
                            	     9: ; use to track progress through the code in debug ..
                            	    10: debugPrintChar MACRO
                            	    11:     IFNE DEBUG
                            	    12:         movem.l D0-D3/A0-A3,-(A7)
                            	    13: 
                            	    14:         moveq.l #6,D0                                   
                            	    15:         move.b  #\1,D1                                     
                            	    16:         trap    #15
                            	    17:     
                            	    18:         movem.l (A7)+,D0-D3/A0-A3
                            	    19:     ENDIF
                            	    20: ENDM
                            	    21: 
                            	    22: ; print sector information read from / written to a SD disk image (or real SD card)
                            	    23: ; pass in a character to this routine to specify type of operation on the sector eg 'R' or 'W'
                            	    24: debugPrintSector MACRO
                            	    25:     IFNE DEBUG
                            	    26:         movem.l D0-D3/A0-A3,-(A7)
                            	    27: 
                            	    28:         moveq.l #6,D0                                   
                            	    29:         move.b  #\1,D1                                     
                            	    30:         trap    #15
                            	    31:     
                            	    32:         moveq.l #15,D0
                            	    33:         move.l  (lastFATSector),D1                          ; sector in hex
                            	    34:         move.b  #16,D2
                            	    35:         trap    #15
                            	    36: 
                            	    37:         moveq.l #6,D0
                            	    38:         move.b  #'-',D1                                    
                            	    39:         trap    #15
                            	    40: 
                            	    41:         moveq.l #15,D0
                            	    42:         move.l  D3,D1                                       ; offset on sector in hex
                            	    43:         move.b  #16,D2
                            	    44:         trap    #15
                            	    45: 
                            	    46:         moveq.l #6,D0
                            	    47:         move.b  #' ',D1                                     
                            	    48:         trap    #15
                            	    49: 
                            	    50:         movem.l (A7)+,D0-D3/A0-A3
                            	    51:     ENDIF
                            	    52: ENDM
                            	    53: 
                            	    54: ; print sector information read from / written to a RAM disk
                            	    55: ; pass in a character to this routine to specify type of operation on the RAM drive eg 'R' or 'W'
                            	    56: ; Assuem A0 is already set up to point to the RAM being moved
                            	    57: debugPrintRAM MACRO
                            	    58:     IFNE DEBUG
                            	    59:         movem.l D0-D3/A0-A3,-(A7)
                            	    60: 
                            	    61:         exg     A0,A3                                       ; save A0 as trap 15 trashes it
                            	    62:         moveq.l #6,D0                                   
                            	    63:         move.b  #\1,D1                                     
                            	    64:         trap    #15
                            	    65:         exg     A3,A0
                            	    66: 
                            	    67:         moveq.l #15,D0
                            	    68:         move.l  A0,D1                                       ; address in hex
                            	    69:         move.b  #16,D2
                            	    70:         trap    #15
                            	    71: 
                            	    72:         moveq.l #6,D0
                            	    73:         move.b  #'-',D1                                     
                            	    74:         trap    #15
                            	    75: 
                            	    76:         moveq.l #15,D0
                            	    77:         move.l  (DMA),D1                          ; sector in hex
                            	    78:         move.b  #16,D2
                            	    79:         trap    #15
                            	    80: 
                            	    81:         moveq.l #6,D0
                            	    82:         move.b  #' ',D1                                     
                            	    83:         trap    #15
                            	    84: 
                            	    85:         movem.l (A7)+,D0-D3/A0-A3
                            	    86:     ENDIF
                            	    87: ENDM
                            	    88: 
                            	    89: _init::    
                            	    90:     ; at this stage, we have loaded from the SDCARD, so we know its valid, no need to re-init
                            	    91:     ; need to find the starting sector of the CPM disk image on the sd card.
                            	    92:     ; To do this we will trawl through the FAT32 boot record etc
                            	    93: 
                            	    94:     ; to do this:
                            	    95:     ;   - read the MBR, block 0 and note:
                            	    96:     ;     - number of reserved sectors, 0x0E, word (eg 20 00)
                            	    97:     ;     - logical sectors per FAT, 0x24, long  (eg f1 03 00 00)
                            	    98:     ;     - number of fats, 0x10, byte (eg 02)
                            	    99:     ;   - This enables us to calculate:
                            	   100:     ;     - start of FAT table (sector after number of reserved sectors - 32 or 0x4000
                            	   101:     ;     - start of root directory,  Logical sectors per FAT (0x24) * Number of FATs (0x10) + Reserved logical sectors
                            	   102:     ;   - The root directory is arranged 32 bytes per entry.  We will assume our CPM disk image is in the root and call
                            	   103:     
                            	   104:     ; check sd card support
00:00000000 7000            	   105:     moveq.l #0,D0
00:00000002 4E4D            	   106:     trap    #13
00:00000004 B0BC1234FEDC    	   107:     cmp.l   #$1234FEDC,D0                               ; check magic return
00:0000000A 6708            	   108:     beq     .haveSDsupport
00:0000000C 41FA1A4C        	   109:     lea     msgNoSdCardSupport,A0
00:00000010 6000018A        	   110:     jmp     .errExit
                            	   111:     
                            	   112: .haveSDsupport:
                            	   113:     ; init the sd card and get sd card structure back
00:00000014 43FA19E2        	   114:     lea     sd,A1
00:00000018 7001            	   115:     moveq.l #1,D0                                       
00:0000001A 4E4D            	   116:     trap    #13
00:0000001C 4A80            	   117:     cmp.l   #0,D0                                       ; check return
00:0000001E 6708            	   118:     beq     .haveSDinit
00:00000020 41FA1A5B        	   119:     lea     msgNoSdCardInit,A0
00:00000024 60000176        	   120:     jmp     .errExit
                            	   121: 
                            	   122: .haveSDinit:
                            	   123:     ; read the MBR from sector 0 on the disk so we can read the partition table
00:00000028 43FA19CE        	   124:     lea     sd,A1
00:0000002C 7002            	   125:     moveq.l #2,D0                                       ; read the MBR from the sd card 
00:0000002E 7200            	   126:     moveq.l #0,D1                                       ; sector number to read
00:00000030 45FA17C6        	   127:     lea     sdBuf,A2
00:00000034 4E4D            	   128:     trap    #13
00:00000036 4A80            	   129:     cmp.l   #0,D0                                       ; check return
00:00000038 6608            	   130:     bne     .haveReadDiskMBR
00:0000003A 41FA1A65        	   131:     lea     msgNoSdCardRead,A0
00:0000003E 6000015C        	   132:     jmp     .errExit
                            	   133: 
                            	   134: .haveReadDiskMBR:
                            	   135:     ; now we need to check the disk MBR for a partition table and get the offset to the first partition
                            	   136:     ; this is a bodge .. CPM has to be on the first partition, partiton 0 and 0x1BE on the disk MBR
                            	   137:     ; The code should really check all 4 partitions ..
                            	   138: 
                            	   139:     ; as we read longs and words off of the MBR we have to take endianess into account and switch the byte order 
                            	   140:     ; as we are on the 68000 CPU
00:00000042 2C3A197A        	   141:     move.l  $1c6+sdBuf,D6                               ; read LBA start from partition 0
00:00000046 E15E            	   142:     rol.w   #8,D6
00:00000048 4846            	   143:     swap    D6
00:0000004A E15E            	   144:     rol.w   #8,D6
00:0000004C 23C600001A38    	   145:     move.l  D6,partStartSector
                            	   146: 
                            	   147:     ; read the MBR from sector 0 of the partition so we can calculate position of the root diectory and hence the CPM i
00:00000052 43FA19A4        	   148:     lea     sd,A1
00:00000056 7002            	   149:     moveq.l #2,D0                                       ; read the MBR from the sd card 
00:00000058 2206            	   150:     move.l  D6,D1                                       ; sector number to read - partStartSector
00:0000005A 45FA179C        	   151:     lea     sdBuf,A2
00:0000005E 4E4D            	   152:     trap    #13
00:00000060 4A80            	   153:     cmp.l   #0,D0                                       ; check return
00:00000062 6608            	   154:     bne     .haveReadPartMBR
00:00000064 41FA1A3B        	   155:     lea     msgNoSdCardRead,A0
00:00000068 60000132        	   156:     jmp     .errExit
                            	   157: 
                            	   158: .haveReadPartMBR
                            	   159: 
00:0000006C 3C3A1798        	   160:     move.w  $e+sdBuf,D6                                 ; number of reserved sectors from MBR.  Reversed due to endiane
00:00000070 E15E            	   161:     rol.w   #8,D6
00:00000072 33C600001A42    	   162:     move.w  D6,reservedSectors
                            	   163: 
00:00000078 2C3A17AA        	   164:     move.l  $2c+sdBuf,D6                                ; read root director cluster (usually 2)
00:0000007C E15E            	   165:     rol.w   #8,D6
00:0000007E 4846            	   166:     swap    D6
00:00000080 E15E            	   167:     rol.w   #8,D6
00:00000082 23C600001A3C    	   168:     move.l  D6,rootDirectoryCluster
                            	   169: 
                            	   170:     ; up until the root directory, we use sectors; after the root directory we have to deal with clusters (groups of se
                            	   171:     ; see the diagram here: https://eric-lo.gitbook.io/lab9-filesystem/overview-of-fat32#
                            	   172:     ; we need to store the number of sectors per cluster for later use
00:00000088 7C00            	   173:     moveq.l #0,D6
00:0000008A 1C3A1779        	   174:     move.b  $d+sdBuf,D6                                 ; read number of sectors per cluster
00:0000008E 33C600001A44    	   175:     move.w  D6,sectorsPerCluster                        ; save as a word for later mulu
                            	   176: 
                            	   177:     ; Calculate the sector of the root directory: 
                            	   178:     ; = sectors per FAT * number of FATs + number of reserved sectors
                            	   179:     ; += partStartSector to allow for the start of the partition on the disk
00:00000094 2A3A1786        	   180:     move.l  $24+sdBuf,D5                                ; read sectors per FAT
00:00000098 E15D            	   181:     rol.w   #8,D5
00:0000009A 4845            	   182:     swap    D5
00:0000009C E15D            	   183:     rol.w   #8,D5
                            	   184:     
00:0000009E 7C00            	   185:     moveq.l #0,D6                                       ; read number of FAT tables
00:000000A0 1C3A1766        	   186:     move.b  $10+sdBuf,D6
                            	   187: 
00:000000A4 CCC5            	   188:     mulu.w  D5,D6
00:000000A6 DC7A199A        	   189:     add.w   reservedSectors,D6
00:000000AA DCBA198C        	   190:     add.l   partStartSector,D6                          ; partStartSector is a long
00:000000AE 33C600001A40    	   191:     move.w  D6,rootDirectorySector
                            	   192: 
                            	   193: 
                            	   194: ;    sector = sector of start of root directory
                            	   195: ;    entry = 0
                            	   196: ;    while (1) {
                            	   197: ;      offset = entry % 16
                            	   198: ;      if offset == 0 {
                            	   199: ;        // read next sector
                            	   200: ;        read next sector
                            	   201: ;        increment sector
                            	   202: ;      };;
                            	   203: ;
                            	   204: ;      directory_entry = offset * 32 plus buffer start
                            	   205: ;
                            	   206: ;      if directory_entry[0] == 0 { // end of root directory
                            	   207: ;        message failure
                            	   208: ;        return failure
                            	   209: ;      }
                            	   210: ;
                            	   211: ;      if directory_entry[0xb] & 0x10 { // subdirectory
                            	   212: ;        continue
                            	   213: ;      }
                            	   214: ;
                            	   215: ;      if directory entry[0xb] == 0xf { // record contains a long file name
                            	   216: ;        continue
                            	   217: ;      }
                            	   218: ;
                            	   219: ;      if strncmp(directory entry, "CPMDISK IMG", 11) {
                            	   220: ;        // found file, might have to ignore case here, lets see
                            	   221: ;        // record sector file starts and file length
                            	   222: ;        block = entry[20,21] << 16 + entry[26,27]
                            	   223: ;        // both of these are store lsb first eg length of 0x7e84 is stored 84 7e 00 00
                            	   224: ;        return success
                            	   225: ;      }
                            	   226: ;      entry++
                            	   227: ;    }
                            	   228: 
                            	   229: 
                            	   230:     ; search the FAT to try to find the CPM disk image
00:000000B4 7600            	   231:     moveq.l #0,D3                                       ; sector to read
00:000000B6 7800            	   232:     moveq.l #0,D4                                       ; directory entry in sector.  Sector is 512b, directory table i
                            	   233: 
                            	   234: .startDirectoryEntry:
00:000000B8 2A04            	   235:     move.l  D4,D5
00:000000BA CABC0000000F    	   236:     and.l   #15,D5                                      ; only look at last 4 bits, we want to calculate (directory ent
00:000000C0 6622            	   237:     bne     .noReadRequired                             ; we dont need to read a new sector from the sd card
                            	   238: 
                            	   239:     ; read the MBR from sector 0 so we can calculate position of the MBR and root diectory in the CPM image
00:000000C2 43FA1934        	   240:     lea     sd,A1
00:000000C6 7002            	   241:     moveq.l #2,D0                                       ; read sector trap
00:000000C8 323A1976        	   242:     move.w  rootDirectorySector,D1
00:000000CC D243            	   243:     add.w   D3,D1                                       ; sector number to read plus offset to rootDirectoryCluster
00:000000CE 45FA1728        	   244:     lea     sdBuf,A2
00:000000D2 4E4D            	   245:     trap    #13
00:000000D4 4A80            	   246:     cmp.l   #0,D0                                       ; check return
00:000000D6 6608            	   247:     bne     .noReadError
00:000000D8 41FA19C7        	   248:     lea     msgNoSdCardRead,A0
00:000000DC 600000BE        	   249:     jmp     .errExit
                            	   250: 
                            	   251: .noReadError:
00:000000E0 5283            	   252:     addq.l  #1,D3                                       ; increment next sector to read
00:000000E2 7800            	   253:     moveq.l #0,D4                                       ; reset directory entry to zero 
                            	   254: 
                            	   255: .noReadRequired:
00:000000E4 2A04            	   256:     move.l  D4,D5                                       ; D4 contains directory record
00:000000E6 EB8D            	   257:     lsl.l   #5,D5                                       ; multiply offset by 32 to get to start of directory record
00:000000E8 DABC000017F8    	   258:     add.l   #sdBuf,D5
00:000000EE 2A45            	   259:     movea.l D5,A5
00:000000F0 1C15            	   260:     move.b  (A5),D6
00:000000F2 4A06            	   261:     tst.b   D6                                          ; reached end of root directory entries
00:000000F4 670000AE        	   262:     beq     .dirEnd
                            	   263: 
                            	   264: .notDirEnd:
00:000000F8 1C2D000B        	   265:     move.b  $b(A5),D6
00:000000FC BC3C0010        	   266:     cmp.b   #$10,D6
00:00000100 67000094        	   267:     beq     .nextDir                                    ; skip subdirectories entries
00:00000104 BC3C000F        	   268:     cmp.b   #$f,D6
00:00000108 6700008C        	   269:     beq     .nextDir                                    ; skip long filename entries
                            	   270: 
                            	   271:     ; check to see if we have found the CPM Image file
                            	   272:     ; Check that name starts "CPMD"
00:0000010C 49FA1940        	   273:     LEA     imageName,A4
00:00000110 BB8C            	   274:     cmp.l   (A4)+,(A5)+
00:00000112 66000082        	   275:     bne     .nextDir
                            	   276: 
                            	   277:     ; Check that the name ends in "IMG*"    
00:00000116 584C            	   278:     addq    #4,A4
00:00000118 584D            	   279:     addq    #4,A5
00:0000011A 2C15            	   280:     move.l  (A5),D6                                      ; wipe last byte from FAT to compare to 0 from imageName
00:0000011C 4206            	   281:     clr.b   D6
00:0000011E BC94            	   282:     cmp.l   (A4),D6
00:00000120 6674            	   283:     bne     .nextDir
                            	   284: 
                            	   285:     ; Now look at the middle "ISK*"
                            	   286:     ; The * can be a space or A..P
00:00000122 594C            	   287:     subq    #4,A4
00:00000124 594D            	   288:     subq    #4,A5
                            	   289: 
00:00000126 2A14            	   290:     move.l  (A4),D5                                      ; save last characters
00:00000128 2C1D            	   291:     move.l  (A5)+,D6                                     ; increment A5 so that its aligned for below                  
00:0000012A 1A06            	   292:     move.b  D6,D5                                        ; make last byte the same
00:0000012C BC85            	   293:     cmp.l   D5,D6                                        ; Check that "ISK" is the same
00:0000012E 6666            	   294:     bne     .nextDir
                            	   295: 
00:00000130 CCBC000000FF    	   296:     and.l   #$FF,D6                                      ; clear top 3 bytes
                            	   297:     ; Now left to check last character
00:00000136 BC3C0020        	   298:     cmp.b   #' ',D6                                      ; CMPDISK.IMG found
00:0000013A 670E            	   299:     beq     .foundCMPDISK
                            	   300: 
                            	   301: .checkdriveletter
00:0000013C 9C3C0041        	   302:     sub.b   #'A',D6
00:00000140 6B06            	   303:     bmi     .notvaliddrive
00:00000142 BC3C000F        	   304:     cmp.b   #15,D6
00:00000146 6F06            	   305:     ble     .validdrive
                            	   306:  
                            	   307: .notvaliddrive
                            	   308:     ; MESSAGE IGNOREING
00:00000148 664C            	   309:     bne     .nextDir
                            	   310: 
                            	   311: .foundCMPDISK
                            	   312:     ; change D6 to 16 (one past end of CPMDRIVE table) and fall through
00:0000014A 1C3C0010        	   313:     move.b  #16,D6
                            	   314:    
                            	   315: .validdrive
                            	   316:     ; found file, A5 will now be pointing at entry[8] so adjust offsets to compensate
                            	   317:     ;        block = entry[20,21] << 16 + entry[26,27]
                            	   318:     ; get starting block of CPMDISK.IMG
00:0000014E 3A2D000C        	   319:     move.w  $c(A5),D5                                   
00:00000152 E15D            	   320:     rol.w   #8,D5
00:00000154 4845            	   321:     swap    D5
00:00000156 3A2D0012        	   322:     move.w  $12(A5),D5
00:0000015A E15D            	   323:     rol.w   #8,D5
                            	   324: 
00:0000015C 9ABA18DE        	   325:     sub.l   (rootDirectoryCluster),D5                   ; allow for the position of the root directory (usually 2)
00:00000160 CAFA18E2        	   326:     mulu.w  (sectorsPerCluster),D5  
                            	   327: 
                            	   328:     ; for efficiency we will point CPMImageSector at the actual block on the sd card
00:00000164 DA7A18DA        	   329:     add.w   (rootDirectorySector),D5
                            	   330: 
00:00000168 1406            	   331:     move.b  D6,D2                                       ; Save for printing drive later
                            	   332: 
00:0000016A 41FA02EA        	   333:     lea     CPMDISK,A0
00:0000016E DC06            	   334:     add.b   D6,D6
00:00000170 DC06            	   335:     add.b   D6,D6
00:00000172 D1C6            	   336:     add.l   D6,A0
00:00000174 2085            	   337:     move.l  D5,(A0)
                            	   338: 
                            	   339:     ; Print out a message about the mapping (if not CPMDISK.IMG, this printed later after other drives assigned)
                            	   340:     ; HACK sort this out msgMapDriveSource
                            	   341: 
00:00000176 B43C0010        	   342:     cmp.b   #16,D2                                      ; Skip over CPMDISK.IMG 
00:0000017A 671A            	   343:     beq     .nextDir
                            	   344: 
00:0000017C 123C0041        	   345:     move.b  #'A',D1                                      
00:00000180 D202            	   346:     add.b   D2,D1
00:00000182 13C100001B70    	   347:     move.b  D1,msgMapDriveLetter
00:00000188 13C100001B67    	   348:     move.b  D1,msgMapDriveSource
00:0000018E 41FA19C9        	   349:     lea     msgMapDrive,A0
00:00000192 7201            	   350:     moveq   #1,D1
00:00000194 4E4E            	   351:     trap    #14 
                            	   352: 
                            	   353: .nextDir:
00:00000196 5284            	   354:     addq.l  #1,D4                                       ; look at next directory entry
00:00000198 6000FF1E        	   355:     bra     .startDirectoryEntry
                            	   356: 
                            	   357: .errExit:
00:0000019C 7201            	   358:     moveq.l #1,D1                                       ; Func code is 1 PRINTLN, A0 preloaded with address of error me
00:0000019E 4E4E            	   359:     trap    #14                          
00:000001A0 7001            	   360:     moveq.l #1,D0                                       ; signal error
00:000001A2 4E75            	   361:     rts
                            	   362: 
                            	   363: 
                            	   364:     ; So now we have read the whole directory and need to do some tidy up:
                            	   365:     ;   if we have found "CPMDISK.IMG" then we need to place this in the table if possible 
                            	   366:     ;   we need to try to place the RAMDISK in the mapping table
                            	   367:     ; Why have CPMDISK.IMG ? TO me most people will only want one disk .. and this is the best name :o
                            	   368: 
                            	   369: .dirEnd
00:000001A4 43FA02B0        	   370:     lea     CPMDISK,A1
00:000001A8 223A02EC        	   371:     move.l  (CPMDISK+64),D1                             ; "CPMDISK.IMG" sector if found stored at 17th entry in table
00:000001AC 760F            	   372:     moveq   #15,D3                                      ; looping variable, 16=max number of drives, -1 for dbra
                            	   373: .nextdiskmap
00:000001AE 4A91            	   374:     tst.l   (A1)
00:000001B0 661C            	   375:     bne     .continue                                   ; not an empty slot, try to loop around
                            	   376: 
00:000001B2 4A01            	   377:     tst.b   D1                                          ; see if we need to map CPMDISK.IMG
00:000001B4 6720            	   378:     beq     .sortoutramdrive
00:000001B6 2281            	   379:     move.l  D1,(A1)
                            	   380: 
                            	   381:     ; format drive letter for message
00:000001B8 123C0050        	   382:     move.b  #'A'+15,D1                                      
00:000001BC 9203            	   383:     sub.b   D3,D1
00:000001BE 13C100001B3F    	   384:     move.b  D1,msgMapCPMDriveLetter
00:000001C4 41FA1963        	   385:     lea     msgMapCPMDrive,A0
00:000001C8 7201            	   386:     moveq   #1,D1
00:000001CA 4E4E            	   387:     trap    #14 
                            	   388: 
00:000001CC 7200            	   389:     moveq   #0,D1                                       ; note that CPMDISK.IMG now mapped
                            	   390:     
                            	   391: .continue
00:000001CE 5849            	   392:     addq    #4,A1    
00:000001D0 51CBFFDC        	   393:     dbra    D3,.nextdiskmap
                            	   394: 
                            	   395:     ; Need to check is we failed to map CPMDRIVE.IMG and RAMDRIVE and message
00:000001D4 601C            	   396:     bra     .finish
                            	   397: 
                            	   398: .sortoutramdrive
00:000001D6 720F            	   399:     moveq   #15,D1                                      ; reuse D1
00:000001D8 9203            	   400:     sub.b   D3,D1
00:000001DA 13C10000049A    	   401:     move.b  D1,RAMDRIVE                                 ; now that we fix up RAMDRIVE we are done, so can fall out of l
                            	   402: 
                            	   403:     ; message RAM drive mapping
00:000001E0 D23C0041        	   404:     add.b   #'A',D1
00:000001E4 13C100001B56    	   405:     move.b  D1,msgMapRAMDriveLetter
00:000001EA 41FA1956        	   406:     lea     msgMapRAMDrive,A0
00:000001EE 7201            	   407:     moveq   #1,D1
00:000001F0 4E4E            	   408:     trap    #14 
                            	   409: 
                            	   410: .finish
00:000001F2 21FC000001FE008C	   411:     move.l  #TRAPHNDL,$8c                               ; set up trap #3 handler
00:000001FA 7000            	   412:     moveq.l #0,D0                                       ; log on disk A, user 0
00:000001FC 4E75            	   413:     rts
                            	   414: 
                            	   415: TRAPHNDL:
00:000001FE 0C400017        	   416:     cmpi    #23,D0                                      ; Function call in range ?
00:00000202 6408            	   417:     bcc     TRAPNG
                            	   418: 
00:00000204 E588            	   419:     lsl.l   #2,D0                                       ; change function call to offset by multiplting by 4
00:00000206 207B0006        	   420:     move.l  BIOSBASE(PC,D0),A0          ; ... and calc offset into table...
00:0000020A 4E90            	   421:     jsr     (A0)                        ; ... then jump there
                            	   422: 
                            	   423: TRAPNG:
00:0000020C 4E73            	   424:     rte
                            	   425: 
                            	   426: BIOSBASE:
00:0000020E 00000000        	   427:     dc.l    _init
00:00000212 0000026A        	   428:     dc.l    WBOOT
00:00000216 00000270        	   429:     dc.l    CONSTAT
00:0000021A 0000027A        	   430:     dc.l    CONIN
00:0000021E 00000288        	   431:     dc.l    CONOUT
00:00000222 0000028E        	   432:     dc.l    LSTOUT
00:00000226 0000028E        	   433:     dc.l    PUN
00:0000022A 0000028E        	   434:     dc.l    RDR
00:0000022E 00000298        	   435:     dc.l    HOME
00:00000232 000002A0        	   436:     dc.l    SELDSK
00:00000236 000002E8        	   437:     dc.l    SETTRK
00:0000023A 000002F0        	   438:     dc.l    SETSEC
00:0000023E 000002FC        	   439:     dc.l    SETDMA
00:00000242 00000306        	   440:     dc.l    READ
00:00000246 000003BA        	   441:     dc.l    WRITE
00:0000024A 00000292        	   442:     dc.l    LISTST
00:0000024E 000002F8        	   443:     dc.l    SECTRAN
00:00000252 00000304        	   444:     dc.l    MISSING
00:00000256 0000040E        	   445:     dc.l    GETSEG
00:0000025A 0000028E        	   446:     dc.l    GETIOB
00:0000025E 0000028E        	   447:     dc.l    SETIOB
00:00000262 0000040A        	   448:     dc.l    FLUSH
00:00000266 00000416        	   449:     dc.l    SETEXC
                            	   450: 
                            	   451: 
                            	   452: WBOOT:  
00:0000026A 4EF9000150BC    	   453:     jmp     _ccp
                            	   454: 
                            	   455: CONSTAT: 
                            	   456: ; Check for keyboard input. Set d0 to 1 if keyboard input is pending, otherwise set to 0.
00:00000270 7007            	   457:     moveq.l #7,D0                        ; use EASy68k trap 15 task 7
00:00000272 4E4F            	   458:     trap    #15                          ; d1.b = 1 if keyboard ready, otherwise = 0
00:00000274 7000            	   459:     moveq.l #0,D0
00:00000276 1001            	   460:     move.b  D1,D0
00:00000278 4E75            	   461:     rts
                            	   462: 
                            	   463: CONIN:    
                            	   464: ; Read single ASCII character from the keyboard into d0
                            	   465: ; Rosco implementation of this trap waits for input
00:0000027A 7005            	   466:     moveq.l #5,D0                        ; use EASy68k trap 15 task 5
00:0000027C 4E4F            	   467:     trap    #15                          ; d1.b contains the ascii character
00:0000027E 1001            	   468:     move.b  D1,D0      
00:00000280 C0BC0000007F    	   469:     and.l   #$7f,D0                      ; only use 7 bit character set
00:00000286 4E75            	   470:     rts
                            	   471: 
                            	   472: CONOUT: 
                            	   473: ; Display single ASCII character in d1
00:00000288 7006            	   474:     moveq.l #6,D0                        ; use EASy68k trap 15 task 6
00:0000028A 4E4F            	   475:     trap    #15
00:0000028C 4E75            	   476:     rts                                  ; and exit
                            	   477: 
                            	   478: LSTOUT:    
                            	   479: PUN:
                            	   480: RDR:
                            	   481: GETIOB:
                            	   482: SETIOB:
00:0000028E 7000            	   483:     moveq.l #0,D0
00:00000290 4E75            	   484:     rts
                            	   485: 
                            	   486: LISTST:    
00:00000292 103C00FF        	   487:     move.b #$ff,D0
00:00000296 4E75            	   488:     rts
                            	   489: 
                            	   490: HOME:    
00:00000298 427900000442    	   491:     clr.w  TRACK
00:0000029E 4E75            	   492:     rts
                            	   493: 
                            	   494: SELDSK:    
                            	   495: ; drive should be in d1.b
                            	   496: ; now trashes A0
00:000002A0 B23A01F8        	   497:     cmp.b   (RAMDRIVE),D1
00:000002A4 6730            	   498:     beq     .selram
                            	   499: 
00:000002A6 B23C000F        	   500:     cmp.b   #15,D1                  ; 16 max drives for cpm68k
00:000002AA 6E38            	   501:     bgt     .seldsk_error           ; .. return without changing anything
                            	   502: 
00:000002AC 7000            	   503:     moveq   #0,D0
00:000002AE 1001            	   504:     move.b  D1,D0                   ; save for later
                            	   505: 
00:000002B0 D201            	   506:     add.b   D1,D1                   ; Multiply D1 by 4 to change to address
00:000002B2 D201            	   507:     add.b   D1,D1
00:000002B4 41FA01A0        	   508:     lea     CPMDISK,A0
00:000002B8 22301800        	   509:     move.l  (0,A0,D1.L),D1            ; move sector for the requested disk to D1
                            	   510:     
00:000002BC 6726            	   511:     beq     .seldsk_error           ; zero so no disk mapped to this slot
                            	   512: 
00:000002BE 23C100001A46    	   513:     move.l  D1,(CPMImageSector)     ; set up FAT32 sector for disk image for read/write routine
                            	   514:                                     
00:000002C4 13C000000440    	   515:     move.b  D0,SELDRV               ; set up selected drive
00:000002CA C0FC001A        	   516:     mulu    #26,D0                  ; 26 is the size of the DPH 
00:000002CE 41FA01CC        	   517:     lea     DPH0,A0
00:000002D2 D088            	   518:     add.l   A0,D0                   ; return D0 pointing to the right DPH
00:000002D4 4E75            	   519:     rts
                            	   520: 
                            	   521: .selram
00:000002D6 13C100000440    	   522:     move.b  D1,SELDRV
00:000002DC 203C0000064C    	   523:     move.l  #DPH1,D0
00:000002E2 4E75            	   524:     rts
                            	   525:     
                            	   526: .seldsk_error
00:000002E4 7000            	   527:     moveq   #0,D0                   ; Signal error
00:000002E6 4E75            	   528:     rts
                            	   529: 
                            	   530: SETTRK:    
00:000002E8 33C100000442    	   531:     move.w  D1,TRACK
00:000002EE 4E75            	   532:     rts
                            	   533: 
                            	   534: SETSEC:    
00:000002F0 33C100000444    	   535:     move.w  D1,SECTOR
00:000002F6 4E75            	   536:     rts
                            	   537: 
                            	   538: SECTRAN:
                            	   539: ;    no sector translate, put d1 into d0 and return
00:000002F8 3001            	   540:     move.w  D1,D0
00:000002FA 4E75            	   541:     rts
                            	   542: 
                            	   543: SETDMA:
00:000002FC 23C100000446    	   544:     move.l  D1,DMA
00:00000302 4E75            	   545:     rts
                            	   546: 
                            	   547: MISSING:
                            	   548:     ; this number is missing from the table in the
                            	   549:     ; CPM 68k documentation, doesn't seem to be ever called
00:00000304 4E75            	   550:     rts
                            	   551: 
                            	   552: READ:
                            	   553: ; Read one cpm sector from requested disk, track, sector to dma address
                            	   554: ; Can be a cpmimage on the sd card or the ram disk
                            	   555:     ;cmp.b   #0,SELDRV
                            	   556:     ;bne     .readRAMDrive
00:00000306 103A0192        	   557:     move.b  (RAMDRIVE),D0
00:0000030A B03A0134        	   558:     cmp.b   SELDRV,D0
00:0000030E 6712            	   559:     beq     .readRAMDrive
                            	   560: 
00:00000310 6142            	   561:     bsr     setupReadDisk                               ; sets A0 to point to the right 128 bytes in memory, potentiall
00:00000312 227A0132        	   562:     move.l  DMA,A1
00:00000316 701F            	   563:     move.l  #(128/4-1),D0  
                            	   564: 
                            	   565: .MOVE_LOOP1:
00:00000318 22D8            	   566:     MOVE.L  (A0)+,(A1)+                                 ; copy long word from source to dest
00:0000031A 51C8FFFC        	   567:     dbra    D0,.MOVE_LOOP1
                            	   568:     
00:0000031E 7000            	   569:     moveq.l #0,D0                                       ; return OK status         
00:00000320 4E75            	   570:     rts
                            	   571: 
                            	   572: .readRAMDrive:
00:00000322 6110            	   573:     bsr     setupReadRAM                                ; sets A0 to point to the right 128 bytes in memory to read
                            	   574:     debugPrintRAM 'R'
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         exg     A0,A3                                       ; save A0 as trap 15 trashes it
                            	     5M         moveq.l #6,D0                                   
                            	     6M         move.b  #'R',D1                                     
                            	     7M         trap    #15
                            	     8M         exg     A3,A0
                            	     9M 
                            	    10M         moveq.l #15,D0
                            	    11M         move.l  A0,D1                                       ; address in hex
                            	    12M         move.b  #16,D2
                            	    13M         trap    #15
                            	    14M 
                            	    15M         moveq.l #6,D0
                            	    16M         move.b  #'-',D1                                     
                            	    17M         trap    #15
                            	    18M 
                            	    19M         moveq.l #15,D0
                            	    20M         move.l  (DMA),D1                          ; sector in hex
                            	    21M         move.b  #16,D2
                            	    22M         trap    #15
                            	    23M 
                            	    24M         moveq.l #6,D0
                            	    25M         move.b  #' ',D1                                     
                            	    26M         trap    #15
                            	    27M 
                            	    28M         movem.l (A7)+,D0-D3/A0-A3
                            	    29M     ENDIF
00:00000324 227A0120        	   575:     move.l  DMA,A1
00:00000328 701F            	   576:     move.l  #(128/4-1),d0  
                            	   577: 
                            	   578: .MOVE_LOOP2:
00:0000032A 22D8            	   579:     MOVE.L  (A0)+,(A1)+                                 ; copy long word from source to dest
00:0000032C 51C8FFFC        	   580:     dbra    D0,.MOVE_LOOP2
                            	   581: 
00:00000330 7000            	   582:     moveq.l #0,D0                                       ; return OK status         
00:00000332 4E75            	   583:     rts         
                            	   584: 
                            	   585: setupReadRAM:
                            	   586: ; translate track/sector into RAM location on the RAM drive
00:00000334 7000            	   587:     moveq.l #0,D0
00:00000336 303A010A        	   588:     move.w  TRACK,D0
00:0000033A 760C            	   589:     moveq.l #12,D3                                      ; much faster than shifting by 8 then 4 (40 versus 12 cycles)
00:0000033C E7A8            	   590:     lsl.l   D3,D0
                            	   591: 
00:0000033E 7400            	   592:     moveq.l #0,D2
00:00000340 343A0102        	   593:     move.w  SECTOR,D2
00:00000344 7607            	   594:     moveq.l #7,D3                                       ; much faster than shifting by 7 (22 versus 12 cycles)
00:00000346 E7AA            	   595:     lsl.l   D3,D2
                            	   596: 
00:00000348 D082            	   597:     add.l   D2,D0
00:0000034A D0BC000C0000    	   598:     add.l   #ramDriveLocation,D0                        ; add base address of RAM drive
00:00000350 2040            	   599:     movea.l D0,A0                                       ; point to the track/sector in RAM drive
00:00000352 4E75            	   600:     rts
                            	   601: 
                            	   602: setupReadDisk:
                            	   603: ;
                            	   604: ; algorithm
                            	   605: ;
                            	   606: ; keep 512b in a memory buffer
                            	   607: ; keep sector number of the data currently in the buffer
                            	   608: ;
                            	   609: ; if requested sector not in buffer {
                            	   610: ;     calcuate the sector and offset that the FAT entry for the sector is located in
                            	   611: ;     read sector pointed to in FAT table from disk into buffer
                            	   612: ;     note requested sector in buffer
                            	   613: ; }
                            	   614: ;
                            	   615: ; calculate offset of CPM 128b required in 512b buffer
                            	   616: ; copy the correct 12b across into the CPM dma area
                            	   617: 
                            	   618:     ; start by calculating the requested (FAT32) sector number from TRACK and SECTOR in D0
                            	   619:     ; also calculate the offset into that 512b buffer for the 128b CPM sector data in D3
00:00000354 7200            	   620:     moveq.l #0,D1
00:00000356 323A00EA        	   621:     move.w  TRACK,D1
00:0000035A E789            	   622:     lsl.l   #3,D1
                            	   623: 
00:0000035C 7400            	   624:     moveq.l #0,D2
00:0000035E 343A00E4        	   625:     move.w  SECTOR,D2
                            	   626: 
00:00000362 2602            	   627:     move.l  D2,D3
00:00000364 C6BC00000003    	   628:     and.l   #3,D3                                       ; use D3 to calculate the offset of the 128b CPM sector in the 
00:0000036A 7807            	   629:     moveq.l #7,D4                                       ; much faster than shifting by 7 (22 versus 12 cycles)
00:0000036C E9AB            	   630:     lsl.l   D4,D3
                            	   631: 
00:0000036E E48A            	   632:     lsr.l   #2,D2
00:00000370 D282            	   633:     add.l   D2,D1                                        ; D1 now has the requested sector number
00:00000372 D2BA16D2        	   634:     add.l   (CPMImageSector),D1                          ; D1 now has the actual sector on the SD card
                            	   635: 
                            	   636:     ; check to see if this FAT32 sector already in memory
00:00000376 B2BA16D2        	   637:     cmp.l (lastFATSector),D1
00:0000037A 6736            	   638:     beq   .noDiskReadRequired
                            	   639: 
                            	   640:     ; we are going to read the sector (hopefully) so update the last read FAT sector before we lose the contents of D1
00:0000037C 23C100001A4A    	   641:     move.l D1,lastFATSector
                            	   642: 
                            	   643:     ; we assume that the FAT table is contiguous for the CP/M image
                            	   644:     ; file, this avoids a walk of the FAT table linked list .. but wont deal with any bad sectors on the sd card
                            	   645: 
00:00000382 43FA1674        	   646:     lea     sd,A1
00:00000386 7002            	   647:     moveq.l #2,D0                                        ; read sector function code
00:00000388 45FA146E        	   648:     lea     sdBuf,A2
00:0000038C 4E4D            	   649:     trap    #13
00:0000038E 4A80            	   650:     cmp.l   #0,D0                                        ; check return
00:00000390 6620            	   651:     bne     .noDiskReadError
                            	   652: 
                            	   653:     ; if we get here we had a disk read error
                            	   654:     debugPrintSector 'E'
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         moveq.l #6,D0                                   
                            	     5M         move.b  #'E',D1                                     
                            	     6M         trap    #15
                            	     7M     
                            	     8M         moveq.l #15,D0
                            	     9M         move.l  (lastFATSector),D1                          ; sector in hex
                            	    10M         move.b  #16,D2
                            	    11M         trap    #15
                            	    12M 
                            	    13M         moveq.l #6,D0
                            	    14M         move.b  #'-',D1                                    
                            	    15M         trap    #15
                            	    16M 
                            	    17M         moveq.l #15,D0
                            	    18M         move.l  D3,D1                                       ; offset on sector in hex
                            	    19M         move.b  #16,D2
                            	    20M         trap    #15
                            	    21M 
                            	    22M         moveq.l #6,D0
                            	    23M         move.b  #' ',D1                                     
                            	    24M         trap    #15
                            	    25M 
                            	    26M         movem.l (A7)+,D0-D3/A0-A3
                            	    27M     ENDIF
                            	   655:     
00:00000392 41FA170D        	   656:     lea     msgNoSdCardRead,A0
00:00000396 7201            	   657:     moveq.l #1,D1                                       ; Func code is 1 PRINTLN, A0 preloaded with address of error me
00:00000398 4E4E            	   658:     trap    #14                         
00:0000039A 7001            	   659:     moveq.l #1,D0                                       ; signal error
                            	   660: 
00:0000039C 23FCFFFFFFFF0000	   661:     move.l  #-1,lastFATSector
00:000003A4 1A4A
00:000003A6 243C000000FF    	   662:     move.l  #$ff,D2
00:000003AC 45BC0001        	   663:     chk     #1,D2                                       ; cause a trap to stop execution
00:000003B0 4E75            	   664:     rts                                                 ; should not get here .. 
                            	   665: 
                            	   666: .noDiskReadError:
                            	   667:     debugPrintSector 'R'
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         moveq.l #6,D0                                   
                            	     5M         move.b  #'R',D1                                     
                            	     6M         trap    #15
                            	     7M     
                            	     8M         moveq.l #15,D0
                            	     9M         move.l  (lastFATSector),D1                          ; sector in hex
                            	    10M         move.b  #16,D2
                            	    11M         trap    #15
                            	    12M 
                            	    13M         moveq.l #6,D0
                            	    14M         move.b  #'-',D1                                    
                            	    15M         trap    #15
                            	    16M 
                            	    17M         moveq.l #15,D0
                            	    18M         move.l  D3,D1                                       ; offset on sector in hex
                            	    19M         move.b  #16,D2
                            	    20M         trap    #15
                            	    21M 
                            	    22M         moveq.l #6,D0
                            	    23M         move.b  #' ',D1                                     
                            	    24M         trap    #15
                            	    25M 
                            	    26M         movem.l (A7)+,D0-D3/A0-A3
                            	    27M     ENDIF
                            	   668:     ;jmp    .noCachePrint
                            	   669: 
                            	   670: .noDiskReadRequired:
                            	   671:     ;debugPrintSector 'C'
                            	   672:     
                            	   673: .noCachePrint:
00:000003B2 41FA1444        	   674:     lea    sdBuf,A0
00:000003B6 D1C3            	   675:     add.l  D3,A0                                        ; add offset into 512b buffer
00:000003B8 4E75            	   676:     rts
                            	   677: 
                            	   678: WRITE:
                            	   679: ; Write one cpm sector from requested disk, track, sector to dma address
                            	   680: ; Can be a cpmimage on the sd card or the ram disk
                            	   681:     ;cmp.b   #0,SELDRV
                            	   682:     ;bne     .writeRAMDrive
00:000003BA 103A00DE        	   683:     move.b  (RAMDRIVE),D0
00:000003BE B03A0080        	   684:     cmp.b   SELDRV,D0
00:000003C2 6732            	   685:     beq     .writeRAMDrive
                            	   686: 
                            	   687: 
                            	   688:     ; going to write to disk    
00:000003C4 618E            	   689:     bsr     setupReadDisk                               ; sets A0 to point to the right 128 bytes in memory, potentiall
                            	   690:     debugPrintSector 'W'
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         moveq.l #6,D0                                   
                            	     5M         move.b  #'W',D1                                     
                            	     6M         trap    #15
                            	     7M     
                            	     8M         moveq.l #15,D0
                            	     9M         move.l  (lastFATSector),D1                          ; sector in hex
                            	    10M         move.b  #16,D2
                            	    11M         trap    #15
                            	    12M 
                            	    13M         moveq.l #6,D0
                            	    14M         move.b  #'-',D1                                    
                            	    15M         trap    #15
                            	    16M 
                            	    17M         moveq.l #15,D0
                            	    18M         move.l  D3,D1                                       ; offset on sector in hex
                            	    19M         move.b  #16,D2
                            	    20M         trap    #15
                            	    21M 
                            	    22M         moveq.l #6,D0
                            	    23M         move.b  #' ',D1                                     
                            	    24M         trap    #15
                            	    25M 
                            	    26M         movem.l (A7)+,D0-D3/A0-A3
                            	    27M     ENDIF
00:000003C6 227A007E        	   691:     move.l  DMA,A1
00:000003CA 701F            	   692:     move.l  #(128/4-1),d0  
                            	   693:     
                            	   694: .MOVE_LOOP3:
00:000003CC 20D9            	   695:     MOVE.L  (A1)+,(A0)+                                 ; copy long word from source to dest, reverse direction from re
00:000003CE 51C8FFFC        	   696:     dbra    D0,.MOVE_LOOP3
                            	   697: 
                            	   698:     ; and write out the 512b buffer to disk
00:000003D2 223A1676        	   699:     move.l  (lastFATSector),D1                          ; set up in SETUPRD
00:000003D6 43FA1620        	   700:     lea     sd,A1
00:000003DA 7003            	   701:     moveq.l #3,D0                                       ; write sector function call
00:000003DC 45FA141A        	   702:     lea     sdBuf,A2                                    ; write out sdBuf to disk
00:000003E0 4E4D            	   703:     trap    #13
00:000003E2 4A80            	   704:     cmp.l   #0,D0                                       ; check return
00:000003E4 660C            	   705:     bne     .noWriteError
00:000003E6 41FA16D7        	   706:     lea     msgNoSdCardWrite,A0
00:000003EA 7201            	   707:     moveq.l #1,D1                                       ; Func code is 1 PRINTLN, A0 preloaded with address of error me
00:000003EC 4E4E            	   708:     trap    #14                                         ; TRAP to firmware    
00:000003EE 7001            	   709:     moveq.l #1,D0                                       ; signal error
00:000003F0 4E75            	   710:     rts
                            	   711:     
                            	   712: .noWriteError:
                            	   713:     ;move.l #-1,lastFATSector
00:000003F2 7000            	   714:     moveq.l #0,D0                                       ; return success
00:000003F4 4E75            	   715:     rts                    
                            	   716: 
                            	   717: .writeRAMDrive:
00:000003F6 6100FF3C        	   718:     bsr     setupReadRAM                                ; sets A0 to point to the right 128 bytes in memory to read
                            	   719:     debugPrintRAM 'W'
                            	     1M     IFNE DEBUG
                            	     2M         movem.l D0-D3/A0-A3,-(A7)
                            	     3M 
                            	     4M         exg     A0,A3                                       ; save A0 as trap 15 trashes it
                            	     5M         moveq.l #6,D0                                   
                            	     6M         move.b  #'W',D1                                     
                            	     7M         trap    #15
                            	     8M         exg     A3,A0
                            	     9M 
                            	    10M         moveq.l #15,D0
                            	    11M         move.l  A0,D1                                       ; address in hex
                            	    12M         move.b  #16,D2
                            	    13M         trap    #15
                            	    14M 
                            	    15M         moveq.l #6,D0
                            	    16M         move.b  #'-',D1                                     
                            	    17M         trap    #15
                            	    18M 
                            	    19M         moveq.l #15,D0
                            	    20M         move.l  (DMA),D1                          ; sector in hex
                            	    21M         move.b  #16,D2
                            	    22M         trap    #15
                            	    23M 
                            	    24M         moveq.l #6,D0
                            	    25M         move.b  #' ',D1                                     
                            	    26M         trap    #15
                            	    27M 
                            	    28M         movem.l (A7)+,D0-D3/A0-A3
                            	    29M     ENDIF
00:000003FA 227A004A        	   720:     move.l  DMA,A1
00:000003FE 701F            	   721:     move.l  #(128/4-1),d0  
                            	   722: 
                            	   723: .MOVE_LOOP4:
00:00000400 20D9            	   724:     MOVE.L  (A1)+,(A0)+                                 ; copy long word from source to dest, reverse direction from re
00:00000402 51C8FFFC        	   725:     dbra    D0,.MOVE_LOOP4
                            	   726: 
00:00000406 7000            	   727:     moveq.l #0,D0
00:00000408 4E75            	   728:     rts        
                            	   729: 
                            	   730: FLUSH:
00:0000040A 7000            	   731:     moveq.l #0,D0                                       ; return successful
00:0000040C 4E75            	   732:     rts
                            	   733: 
                            	   734: GETSEG:
00:0000040E 203C0000044C    	   735:     move.l #MEMRGN,D0                                   ; return address of mem region table
00:00000414 4E75            	   736:     rts
                            	   737: 
                            	   738: SETEXC:
00:00000416 0281000000FF    	   739:     andi.l  #$ff,D1                                     ; do only for exceptions 0 - 255
                            	   740: 
00:0000041C 0C41002D        	   741:     cmpi    #45,D1
00:00000420 671A            	   742:     beq     NOSET                                       ; don't set trap 13,14,15 as used by rosco firmware
00:00000422 0C41002E        	   743:     cmpi    #46,D1
00:00000426 6714            	   744:     beq     NOSET                        
00:00000428 0C41002F        	   745:     cmpi    #47,D1
00:0000042C 670E            	   746:     beq     NOSET                       
00:0000042E 0C410009        	   747:     cmpi    #9,D1                                       ; don't set trace trap
00:00000432 6708            	   748:     beq     NOSET
00:00000434 E549            	   749:     lsl     #2,D1                                       ; multiply exception number by 4
00:00000436 2041            	   750:     movea.l D1,A0
00:00000438 2010            	   751:     move.l  (A0),D0                                     ; return old vector value
00:0000043A 2082            	   752:     move.l  D2,(A0)                                     ; insert new vector
                            	   753: 
                            	   754: NOSET:    
00:0000043C 4E75            	   755:     rts
                            	   756: 
                            	   757: * ************************************************************************** *
                            	   758: ; Data
                            	   759: * ************************************************************************** *
                            	   760: 
                            	   761:               align 2                    ; DMA must be at even address
00:00000440 FF              	   762: SELDRV        dc.b        $ff            ; drive requested by seldsk
00:00000441 00              	   763: RESV          dc.b        0              ; reserve byte, padding
00:00000442 0000            	   764: TRACK         dc.w        0              ; track requested by settrk
00:00000444 0000            	   765: SECTOR        dc.w        0              ; max sector value is 0x3FF
00:00000446 00000000        	   766: DMA           dc.l        0
00:0000044A 00              	   767: SELCODE       dc.b        0              ; reserve byte
00:0000044B 00              	   768: RESV1         dc.b        0              ; reserve byte, padding
                            	   769: 
                            	   770: ; memory table must start on an even address
                            	   771:               align 2
00:0000044C 0001            	   772: MEMRGN        dc.w        1              ; 1 memory region
00:0000044E 00020000        	   773:               dc.l        $20000         ; after the CP/M 
00:00000452 000A0000        	   774: 			  dc.l        $A0000         ; 524K bytes, more than enough for bootstrapping  
                            	   775: 
                            	   776: ; Drive mapping; 0xFFFFFFFF means mapped to Ram disk, 0 not present otherwise records
                            	   777: ; the sector of the logical file on the FAT32 SD Card
                            	   778: ; Max of 16 disks 
                            	   779: CPMDISK:
00:00000456 00000000        	   780:     ds.l      17,0                       ; 16 drives plus one slot for "CPMDISK.IMG" which gets mapped to one of the ot
00:0000045A *
                            	   781: RAMDRIVE:
00:0000049A 00              	   782:     dc.b      0                          ; mappimg for RAM disk
00:0000049B 00              	   783:     dc.b      0                          ; padding
                            	   784: 
                            	   785: ; disk parameter header - 4mb disk on sd card
                            	   786: ; set this up for 16 disks .. DPB and DIRBUF can be reused, ALV cannot ..
                            	   787: DPH0:  
00:0000049C 00000000        	   788:     dc.l      0                          ; no sector translation table
00:000004A0 0000            	   789:     dc.w      0                          ; dummy
00:000004A2 0000            	   790:     dc.w      0
00:000004A4 0000            	   791:     dc.w      0
00:000004A6 00000678        	   792:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000004AA 0000063C        	   793:     dc.l      DPB0                       ; ptr to disk parameter block
00:000004AE 00000000        	   794:     dc.l      0                          ; permanent drive, no check vector
00:000004B2 000006F8        	   795:     dc.l      ALV0                       ; ptr to allocation vector
                            	   796: 
00:000004B6 00000000        	   797:     dc.l      0                          ; no sector translation table
00:000004BA 0000            	   798:     dc.w      0                          ; dummy
00:000004BC 0000            	   799:     dc.w      0
00:000004BE 0000            	   800:     dc.w      0
00:000004C0 00000678        	   801:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000004C4 0000063C        	   802:     dc.l      DPB0                       ; ptr to disk parameter block
00:000004C8 00000000        	   803:     dc.l      0                          ; permanent drive, no check vector
00:000004CC 000007F8        	   804:     dc.l      ALV1                       ; ptr to allocation vector
                            	   805: 
00:000004D0 00000000        	   806:     dc.l      0                          ; no sector translation table
00:000004D4 0000            	   807:     dc.w      0                          ; dummy
00:000004D6 0000            	   808:     dc.w      0
00:000004D8 0000            	   809:     dc.w      0
00:000004DA 00000678        	   810:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000004DE 0000063C        	   811:     dc.l      DPB0                       ; ptr to disk parameter block
00:000004E2 00000000        	   812:     dc.l      0                          ; permanent drive, no check vector
00:000004E6 000008F8        	   813:     dc.l      ALV2                       ; ptr to allocation vector
                            	   814: 
00:000004EA 00000000        	   815:     dc.l      0                          ; no sector translation table
00:000004EE 0000            	   816:     dc.w      0                          ; dummy
00:000004F0 0000            	   817:     dc.w      0
00:000004F2 0000            	   818:     dc.w      0
00:000004F4 00000678        	   819:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000004F8 0000063C        	   820:     dc.l      DPB0                       ; ptr to disk parameter block
00:000004FC 00000000        	   821:     dc.l      0                          ; permanent drive, no check vector
00:00000500 000009F8        	   822:     dc.l      ALV3                       ; ptr to allocation vector
                            	   823: 
00:00000504 00000000        	   824:     dc.l      0                          ; no sector translation table
00:00000508 0000            	   825:     dc.w      0                          ; dummy
00:0000050A 0000            	   826:     dc.w      0
00:0000050C 0000            	   827:     dc.w      0
00:0000050E 00000678        	   828:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000512 0000063C        	   829:     dc.l      DPB0                       ; ptr to disk parameter block
00:00000516 00000000        	   830:     dc.l      0                          ; permanent drive, no check vector
00:0000051A 00000AF8        	   831:     dc.l      ALV4                       ; ptr to allocation vector
                            	   832: 
00:0000051E 00000000        	   833:     dc.l      0                          ; no sector translation table
00:00000522 0000            	   834:     dc.w      0                          ; dummy
00:00000524 0000            	   835:     dc.w      0
00:00000526 0000            	   836:     dc.w      0
00:00000528 00000678        	   837:     dc.l      DIRBUF                     ; ptr to directory buffer
00:0000052C 0000063C        	   838:     dc.l      DPB0                       ; ptr to disk parameter block
00:00000530 00000000        	   839:     dc.l      0                          ; permanent drive, no check vector
00:00000534 00000BF8        	   840:     dc.l      ALV5                       ; ptr to allocation vector
                            	   841: 
00:00000538 00000000        	   842:     dc.l      0                          ; no sector translation table
00:0000053C 0000            	   843:     dc.w      0                          ; dummy
00:0000053E 0000            	   844:     dc.w      0
00:00000540 0000            	   845:     dc.w      0
00:00000542 00000678        	   846:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000546 0000063C        	   847:     dc.l      DPB0                       ; ptr to disk parameter block
00:0000054A 00000000        	   848:     dc.l      0                          ; permanent drive, no check vector
00:0000054E 00000CF8        	   849:     dc.l      ALV6                       ; ptr to allocation vector
                            	   850: 
00:00000552 00000000        	   851:     dc.l      0                          ; no sector translation table
00:00000556 0000            	   852:     dc.w      0                          ; dummy
00:00000558 0000            	   853:     dc.w      0
00:0000055A 0000            	   854:     dc.w      0
00:0000055C 00000678        	   855:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000560 0000063C        	   856:     dc.l      DPB0                       ; ptr to disk parameter block
00:00000564 00000000        	   857:     dc.l      0                          ; permanent drive, no check vector
00:00000568 00000DF8        	   858:     dc.l      ALV7                       ; ptr to allocation vector
                            	   859: 
00:0000056C 00000000        	   860:     dc.l      0                          ; no sector translation table
00:00000570 0000            	   861:     dc.w      0                          ; dummy
00:00000572 0000            	   862:     dc.w      0
00:00000574 0000            	   863:     dc.w      0
00:00000576 00000678        	   864:     dc.l      DIRBUF                     ; ptr to directory buffer
00:0000057A 0000063C        	   865:     dc.l      DPB0                       ; ptr to disk parameter block
00:0000057E 00000000        	   866:     dc.l      0                          ; permanent drive, no check vector
00:00000582 00000EF8        	   867:     dc.l      ALV8                       ; ptr to allocation vector
                            	   868: 
00:00000586 00000000        	   869:     dc.l      0                          ; no sector translation table
00:0000058A 0000            	   870:     dc.w      0                          ; dummy
00:0000058C 0000            	   871:     dc.w      0
00:0000058E 0000            	   872:     dc.w      0
00:00000590 00000678        	   873:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000594 0000063C        	   874:     dc.l      DPB0                       ; ptr to disk parameter block
00:00000598 00000000        	   875:     dc.l      0                          ; permanent drive, no check vector
00:0000059C 00000FF8        	   876:     dc.l      ALV9                       ; ptr to allocation vector
                            	   877: 
00:000005A0 00000000        	   878:     dc.l      0                          ; no sector translation table
00:000005A4 0000            	   879:     dc.w      0                          ; dummy
00:000005A6 0000            	   880:     dc.w      0
00:000005A8 0000            	   881:     dc.w      0
00:000005AA 00000678        	   882:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000005AE 0000063C        	   883:     dc.l      DPB0                       ; ptr to disk parameter block
00:000005B2 00000000        	   884:     dc.l      0                          ; permanent drive, no check vector
00:000005B6 000010F8        	   885:     dc.l      ALV10                      ; ptr to allocation vector
                            	   886: 
00:000005BA 00000000        	   887:     dc.l      0                          ; no sector translation table
00:000005BE 0000            	   888:     dc.w      0                          ; dummy
00:000005C0 0000            	   889:     dc.w      0
00:000005C2 0000            	   890:     dc.w      0
00:000005C4 00000678        	   891:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000005C8 0000063C        	   892:     dc.l      DPB0                       ; ptr to disk parameter block
00:000005CC 00000000        	   893:     dc.l      0                          ; permanent drive, no check vector
00:000005D0 000011F8        	   894:     dc.l      ALV11                      ; ptr to allocation vector
                            	   895: 
00:000005D4 00000000        	   896:     dc.l      0                          ; no sector translation table
00:000005D8 0000            	   897:     dc.w      0                          ; dummy
00:000005DA 0000            	   898:     dc.w      0
00:000005DC 0000            	   899:     dc.w      0
00:000005DE 00000678        	   900:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000005E2 0000063C        	   901:     dc.l      DPB0                       ; ptr to disk parameter block
00:000005E6 00000000        	   902:     dc.l      0                          ; permanent drive, no check vector
00:000005EA 000012F8        	   903:     dc.l      ALV12                      ; ptr to allocation vector
                            	   904: 
00:000005EE 00000000        	   905:     dc.l      0                          ; no sector translation table
00:000005F2 0000            	   906:     dc.w      0                          ; dummy
00:000005F4 0000            	   907:     dc.w      0
00:000005F6 0000            	   908:     dc.w      0
00:000005F8 00000678        	   909:     dc.l      DIRBUF                     ; ptr to directory buffer
00:000005FC 0000063C        	   910:     dc.l      DPB0                       ; ptr to disk parameter block
00:00000600 00000000        	   911:     dc.l      0                          ; permanent drive, no check vector
00:00000604 000013F8        	   912:     dc.l      ALV13                      ; ptr to allocation vector
                            	   913: 
00:00000608 00000000        	   914:     dc.l      0                          ; no sector translation table
00:0000060C 0000            	   915:     dc.w      0                          ; dummy
00:0000060E 0000            	   916:     dc.w      0
00:00000610 0000            	   917:     dc.w      0
00:00000612 00000678        	   918:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000616 0000063C        	   919:     dc.l      DPB0                       ; ptr to disk parameter block
00:0000061A 00000000        	   920:     dc.l      0                          ; permanent drive, no check vector
00:0000061E 000014F8        	   921:     dc.l      ALV14                      ; ptr to allocation vector
                            	   922: 
00:00000622 00000000        	   923:     dc.l      0                          ; no sector translation table
00:00000626 0000            	   924:     dc.w      0                          ; dummy
00:00000628 0000            	   925:     dc.w      0
00:0000062A 0000            	   926:     dc.w      0
00:0000062C 00000678        	   927:     dc.l      DIRBUF                     ; ptr to directory buffer
00:00000630 0000063C        	   928:     dc.l      DPB0                       ; ptr to disk parameter block
00:00000634 00000000        	   929:     dc.l      0                          ; permanent drive, no check vector
00:00000638 000015F8        	   930:     dc.l      ALV15                      ; ptr to allocation vector
                            	   931: 
                            	   932: 
                            	   933: DPB0:    
00:0000063C 0020            	   934:     dc.w     32                          ; 32 sectors per track
00:0000063E 04              	   935:     dc.b     4                           ; block shift for BLS of 2048
00:0000063F 0F              	   936:     dc.b     15                          ; block mask for BLS of 2048
00:00000640 00              	   937:     dc.b     0                           ; extent mask, EXM
00:00000641 00              	   938:     dc.b     0                           ; dummy fill
00:00000642 07FF            	   939:     dc.w     2047                        ; DSM, (1024 tracks * 32 sectors * 128 bytes /2048)-1
                            	   940:                            
00:00000644 00FF            	   941:     dc.w     255                         ; DRM, 256 directory entries
00:00000646 0000            	   942:     dc.w     0                           ; directory mask
00:00000648 0000            	   943:     dc.w     0                           ; permanent mounted drive, check size is zero
00:0000064A 0000            	   944:     dc.w     0                           ; no track offset
                            	   945: 
                            	   946: 
                            	   947: ; disk parameter header - 128k ram disk 
                            	   948: DPH1:    
00:0000064C 00000000        	   949:     dc.l      0                          ; no sector translation table
00:00000650 0000            	   950:     dc.w      0                          ; dummy
00:00000652 0000            	   951:     dc.w      0
00:00000654 0000            	   952:     dc.w      0
00:00000656 00000678        	   953:     dc.l      DIRBUF                     ; ptr to directory buffer
00:0000065A 00000666        	   954:     dc.l      DPB1                       ; ptr to disk parameter block
00:0000065E 00000000        	   955:     dc.l      0                          ; permanent drive, no check vector
00:00000662 000016F8        	   956:     dc.l      ALV16                      ; ptr to allocation vector
                            	   957: 
                            	   958: DPB1:    
00:00000666 0020            	   959:     dc.w     32                          ; 32 sectors per track
00:00000668 04              	   960:     dc.b     4                           ; block shift for BLS of 2048
00:00000669 0F              	   961:     dc.b     15                          ; block mask for BLS of 2048
00:0000066A 00              	   962:     dc.b     0                           ; extent mask, EXM
00:0000066B 00              	   963:     dc.b     0                           ; dummy fill
00:0000066C 003F            	   964:     dc.w     63                          ; DSM, (32 tracks * 32 sectors * 128 bytes /2048)-1
                            	   965:                            
00:0000066E 00FF            	   966:     dc.w     255                         ; DRM, 256 directory entries
00:00000670 0000            	   967:     dc.w     0                           ; directory mask
00:00000672 0000            	   968:     dc.w     0                           ; permanent mounted drive, check size is zero
00:00000674 0000            	   969:     dc.w     0                           ; no track offset
                            	   970: 
                            	   971: 
                            	   972:     align 2
                            	   973: DIRBUF:    
00:00000678 00              	   974:     ds.b     128                         ; directory buffer
00:00000679 *
                            	   975: 
                            	   976: ALV0:    
00:000006F8 00              	   977: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000006F9 *
                            	   978: 
                            	   979: ALV1:    
00:000007F8 00              	   980: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000007F9 *
                            	   981: 
                            	   982: ALV2:    
00:000008F8 00              	   983: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000008F9 *
                            	   984: 
                            	   985: ALV3:    
00:000009F8 00              	   986: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000009F9 *
                            	   987: 
                            	   988: ALV4:    
00:00000AF8 00              	   989: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000AF9 *
                            	   990: 
                            	   991: ALV5:    
00:00000BF8 00              	   992: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000BF9 *
                            	   993: 
                            	   994: ALV6:    
00:00000CF8 00              	   995: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000CF9 *
                            	   996: 
                            	   997: ALV7:    
00:00000DF8 00              	   998: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000DF9 *
                            	   999: 
                            	  1000: ALV8:    
00:00000EF8 00              	  1001: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000EF9 *
                            	  1002: 
                            	  1003: ALV9:    
00:00000FF8 00              	  1004: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000FF9 *
                            	  1005: 
                            	  1006: ALV10:    
00:000010F8 00              	  1007: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000010F9 *
                            	  1008: 
                            	  1009: ALV11:    
00:000011F8 00              	  1010: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000011F9 *
                            	  1011: 
                            	  1012: ALV12:    
00:000012F8 00              	  1013: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000012F9 *
                            	  1014: 
                            	  1015: ALV13:    
00:000013F8 00              	  1016: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000013F9 *
                            	  1017: 
                            	  1018: ALV14:    
00:000014F8 00              	  1019: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000014F9 *
                            	  1020: 
                            	  1021: ALV15:    
00:000015F8 00              	  1022: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000015F9 *
                            	  1023: 
                            	  1024: ALV16:    
00:000016F8 00              	  1025: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:000016F9 *
                            	  1026: 
                            	  1027: sdBuf:    
00:000017F8 00              	  1028: 	ds.b     512                         ; buffer to read/write sectors to sd card
00:000017F9 *
                            	  1029: 
                            	  1030: sd:
00:000019F8 00              	  1031:     ds.b     64                          ; needs to be large enough to hold a sd card structure
00:000019F9 *
                            	  1032: 
                            	  1033: partStartSector:                         ; starting sector for partition 0 on the disk
00:00001A38 00000000        	  1034:     dc.l     0
                            	  1035: 
                            	  1036: rootDirectoryCluster:                    ; cluster of root directory - usually 2
00:00001A3C 00000000        	  1037:     dc.l     0
                            	  1038: 
                            	  1039: rootDirectorySector:                     ; sector where root directory starts on sd card
00:00001A40 0000            	  1040:     dc.w     0
                            	  1041: 
                            	  1042: reservedSectors:                         ; sector where FAT table starts on sd card
00:00001A42 0000            	  1043:     dc.w     0
                            	  1044: 
                            	  1045: sectorsPerCluster:                       ; sectors per cluster in word format
00:00001A44 0000            	  1046:     dc.w     0
                            	  1047: 
                            	  1048: CPMImageSector:                          ; sector number of CPM image for the current disk
00:00001A46 00000000        	  1049:     dc.l     0
                            	  1050: 
                            	  1051: lastFATSector:                           ; last FAT sector read (contents should be in sdBuf)
00:00001A4A FFFFFFFF        	  1052:     dc.l     -1
                            	  1053: 
                            	  1054: imageName:
00:00001A4E 43504D4449534B20	  1055:     dc.b     "CPMDISK IMG",0             ; Nameof CPM image file on SD card
00:00001A56 494D47
00:00001A59 00
                            	  1056: 
                            	  1057: msgNoSdCardSupport:
00:00001A5A 6572726F723A204E	  1058:     dc.b     "error: No SD card support detected",0
00:00001A62 6F20534420636172
00:00001A6A 6420737570706F72
00:00001A72 7420646574656374
00:00001A7A 6564
00:00001A7C 00
                            	  1059: 
                            	  1060: msgNoSdCardInit:
00:00001A7D 6572726F723A2055	  1061:     dc.b     "error: Unable to initialize SD card",0
00:00001A85 6E61626C6520746F
00:00001A8D 20696E697469616C
00:00001A95 697A652053442063
00:00001A9D 617264
00:00001AA0 00
                            	  1062: 
                            	  1063: msgNoSdCardRead:
00:00001AA1 6572726F723A2055	  1064:     dc.b     "error: Unable to read SD card",0
00:00001AA9 6E61626C6520746F
00:00001AB1 2072656164205344
00:00001AB9 2063617264
00:00001ABE 00
                            	  1065: 
                            	  1066: msgNoSdCardWrite:
00:00001ABF 6572726F723A2055	  1067:     dc.b     "error: Unable to write SD card",0
00:00001AC7 6E61626C6520746F
00:00001ACF 2077726974652053
00:00001AD7 442063617264
00:00001ADD 00
                            	  1068: 
                            	  1069: msgNoCPMImage:
00:00001ADE 6572726F723A2043	  1070:     dc.b     "error: Cannot find CPMDISK.IMG in root directory of partition 0 on SD card",0
00:00001AE6 616E6E6F74206669
00:00001AEE 6E642043504D4449
00:00001AF6 534B2E494D472069
00:00001AFE 6E20726F6F742064
00:00001B06 69726563746F7279
00:00001B0E 206F662070617274
00:00001B16 6974696F6E203020
00:00001B1E 6F6E205344206361
00:00001B26 7264
00:00001B28 00
                            	  1071: msgMapCPMDrive:
00:00001B29 4D61707065642043	  1072:     dc.b     "Mapped CPMDISK.IMG to "
00:00001B31 504D4449534B2E49
00:00001B39 4D4720746F20
                            	  1073: msgMapCPMDriveLetter:
00:00001B3F 513A            	  1074:     dc.b     "Q:",0
00:00001B41 00
                            	  1075: msgMapRAMDrive:
00:00001B42 4D61707065642052	  1076:     dc.b     "Mapped RAM drive to "
00:00001B4A 414D206472697665
00:00001B52 20746F20
                            	  1077: msgMapRAMDriveLetter:
00:00001B56 513A            	  1078:     dc.b     "Q:",0
00:00001B58 00
                            	  1079: msgMapDrive:
00:00001B59 4D61707065642043	  1080:     dc.b     "Mapped CPMDISK"
00:00001B61 504D4449534B
                            	  1081: msgMapDriveSource:
00:00001B67 512E494D4720746F	  1082:     dc.b     "Q.IMG to "
00:00001B6F 20
                            	  1083: msgMapDriveLetter:
00:00001B70 513A            	  1084:     dc.b     "Q:",0
00:00001B72 00


Symbols by name:
ALV0                            00:000006F8
ALV1                            00:000007F8
ALV10                           00:000010F8
ALV11                           00:000011F8
ALV12                           00:000012F8
ALV13                           00:000013F8
ALV14                           00:000014F8
ALV15                           00:000015F8
ALV16                           00:000016F8
ALV2                            00:000008F8
ALV3                            00:000009F8
ALV4                            00:00000AF8
ALV5                            00:00000BF8
ALV6                            00:00000CF8
ALV7                            00:00000DF8
ALV8                            00:00000EF8
ALV9                            00:00000FF8
BIOSBASE                        00:0000020E
CONIN                           00:0000027A
CONOUT                          00:00000288
CONSTAT                         00:00000270
CPMDISK                         00:00000456
CPMImageSector                  00:00001A46
DEBUG                            S:00000000
DIRBUF                          00:00000678
DMA                             00:00000446
DPB0                            00:0000063C
DPB1                            00:00000666
DPH0                            00:0000049C
DPH1                            00:0000064C
FLUSH                           00:0000040A
GETIOB                          00:0000028E
GETSEG                          00:0000040E
HOME                            00:00000298
LISTST                          00:00000292
LSTOUT                          00:0000028E
MEMRGN                          00:0000044C
MISSING                         00:00000304
NOSET                           00:0000043C
PUN                             00:0000028E
RAMDRIVE                        00:0000049A
RDR                             00:0000028E
READ                            00:00000306
RESV                            00:00000441
RESV1                           00:0000044B
SECTOR                          00:00000444
SECTRAN                         00:000002F8
SELCODE                         00:0000044A
SELDRV                          00:00000440
SELDSK                          00:000002A0
SETDMA                          00:000002FC
SETEXC                          00:00000416
SETIOB                          00:0000028E
SETSEC                          00:000002F0
SETTRK                          00:000002E8
TRACK                           00:00000442
TRAPHNDL                        00:000001FE
TRAPNG                          00:0000020C
WBOOT                           00:0000026A
WRITE                           00:000003BA
_ccp                             E:000150BC
_init                           00:00000000 EXP
imageName                       00:00001A4E
lastFATSector                   00:00001A4A
msgMapCPMDrive                  00:00001B29
msgMapCPMDriveLetter            00:00001B3F
msgMapDrive                     00:00001B59
msgMapDriveLetter               00:00001B70
msgMapDriveSource               00:00001B67
msgMapRAMDrive                  00:00001B42
msgMapRAMDriveLetter            00:00001B56
msgNoCPMImage                   00:00001ADE
msgNoSdCardInit                 00:00001A7D
msgNoSdCardRead                 00:00001AA1
msgNoSdCardSupport              00:00001A5A
msgNoSdCardWrite                00:00001ABF
partStartSector                 00:00001A38
ramDriveLocation                 E:000C0000
reservedSectors                 00:00001A42
rootDirectoryCluster            00:00001A3C
rootDirectorySector             00:00001A40
sd                              00:000019F8
sdBuf                           00:000017F8
sectorsPerCluster               00:00001A44
setupReadDisk                   00:00000354
setupReadRAM                    00:00000334

Symbols by value:
00000000 _init
00000000 DEBUG
000001FE TRAPHNDL
0000020C TRAPNG
0000020E BIOSBASE
0000026A WBOOT
00000270 CONSTAT
0000027A CONIN
00000288 CONOUT
0000028E RDR
0000028E SETIOB
0000028E GETIOB
0000028E LSTOUT
0000028E PUN
00000292 LISTST
00000298 HOME
000002A0 SELDSK
000002E8 SETTRK
000002F0 SETSEC
000002F8 SECTRAN
000002FC SETDMA
00000304 MISSING
00000306 READ
00000334 setupReadRAM
00000354 setupReadDisk
000003BA WRITE
0000040A FLUSH
0000040E GETSEG
00000416 SETEXC
0000043C NOSET
00000440 SELDRV
00000441 RESV
00000442 TRACK
00000444 SECTOR
00000446 DMA
0000044A SELCODE
0000044B RESV1
0000044C MEMRGN
00000456 CPMDISK
0000049A RAMDRIVE
0000049C DPH0
0000063C DPB0
0000064C DPH1
00000666 DPB1
00000678 DIRBUF
000006F8 ALV0
000007F8 ALV1
000008F8 ALV2
000009F8 ALV3
00000AF8 ALV4
00000BF8 ALV5
00000CF8 ALV6
00000DF8 ALV7
00000EF8 ALV8
00000FF8 ALV9
000010F8 ALV10
000011F8 ALV11
000012F8 ALV12
000013F8 ALV13
000014F8 ALV14
000015F8 ALV15
000016F8 ALV16
000017F8 sdBuf
000019F8 sd
00001A38 partStartSector
00001A3C rootDirectoryCluster
00001A40 rootDirectorySector
00001A42 reservedSectors
00001A44 sectorsPerCluster
00001A46 CPMImageSector
00001A4A lastFATSector
00001A4E imageName
00001A5A msgNoSdCardSupport
00001A7D msgNoSdCardInit
00001AA1 msgNoSdCardRead
00001ABF msgNoSdCardWrite
00001ADE msgNoCPMImage
00001B29 msgMapCPMDrive
00001B3F msgMapCPMDriveLetter
00001B42 msgMapRAMDrive
00001B56 msgMapRAMDriveLetter
00001B59 msgMapDrive
00001B67 msgMapDriveSource
00001B70 msgMapDriveLetter
000150BC _ccp
000C0000 ramDriveLocation
