Sections:
00: "CODE" (0-5D7)


Source: "bios.asm"
                            	     1: ; Very simple cpm68k bios
                            	     2: ; Malcolm Harrow August 2023
                            	     3: 
                            	     4: _ccp     equ $150BC                     ; hard location for _ccp of CPM15000.SR
                            	     5: 
                            	     6: _init::    
                            	     7: 
                            	     8:     ; at this stage, we have loaded from the SDCARD, so we know its valid, no need to re-init
                            	     9:     ; need to find the starting block of the CPM disk image on the sd card, or offset
                            	    10:     ; to do this we will trawl through the FAT32 boot record etc
                            	    11: 
                            	    12:     ; to do this:
                            	    13:     ;   - read the MBR, block 0 and note:
                            	    14:     ;     - number of reserved sectors, 0x0E, word (eg 20 00)
                            	    15:     ;     - logical sectors per FAT, 0x24, long  (eg f1 03 00 00)
                            	    16:     ;     - number of fats, 0x10, byte (eg 02)
                            	    17:     ;   - This enables us to calculate:
                            	    18:     ;     - start of FAT table (sector after number of reserved sectors - 32 or 0x4000
                            	    19:     ;     - start of root directory,  Logical sectors per FAT (0x24) * Number of FATs (0x10) + Reserved logical sectors
                            	    20:     ;   - The root directory is arranged 32 bytes per entry.  We will assume our CPM disk image is in the root and call
                            	    21:     ;   
                            	    22:     ;  
                            	    23: 
                            	    24:     ; check and initialise the sd card
00:00000000 7000            	    25:     move.l  #0,D0                                       ; check sd card support
00:00000002 4E4D            	    26:     trap    #13
00:00000004 B0BC1234FEDC    	    27:     cmp.l   #$1234FEDC,D0                              ; check magic return
00:0000000A 6706            	    28:     beq     .noerr1
00:0000000C 41FA031A        	    29:     lea     msgNoSdCardSupport,A0
00:00000010 6012            	    30:     jmp     .errExit
                            	    31:     
                            	    32: .noerr1:
00:00000012 43FA0583        	    33:      lea     sd,A1
00:00000016 7001            	    34:      move.l  #1,D0                                       ; init sd card and get sd card structure back. 
                            	    35: ;     trap    #13
                            	    36: ;.malcolm: jmp .malcolm
                            	    37: ;     cmp.l   #0,D0                                       ; check return
                            	    38: 
                            	    39: 
                            	    40: 
                            	    41: ;     beq     .noerr2
                            	    42: ;     lea     msgNoSdCardInit,A0
                            	    43: ;     jmp     .errExit
                            	    44: 
                            	    45: ;.noerr2:
                            	    46: ;    lea     sd,A1
                            	    47: ;    move.l  #2,D0                                       ; read the MBR from the sd card 
                            	    48: ;    clr.l   D1                                          ; read block 0, mbr
                            	    49: ;    lea     sdBuf,A2
                            	    50: ;    trap    #13
                            	    51: ;    bne     .noerr3
                            	    52: ;    lea     msgNoSdCardRead,A0
                            	    53: ;    jmp     .errExit
                            	    54: 
                            	    55: .noerr3:
                            	    56: 
                            	    57: 
                            	    58:     
                            	    59: ;    sector = sector of start of root directory
                            	    60: ;    entry = 0
                            	    61: ;    while (1) {
                            	    62: ;      offset = entry % 8
                            	    63: ;      if offset == 0 {
                            	    64: ;        // read next sector
                            	    65: ;        read next sector
                            	    66: ;        increment sector
                            	    67: ;      };;
                            	    68: ;
                            	    69: ;      directory_entry = offset * 32 plus buffer start
                            	    70: ;
                            	    71: ;      if directory_entry[0] == 0 { // end of root directory
                            	    72: ;        message failure
                            	    73: ;        return failure
                            	    74: ;      }
                            	    75: ;
                            	    76: ;      if directory_entry[0] == 0xE5 { // previously erased entry
                            	    77: ;        continue
                            	    78: ;      }
                            	    79: ;
                            	    80: ;      if directory_entry[0xb] & 0x10 { // subdirectory
                            	    81: ;        continue
                            	    82: ;      }
                            	    83: ;
                            	    84: ;      if directory entry[0xb] == 0xf { // record contains a long file name
                            	    85: ;        continue
                            	    86: ;      }
                            	    87: ;
                            	    88: ;      if strncmp(directory entry, "CPMDISK IMG", 11) {
                            	    89: ;        // found file, might have to ignore case here, lets see
                            	    90: ;        // record sector file starts and file length
                            	    91: ;        block = entry[20,21] << 16 + entry[26,27]
                            	    92: ;        filelength = entry[28,29,30,31]
                            	    93: ;        // both of these are store lsb first eg length of 0x7e84 is stored 84 7e 00 00
                            	    94: ;        return success
                            	    95: ;      }
                            	    96: ;      entry++
                            	    97: ;    }
                            	    98:     
00:00000018 21FC0000002C008C	    99:     move.l  #TRAPHNDL,$8c               ; set up trap #3 handler
00:00000020 7000            	   100:     clr.l   D0                          ; log on disk A, user 0
00:00000022 4E75            	   101:     rts
                            	   102: 
                            	   103: .errExit:
00:00000024 7201            	   104:     move.l  #1,D1                       ; Func code is 1 PRINTLN, A0 preloaded with address of error message
00:00000026 4E4E            	   105:     trap    #14                         ; TRAP to firmware
00:00000028 7001            	   106:     move.l  #1,D0                       ; signal error
00:0000002A 4E75            	   107: g    rts
                            	   108: 
                            	   109: TRAPHNDL:
00:0000002C 0C400017        	   110:     cmpi    #23,D0                      ; Function call in range ?
00:00000030 640A            	   111:     bcc     TRAPNG
                            	   112: 
                            	   113:  ;   move.l  D0,D5
                            	   114:  ;   move.l  D1,D6
                            	   115:  ;   and.l   #$ffff,D0
                            	   116:  ;   add.b   #65,D0
                            	   117:  ;   move.l  D0,D1
                            	   118:  ;   clr.l   D0
                            	   119:  ;   jsr     CONOUT
                            	   120:  ;   move.l  D5,D0
                            	   121:  ;   move.l  D6,D1
                            	   122:     
                            	   123: 
00:00000032 D080            	   124:     add.l   D0,D0                       ; Multiply FC...
00:00000034 D080            	   125:     add.l   D0,D0                       ; ... by 4...
00:00000036 207B0006        	   126:     move.l  BIOSBASE(PC,D0),A0          ; ... and calc offset into table...
00:0000003A 4E90            	   127:     jsr     (A0)                        ; ... then jump there
                            	   128: 
                            	   129: TRAPNG:
00:0000003C 4E73            	   130:     rte
                            	   131: 
                            	   132: BIOSBASE:
00:0000003E 00000000        	   133:     dc.l    _init
00:00000042 0000009A        	   134:     dc.l    WBOOT
00:00000046 000000A0        	   135:     dc.l    CONSTAT
00:0000004A 000000AA        	   136:     dc.l    CONIN
00:0000004E 000000B8        	   137:     dc.l    CONOUT
00:00000052 000000BE        	   138:     dc.l    LSTOUT
00:00000056 000000BE        	   139:     dc.l    PUN
00:0000005A 000000BE        	   140:     dc.l    RDR
00:0000005E 000000C8        	   141:     dc.l    HOME
00:00000062 000000D0        	   142:     dc.l    SELDSK
00:00000066 000000DE        	   143:     dc.l    SETTRK
00:0000006A 000000E6        	   144:     dc.l    SETSEC
00:0000006E 000000F2        	   145:     dc.l    SETDMA
00:00000072 000000FA        	   146:     dc.l    READ
00:00000076 0000012C        	   147:     dc.l    WRITE
00:0000007A 000000C2        	   148:     dc.l    LISTST
00:0000007E 000000EE        	   149:     dc.l    SECTRAN
00:00000082 000000F2        	   150:     dc.l    SETDMA
00:00000086 00000140        	   151:     dc.l    GETSEG
00:0000008A 000000BE        	   152:     dc.l    GETIOB
00:0000008E 000000BE        	   153:     dc.l    SETIOB
00:00000092 0000013C        	   154:     dc.l    FLUSH
00:00000096 00000148        	   155:     dc.l    SETEXC
                            	   156: 
                            	   157: 
                            	   158: WBOOT:  
00:0000009A 4EF9000150BC    	   159:     jmp   _ccp
                            	   160: 
                            	   161: CONSTAT: 
                            	   162: ; Check for keyboard input. Set d0 to 1 if keyboard input is pending, otherwise set to 0.
00:000000A0 7007            	   163:     move.l #7,D0                        ; use EASy68k trap 15 task 7
00:000000A2 4E4F            	   164:     trap   #15                          ; d1.b = 1 if keyboard ready, otherwise = 0
00:000000A4 7000            	   165:     clr.l  D0
00:000000A6 1001            	   166:     move.b D1,D0
00:000000A8 4E75            	   167:     rts
                            	   168:          
                            	   169: CONIN:    
                            	   170: ; Read single ASCII character from the keyboard into d0
                            	   171: ; Rosco implementation of this trap waits for input
00:000000AA 7005            	   172:     move.l #5,D0                        ; use EASy68k trap 15 task 5
00:000000AC 4E4F            	   173:     trap   #15                          ; d1.b contains the ascii character
00:000000AE 1001            	   174:     move.b D1,D0      
00:000000B0 C0BC0000007F    	   175:     and.l  #$7f,D0                      ; only use 7 bit character set
00:000000B6 4E75            	   176:     rts
                            	   177: 
                            	   178: CONOUT: 
                            	   179: ; Display single ASCII character in d1
00:000000B8 7006            	   180:     move.l #6,D0                        ; use EASy68k trap 15 task 6
00:000000BA 4E4F            	   181:     trap   #15
00:000000BC 4E75            	   182:     rts                                 ; and exit
                            	   183: 
                            	   184: LSTOUT:    
                            	   185: PUN:
                            	   186: RDR:
                            	   187: GETIOB:
                            	   188: SETIOB:
00:000000BE 7000            	   189:     clr.l  D0                            ; HACK ?
00:000000C0 4E75            	   190:     rts
                            	   191: 
                            	   192: LISTST:    
00:000000C2 103C00FF        	   193:     move.b #$ff,D0
00:000000C6 4E75            	   194:     rts
                            	   195: 
                            	   196: HOME:    
00:000000C8 42790000016A    	   197:     clr.w  TRACK
00:000000CE 4E75            	   198:     rts
                            	   199: 
                            	   200: SELDSK:    
                            	   201: ; always assume one drive
00:000000D0 423900000164    	   202:     move.b  #0,SELDRV
00:000000D6 203C0000017E    	   203:     move.l  #DPH0,D0
00:000000DC 4E75            	   204:     rts
                            	   205: 
                            	   206: SETTRK:    
00:000000DE 33C10000016A    	   207:     move.w  D1,TRACK
                            	   208: 
                            	   209: 
                            	   210:     ;clr.l   D1
                            	   211:     ;move.w  TRACK,D1
                            	   212:     ;add.l   #97,D1
                            	   213:     ;clr.l   D0
                            	   214:     ;jsr     CONOUT
                            	   215: 
00:000000E4 4E75            	   216:     rts
                            	   217: 
                            	   218: SETSEC:    
00:000000E6 33C10000016C    	   219:     move.w  D1,SECTOR
                            	   220: 
                            	   221:     ;clr.l   D1
                            	   222:     ;move.w  SECTOR,D1
                            	   223:     ;add.l   #97,D1
                            	   224:     ;clr.l   D0
                            	   225:     ;jsr     CONOUT
                            	   226: 
00:000000EC 4E75            	   227:     rts
                            	   228: 
                            	   229: SECTRAN:
                            	   230: ;    no sector translate, put d1 into d0 and return
00:000000EE 3001            	   231:     move.w  D1,D0
00:000000F0 4E75            	   232:     rts
                            	   233: 
                            	   234: SETDMA:
00:000000F2 23C10000016E    	   235:     move.l  D1,DMA
00:000000F8 4E75            	   236:     rts
                            	   237: 
                            	   238: READ:
                            	   239: ; Read one sector from requested disk, track, sector to dma address
                            	   240: ; One small drive possible as loaded at 0x2000 and CPM starts at 0x15000
                            	   241: ; This gives a max ram disk size of ~77k
                            	   242: 
00:000000FA 610A            	   243:     bsr     SETUPRD                      ; translate track/sector values into RAM loc
                            	   244: RAMDRVR:
00:000000FC 22D8            	   245:     move.l (A0)+,(A1)+
00:000000FE 51CAFFFC        	   246:     dbra   D2,RAMDRVR
                            	   247: 
00:00000102 7000            	   248:     clr.l  D0                            ; return OK status         
00:00000104 4E75            	   249:     rts         
                            	   250: 
                            	   251: SETUPRD:
                            	   252: ; translate track/sector into RAM location on the RAM drive
                            	   253: 
                            	   254:     ;clr.l   D1
                            	   255:     ;move.w  TRACK,D1
                            	   256:     ;add.l   #65,D1
                            	   257:     ;clr.l   D0
                            	   258:     ;jsr     CONOUT
                            	   259: 
                            	   260:     ;clr.l   D1
                            	   261:     ;move.w  SECTOR,D1
                            	   262:     ;add.l   #65,D1
                            	   263:     ;clr.l   D0
                            	   264:     ;jsr     CONOUT
                            	   265: 
00:00000106 7000            	   266:     clr.l  D0
00:00000108 303A0060        	   267:     move.w TRACK,D0
00:0000010C E188            	   268:     lsl.l  #8,D0
00:0000010E E988            	   269:     lsl.l  #4,D0
00:00000110 7400            	   270:     clr.l  D2
00:00000112 343A0058        	   271:     move.w SECTOR,D2
00:00000116 EF8A            	   272:     lsl.l  #7,D2
00:00000118 D082            	   273:     add.l  D2,D0
00:0000011A D0BC000C0000    	   274:     add.l  #$C0000,D0                    ; add base address of RAM drive
00:00000120 2040            	   275:     move.l D0,A0                         ; point to the track/sector in RAM drive
00:00000122 227A004A        	   276:     move.l DMA,A1                        ; get dma
00:00000126 343C001F        	   277:     move.w #(128/4)-1,D2                 ; long word move 128 bytes of sector data
00:0000012A 4E75            	   278:     rts
                            	   279: 
                            	   280: WRITE:
                            	   281: ; Write one sector to requested disk, track, sector from dma address
                            	   282: ; Both drive A & B are RAM drive
                            	   283:     ;cmp.b  #2,SELDRV                     ; only drive C can be written
                            	   284:     ;bne    WRBAD
00:0000012C 61D8            	   285:     bsr    SETUPRD                       ; translate track/sector values into RAM loc
                            	   286: RAMDRVW:
00:0000012E 20D9            	   287:     move.l (A1)+,(A0)+
00:00000130 51CAFFFC        	   288:     dbra   D2,RAMDRVW
                            	   289: 
00:00000134 7000            	   290:     clr.l  D0
00:00000136 4E75            	   291:     rts         
                            	   292: WRBAD:
00:00000138 70FF            	   293:     move.l #-1,D0
00:0000013A 4E75            	   294:     rts
                            	   295: 
                            	   296: FLUSH:
00:0000013C 7000            	   297:     clr.l  D0                            ; return successful
00:0000013E 4E75            	   298:     rts
                            	   299: 
                            	   300: GETSEG:
00:00000140 203C00000174    	   301:     move.l #MEMRGN,D0                    ; return address of mem region table
00:00000146 4E75            	   302:     rts
                            	   303: 
                            	   304: SETEXC:
00:00000148 0281000000FF    	   305:     andi.l  #$ff,D1                      ; do only for exceptions 0 - 255
00:0000014E 0C41002F        	   306:     cmpi    #47,D1
00:00000152 670E            	   307:     beq     NOSET                        ; this BIOS doesn't set Trap 15
00:00000154 0C410009        	   308:     cmpi    #9,D1                        ; or Trace
00:00000158 6708            	   309:     beq     NOSET
00:0000015A E549            	   310:     lsl     #2,D1                        ; multiply exception nmbr by 4
00:0000015C 2041            	   311:     movea.l D1,A0
00:0000015E 2010            	   312:     move.l  (A0),D0                      ; return old vector value
00:00000160 2082            	   313:     move.l  D2,(A0)                      ; insert new vector
                            	   314: 
                            	   315: NOSET:    
00:00000162 4E75            	   316:     rts
                            	   317: 
                            	   318: * ************************************************************************** *
                            	   319: ; Data
                            	   320: * ************************************************************************** *
                            	   321: 
                            	   322:               even                       ; DMA must be at even address
00:00000164 FF              	   323: SELDRV        dc.b        $ff            ; drive requested by seldsk
00:00000165 00              	   324: RESV          dc.b        0              ; reserve byte, padding
00:00000166 FFFFFFFF        	   325: CURCFSECT     dc.l        -1             ; current CF sector, the 512 bytes data of curtrk is in sectCF
00:0000016A 0000            	   326: TRACK         dc.w        0              ; track requested by settrk
00:0000016C 0000            	   327: SECTOR        dc.w        0              ; max sector value is 0x3FF
00:0000016E 00000000        	   328: DMA           dc.l        0
00:00000172 00              	   329: SELCODE       dc.b        0              ; reserve byte
00:00000173 00              	   330: RESV1         dc.b        0              ; reserve byte, padding
                            	   331: 
                            	   332: ; memory table must start on an even address
                            	   333:               even
00:00000174 0001            	   334: MEMRGN        dc.w        1              ; 1 memory region
00:00000176 00020000        	   335:               dc.l        $20000         ; after the CP/M 
00:0000017A 000A0000        	   336: 			  dc.l        $A0000         ; 524K bytes, more than enough for bootstrapping  
                            	   337: 
                            	   338: ; disk parameter header
                            	   339: DPH0:    
00:0000017E 00000000        	   340:     dc.l      0                          ; no sector translation table
00:00000182 0000            	   341:     dc.w      0                          ; dummy
00:00000184 0000            	   342:     dc.w      0
00:00000186 0000            	   343:     dc.w      0
00:00000188 000001A8        	   344:     dc.l      DIRBUF                     ; ptr to directory buffer
00:0000018C 00000198        	   345:     dc.l      DPB0                       ; ptr to disk parameter block
00:00000190 00000000        	   346:     dc.l      0                          ; permanent drive, no check vector
00:00000194 00000228        	   347:     dc.l      ALV0                       ; ptr to allocation vector
                            	   348: 
                            	   349: DPB0:    
00:00000198 0020            	   350:     dc.w     32                          ; 32 sectors per track
00:0000019A 04              	   351:     dc.b     4                           ; block shift for BLS of 2048
00:0000019B 0F              	   352:     dc.b     15                          ; block mask for BLS of 2048
00:0000019C 00              	   353:     dc.b     0                           ; extent mask, EXM
00:0000019D 00              	   354:     dc.b     0                           ; dummy fill
00:0000019E 07FF            	   355:     dc.w     2047                        ; DSM, (3 tracks * 1024 sectors * 128 bytes /2048)-1
                            	   356:                            
00:000001A0 00FF            	   357:     dc.w     255                         ; DRM, 256 directory entries
00:000001A2 0000            	   358:     dc.w     0                           ; directory mask
00:000001A4 0000            	   359:     dc.w     0                           ; permanent mounted drive, check size is zero
00:000001A6 0000            	   360:     dc.w     0                           ; no track offset
                            	   361: 
                            	   362: ;diskdef 4mb-hd-0
                            	   363: ;  seclen 128
                            	   364: ;  tracks 1024
                            	   365: ;  sectrk 32
                            	   366: ;  blocksize 2048
                            	   367: ;  maxdir 256
                            	   368: ;  skew 1
                            	   369: ;  boottrk 0
                            	   370: ;  os 2.2
                            	   371: ;end
                            	   372: 
                            	   373: DIRBUF:    
00:000001A8 00              	   374:     ds.b     128                         ; directory buffer
00:000001A9 *
                            	   375: 
                            	   376: ALV0:    
00:00000228 00              	   377: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:00000229 *
                            	   378: 
                            	   379: msgNoSdCardSupport:
00:00000328 6572726F723A204E	   380:     dc.b     "error: No SD card support detected",0
00:00000330 6F20534420636172
00:00000338 6420737570706F72
00:00000340 7420646574656374
00:00000348 6564
00:0000034A 00
                            	   381: 
                            	   382: msgNoSdCardInit:
00:0000034B 6572726F723A2055	   383:     dc.b     "error: Unable to initialize SD card",0
00:00000353 6E61626C6520746F
00:0000035B 20696E697469616C
00:00000363 697A652053442063
00:0000036B 617264
00:0000036E 00
                            	   384: 
                            	   385: msgNoSdCardRead:
00:0000036F 6572726F723A2055	   386:     dc.b     "error: Unable to read SD card",0
00:00000377 6E61626C6520746F
00:0000037F 2072656164205344
00:00000387 2063617264
00:0000038C 00
                            	   387: 
                            	   388: strPath:
00:0000038D 6469736B312E696D	   389:     dc.b     "disk1.img",0               ; needs to be a path not a filename (leading /)
00:00000395 67
00:00000396 00
                            	   390: 
                            	   391: sdBuf:    
00:00000397 00              	   392: 	ds.b     512                         ; buffer to read/write sectors to sd card
00:00000398 *
                            	   393: 
                            	   394: sd:
00:00000597 00              	   395:     ds.b     64                          ; needs to be large enough to hold a sd card structure
00:00000598 *


Symbols by name:
ALV0                            00:00000228
BIOSBASE                        00:0000003E
CONIN                           00:000000AA
CONOUT                          00:000000B8
CONSTAT                         00:000000A0
CURCFSECT                       00:00000166
DIRBUF                          00:000001A8
DMA                             00:0000016E
DPB0                            00:00000198
DPH0                            00:0000017E
FLUSH                           00:0000013C
GETIOB                          00:000000BE
GETSEG                          00:00000140
HOME                            00:000000C8
LISTST                          00:000000C2
LSTOUT                          00:000000BE
MEMRGN                          00:00000174
NOSET                           00:00000162
PUN                             00:000000BE
RAMDRVR                         00:000000FC
RAMDRVW                         00:0000012E
RDR                             00:000000BE
READ                            00:000000FA
RESV                            00:00000165
RESV1                           00:00000173
SECTOR                          00:0000016C
SECTRAN                         00:000000EE
SELCODE                         00:00000172
SELDRV                          00:00000164
SELDSK                          00:000000D0
SETDMA                          00:000000F2
SETEXC                          00:00000148
SETIOB                          00:000000BE
SETSEC                          00:000000E6
SETTRK                          00:000000DE
SETUPRD                         00:00000106
TRACK                           00:0000016A
TRAPHNDL                        00:0000002C
TRAPNG                          00:0000003C
WBOOT                           00:0000009A
WRBAD                           00:00000138
WRITE                           00:0000012C
_ccp                             E:000150BC
_init                           00:00000000 EXP
g                               00:0000002A
msgNoSdCardInit                 00:0000034B
msgNoSdCardRead                 00:0000036F
msgNoSdCardSupport              00:00000328
sd                              00:00000597
sdBuf                           00:00000397
strPath                         00:0000038D

Symbols by value:
00000000 _init
0000002A g
0000002C TRAPHNDL
0000003C TRAPNG
0000003E BIOSBASE
0000009A WBOOT
000000A0 CONSTAT
000000AA CONIN
000000B8 CONOUT
000000BE LSTOUT
000000BE SETIOB
000000BE RDR
000000BE PUN
000000BE GETIOB
000000C2 LISTST
000000C8 HOME
000000D0 SELDSK
000000DE SETTRK
000000E6 SETSEC
000000EE SECTRAN
000000F2 SETDMA
000000FA READ
000000FC RAMDRVR
00000106 SETUPRD
0000012C WRITE
0000012E RAMDRVW
00000138 WRBAD
0000013C FLUSH
00000140 GETSEG
00000148 SETEXC
00000162 NOSET
00000164 SELDRV
00000165 RESV
00000166 CURCFSECT
0000016A TRACK
0000016C SECTOR
0000016E DMA
00000172 SELCODE
00000173 RESV1
00000174 MEMRGN
0000017E DPH0
00000198 DPB0
000001A8 DIRBUF
00000228 ALV0
00000328 msgNoSdCardSupport
0000034B msgNoSdCardInit
0000036F msgNoSdCardRead
0000038D strPath
00000397 sdBuf
00000597 sd
000150BC _ccp
