Sections:
00: "seg1b000" (1B000-1B586)


Source: "bios.asm"
                            	     1: ; Very simple cpm68k bios
                            	     2: ; Malcolm Harrow August 2023
                            	     3: 
                            	     4: ; TO DO
                            	     5: ; Change start positions of ram disks in read
                            	     6: ; sort out org instruction
                            	     7: ; Change MEMRGN
                            	     8: ; Change disk parameter tables
                            	     9: 
                            	    10: 
                            	    11: ; 7/29/17, fork from rev 3 of TinyBIOS for Tiny68000
                            	    12: ; This BIOS assumes CPM15000 will be loaded
                            	    13: ; It also assume the disk is reside in flash from location $420000 to $5FFFFF
                            	    14: ; The disk already contains CP/M 68K distribution files
                            	    15: 
                            	    16: 
                            	    17: _ccp     equ $150BC                     ; hard location for _ccp of CPM15000.SR
                            	    18:          org $1B000                     ; this is the hard location for _init for CPM15000.SR
                            	    19: 
                            	    20: _init::    
00:0001B000 21FC0001B012008C	    21:     move.l  #TRAPHNDL,$8c               ; set up trap #3 handler
00:0001B008 7000            	    22:     clr.l   D0                          ; log on disk A, user 0
                            	    23: 
00:0001B00A 7241            	    24:     move.l  #65,D1
00:0001B00C 61000098        	    25:     jsr     CONOUT
00:0001B010 4E75            	    26:     rts
                            	    27: 
                            	    28: TRAPHNDL:
00:0001B012 0C400016        	    29:     cmpi    #22,D0                      ; Function call in range ?
00:0001B016 640A            	    30:     bcc     TRAPNG
00:0001B018 D080            	    31:     add.l   D0,D0                       ; Multiply FC...
00:0001B01A D080            	    32:     add.l   D0,D0                       ; ... by 4...
00:0001B01C 207B0006        	    33:     move.l  BIOSBASE(PC,D0),A0          ; ... and calc offset into table...
00:0001B020 4ED0            	    34:     jmp     (A0)                        ; ... then jump there
                            	    35: 
                            	    36: TRAPNG:
00:0001B022 4E73            	    37:     rte
                            	    38: 
                            	    39: BIOSBASE:
00:0001B024 0001B000        	    40:     dc.l    _init
00:0001B028 0001B080        	    41:     dc.l    WBOOT
00:0001B02C 0001B084        	    42:     dc.l    CONSTAT
00:0001B030 0001B090        	    43:     dc.l    CONIN
00:0001B034 0001B0A6        	    44:     dc.l    CONOUT
00:0001B038 0001B0AE        	    45:     dc.l    LSTOUT
00:0001B03C 0001B0AE        	    46:     dc.l    PUN
00:0001B040 0001B0AE        	    47:     dc.l    RDR
00:0001B044 0001B0B6        	    48:     dc.l    HOME
00:0001B048 0001B0BE        	    49:     dc.l    SELDSK
00:0001B04C 0001B0DC        	    50:     dc.l    SETTRK
00:0001B050 0001B0E4        	    51:     dc.l    SETSEC
00:0001B054 0001B0F0        	    52:     dc.l    SETDMA
00:0001B058 0001B0F8        	    53:     dc.l    READ
00:0001B05C 0001B128        	    54:     dc.l    WRITE
00:0001B060 0001B0B0        	    55:     dc.l    LISTST
00:0001B064 0001B0EC        	    56:     dc.l    SECTRAN
00:0001B068 0001B0F0        	    57:     dc.l    SETDMA
00:0001B06C 0001B146        	    58:     dc.l    GETSEG
00:0001B070 0001B14E        	    59:     dc.l    GETIOB
00:0001B074 0001B150        	    60:     dc.l    SETIOB
00:0001B078 0001B142        	    61:     dc.l    FLUSH
00:0001B07C 0001B152        	    62:     dc.l    SETEXC
                            	    63: 
                            	    64: 
                            	    65: WBOOT:  
00:0001B080 6000A03A        	    66:     jmp   _ccp
                            	    67: 
                            	    68: CONSTAT: 
                            	    69: ; Check for keyboard input. Set d0 to 1 if keyboard input is pending, otherwise set to 0.
00:0001B084 103C0007        	    70:     move.b #7,D0                        ; use EASy68k trap 15 task 7
00:0001B088 4E4F            	    71:     trap   #15                          ; d1.b = 1 if keyboard ready, otherwise = 0
00:0001B08A 7000            	    72:     clr.l  D0
00:0001B08C 1001            	    73:     move.b D1,D0
00:0001B08E 4E75            	    74:     rts
                            	    75:          
                            	    76: CONIN:    
                            	    77: ; Read single ASCII character from the keyboard into d0
00:0001B090 61F2            	    78:     bsr    CONSTAT                      ; see if key pressed
00:0001B092 4A40            	    79:     tst    D0
00:0001B094 67FA            	    80:     beq    CONIN
00:0001B096 103C0005        	    81:     move.b #5,D0                        ; use EASy68k trap 15 task 5
00:0001B09A 4E4F            	    82:     trap   #15                          ; d1.b contains the ascii character
00:0001B09C 1001            	    83:     move.b D1,D0      
00:0001B09E C0BC0000007F    	    84:     and.l  #$7f,D0                      ; only use 7 bit character set
00:0001B0A4 4E75            	    85:     rts
                            	    86: 
                            	    87: CONOUT: 
                            	    88: ; Display single ASCII character in d1
00:0001B0A6 103C0006        	    89:     move.b #6,D0                        ; use EASy68k trap 15 task 6
00:0001B0AA 4E4F            	    90:     trap   #15
00:0001B0AC 4E75            	    91:     rts                                 ; and exit
                            	    92: 
                            	    93: LSTOUT:    
                            	    94: PUN:
                            	    95: RDR:
00:0001B0AE 4E75            	    96:     rts
                            	    97: 
                            	    98: LISTST:    
00:0001B0B0 103C00FF        	    99:     move.b #$ff,D0
00:0001B0B4 4E75            	   100:     rts
                            	   101: 
                            	   102: MAXDSK     equ 3                         ; three RAM drives
                            	   103: DPHLEN     equ 26                        ; length of disk parameter header
                            	   104: 
                            	   105: HOME:    
00:0001B0B6 42390001B174    	   106:     clr.b  TRACK
00:0001B0BC 4E75            	   107:     rts
                            	   108: 
                            	   109: SELDSK:    
                            	   110: ;    select disk given by register d1.b
00:0001B0BE 7000            	   111:     moveq  #0,D0
00:0001B0C0 B23C0003        	   112:     cmp.b  #MAXDSK,D1                     ; valid drive number?
00:0001B0C4 6A14            	   113:     bpl    SELRTN                         ; if no, return 0 in d0
00:0001B0C6 13C10001B16E    	   114:     move.b D1,SELDRV                      ; else, save drive number
00:0001B0CC 103A00A0        	   115:     move.b SELDRV,D0
00:0001B0D0 C0FC001A        	   116:     mulu   #DPHLEN,D0
00:0001B0D4 D0BC0001B188    	   117:     add.l  #DPH0,D0                       ; point d0 at correct dph
                            	   118: 
                            	   119: SELRTN:
00:0001B0DA 4E75            	   120:     rts
                            	   121: 
                            	   122: SETTRK:    
00:0001B0DC 33C10001B174    	   123:     move.w  D1,TRACK
00:0001B0E2 4E75            	   124:     rts
                            	   125: 
                            	   126: SETSEC:    
00:0001B0E4 33C10001B176    	   127:     move.w  D1,SECTOR
00:0001B0EA 4E75            	   128:     rts
                            	   129: 
                            	   130: SECTRAN:
                            	   131: ;    no sector translate, put d1 into d0 and return
00:0001B0EC 3001            	   132:     move.w  D1,D0
00:0001B0EE 4E75            	   133:     rts
                            	   134: 
                            	   135: SETDMA:
00:0001B0F0 23C10001B178    	   136:     move.l  D1,DMA
00:0001B0F6 4E75            	   137:     rts
                            	   138: 
                            	   139: READ:
                            	   140: ; Read one sector from requested disk, track, sector to dma address
                            	   141: ; Both drive A, B & C are RAM drives
                            	   142: ; drive A starts from 0x420000 to 0x5BFFFF
                            	   143: ; drive B starts from 0xC0000 to 0xFFFFF
                            	   144: 
                            	   145: 
00:0001B0F8 610A            	   146:     bsr     SETUPRD                      ; translate track/sector values into RAM loc
                            	   147: RAMDRVR:
00:0001B0FA 22D8            	   148:     move.l (A0)+,(A1)+
00:0001B0FC 51CAFFFC        	   149:     dbra   D2,RAMDRVR
                            	   150: 
00:0001B100 7000            	   151:     clr.l  D0                            ; return OK status         
00:0001B102 4E75            	   152:     rts         
                            	   153: 
                            	   154: SETUPRD:
                            	   155: ; translate track/sector into RAM location on the RAM drive
00:0001B104 203A006E        	   156:     move.l TRACK,D0                      ; get track & sector values
00:0001B108 ED48            	   157:     lsl.w  #6,D0                         ; multiply by 64
00:0001B10A E388            	   158:     lsl.l  #1,D0                         ; multiply the track/sector by 128 to index into RAM
00:0001B10C 0C3900020001B16E	   159:     cmp.b  #2,SELDRV                     ; drive C is RAM drive
00:0001B114 6706            	   160:     beq    RAMDRV
                            	   161: ; now have one drive starting at 0x20000
                            	   162: ;    add.l  #$420000,D0                   ; add base address of RAM drive
00:0001B116 D0BC00020000    	   163:     add.l  #$20000,D0                   ; add base address of RAM drive
                            	   164:     bra    GETDATA
                            	   165: 
                            	   166: RAMDRV:
                            	   167: ; no drive C
                            	   168: ;    add.l  #$C0000,D0
                            	   169: 
                            	   170: GETDATA:
00:0001B11C 2040            	   171:     move.l D0,A0                         ; point to the track/sector in RAM drive
00:0001B11E 227A0058        	   172:     move.l DMA,A1                        ; get dma
00:0001B122 343C001F        	   173:     move.w #(128/4)-1,D2                 ; long word move 128 bytes of sector data
00:0001B126 4E75            	   174:     rts
                            	   175: 
                            	   176: WRITE:
                            	   177: ; Write one sector to requested disk, track, sector from dma address
                            	   178: ; Both drive A & B are RAM drive
00:0001B128 0C3900020001B16E	   179:     cmp.b  #2,SELDRV                     ; only drive C can be written
00:0001B130 660C            	   180:     bne    WRBAD
00:0001B132 61D0            	   181:     bsr    SETUPRD                       ; translate track/sector values into RAM loc
                            	   182: RAMDRVW:
00:0001B134 20D9            	   183:     move.l (A1)+,(A0)+
00:0001B136 51CAFFFC        	   184:     dbra   D2,RAMDRVW
                            	   185: 
00:0001B13A 7000            	   186:     clr.l  D0
00:0001B13C 4E75            	   187:     rts         
                            	   188: WRBAD:
00:0001B13E 70FF            	   189:     move.l #-1,D0
00:0001B140 4E75            	   190:     rts
                            	   191: 
                            	   192: FLUSH:
00:0001B142 7000            	   193:     clr.l  D0                            ; return successful
00:0001B144 4E75            	   194:     rts
                            	   195: 
                            	   196: GETSEG:
00:0001B146 203C0001B17E    	   197:     move.l #MEMRGN,D0                    ; return address of mem region table
00:0001B14C 4E75            	   198:     rts
                            	   199: 
                            	   200: GETIOB:
00:0001B14E 4E75            	   201:     rts
                            	   202: 
                            	   203: SETIOB:
00:0001B150 4E75            	   204:     rts
                            	   205: 
                            	   206: SETEXC:
00:0001B152 0281000000FF    	   207:     andi.l  #$ff,D1                      ; do only for exceptions 0 - 255
00:0001B158 0C41002F        	   208:     cmpi    #47,D1
00:0001B15C 670E            	   209:     beq     NOSET                        ; this BIOS doesn't set Trap 15
00:0001B15E 0C410009        	   210:     cmpi    #9,D1                        ; or Trace
00:0001B162 6708            	   211:     beq     NOSET
00:0001B164 E549            	   212:     lsl     #2,D1                        ; multiply exception nmbr by 4
00:0001B166 2041            	   213:     movea.l D1,A0
00:0001B168 2010            	   214:     move.l  (A0),D0                      ; return old vector value
00:0001B16A 2082            	   215:     move.l  D2,(A0)                      ; insert new vector
                            	   216: 
                            	   217: NOSET:    
00:0001B16C 4E75            	   218:     rts
                            	   219: 
                            	   220: * ************************************************************************** *
                            	   221: ; Data
                            	   222: * ************************************************************************** *
                            	   223: 
00:0001B16E FF              	   224: SELDRV        dc.b        $ff            ; drive requested by seldsk
00:0001B16F 00              	   225: RESV          dc.b        0              ; reserve byte, padding
00:0001B170 FFFFFFFF        	   226: CURCFSECT     dc.l        -1             ; current CF sector, the 512 bytes data of curtrk is in sectCF
00:0001B174 0000            	   227: TRACK         dc.w        0              ; track requested by settrk
00:0001B176 0000            	   228: SECTOR        dc.w        0              ; max sector value is 0x3FF
00:0001B178 00000000        	   229: DMA           dc.l        0
00:0001B17C 00              	   230: SELCODE       dc.b        0              ; reserve byte
00:0001B17D 00              	   231: RESV1         dc.b        0              ; reserve byte, padding
                            	   232: 
00:0001B17E 0001            	   233: MEMRGN        dc.w        1              ; 1 memory region
                            	   234: ;              dc.l        $20000         ; right after the CP/M 
00:0001B180 00090000        	   235:               dc.l        $90000         ; right after the CP/M 
00:0001B184 00040000        	   236:               dc.l        $40000         ; goes until $60000, 256K bytes
                            	   237: ;			  dc.l        $A0000         ; goes until $C0000, 655K bytes  
                            	   238: 
                            	   239: ; disk parameter headers
                            	   240: 
                            	   241: DPH0:    
00:0001B188 00000000        	   242:     dc.l      0                          ; no sector translation table
00:0001B18C 0000            	   243:     dc.w      0                          ; dummy
00:0001B18E 0000            	   244:     dc.w      0
00:0001B190 0000            	   245:     dc.w      0
00:0001B192 0001B206        	   246:     dc.l      DIRBUF                     ; ptr to directory buffer
00:0001B196 0001B1D6        	   247:     dc.l      DPB0                       ; ptr to disk parameter block
00:0001B19A 00000000        	   248:     dc.l      0                          ; permanent drive, no check vector
00:0001B19E 0001B286        	   249:     dc.l      ALV0                       ; ptr to allocation vector
                            	   250: 
                            	   251: DPH1:
00:0001B1A2 00000000        	   252:     dc.l     0                           ; no sector translation table
00:0001B1A6 0000            	   253:     dc.w     0                           ; dummy
00:0001B1A8 0000            	   254:     dc.w     0
00:0001B1AA 0000            	   255:     dc.w     0
00:0001B1AC 0001B206        	   256:     dc.l     DIRBUF                      ; ptr to directory buffer
00:0001B1B0 0001B1E6        	   257:     dc.l     DPB1                        ; ptr to disk parameter block
00:0001B1B4 00000000        	   258:     dc.l     0                           ; permanent drive, no check vector
00:0001B1B8 0001B386        	   259:     dc.l     ALV1                        ; ptr to allocation vector
                            	   260: 
                            	   261: DPH2:
00:0001B1BC 00000000        	   262:     dc.l     0                           ; no sector translation table
00:0001B1C0 0000            	   263:     dc.w     0                           ; dummy
00:0001B1C2 0000            	   264:     dc.w     0
00:0001B1C4 0000            	   265:     dc.w     0
00:0001B1C6 0001B206        	   266:     dc.l     DIRBUF                      ; ptr to directory buffer
00:0001B1CA 0001B1F6        	   267:     dc.l     DPB2                        ; ptr to disk parameter block
00:0001B1CE 00000000        	   268:     dc.l     0                           ; permanent drive, no check vector
00:0001B1D2 0001B486        	   269:     dc.l     ALV2                        ; ptr to allocation vector
                            	   270: 
                            	   271: ; disk parameter block
                            	   272: ; flash drive from $420000 to 59FFFF,
                            	   273: ; choose a BLS of 2048
                            	   274: ; 1024 sectors (128 byte sector) per track
                            	   275: ; 16 sectors per block
                            	   276: ; 12 tracks per drive 
                            	   277: ; DPB0:    
                            	   278: ;     dc.w     1024                        ; 1024 sectors per track
                            	   279: ;     dc.b     4                           ; block shift for BLS of 2048
                            	   280: ;     dc.b     15                          ; block mask for BLS of 2048
                            	   281: ;     dc.b     0                           ; extent mask, EXM
                            	   282: ;     dc.b     0                           ; dummy fill
                            	   283: ;     dc.w     767                         ; DSM, (12 tracks * 1024 sectors * 128 bytes /2048)-1
                            	   284:                            
                            	   285: ;     dc.w     255                         ; DRM, 256 directory entries
                            	   286: ;     dc.w     0                           ; directory mask
                            	   287: ; 	dc.w     0                           ; permanent mounted drive, check size is zero
                            	   288: ;     dc.w     0                           ; no track offset
                            	   289: 
                            	   290: ; hack in a drive 0 that looked like old drive 1
                            	   291: DPB0:    
00:0001B1D6 0400            	   292:     dc.w     1024                        ; 1024 sectors per track
00:0001B1D8 04              	   293:     dc.b     4                           ; block shift for BLS of 2048
00:0001B1D9 0F              	   294:     dc.b     15                          ; block mask for BLS of 2048
00:0001B1DA 00              	   295:     dc.b     0                           ; extent mask, EXM
00:0001B1DB 00              	   296:     dc.b     0                           ; dummy fill
00:0001B1DC 00BF            	   297:     dc.w     191                         ; DSM, (3 tracks * 1024 sectors * 128 bytes /2048)-1
                            	   298:                            
00:0001B1DE 00FF            	   299:     dc.w     255                         ; DRM, 256 directory entries
00:0001B1E0 0000            	   300:     dc.w     0                           ; directory mask
00:0001B1E2 0000            	   301:     dc.w     0                           ; permanent mounted drive, check size is zero
00:0001B1E4 000C            	   302:     dc.w     12                          ; no track offset
                            	   303: 
                            	   304: 
                            	   305: ; flash drive from $5A0000 to $5FFFFF
                            	   306: ; choose a BLS of 2048
                            	   307: ; 1024 sectors (128 byte sector) per track
                            	   308: ; 16 sectors per block
                            	   309: ; 3 tracks per drive 
                            	   310: DPB1:    
00:0001B1E6 0400            	   311:     dc.w     1024                        ; 1024 sectors per track
00:0001B1E8 04              	   312:     dc.b     4                           ; block shift for BLS of 2048
00:0001B1E9 0F              	   313:     dc.b     15                          ; block mask for BLS of 2048
00:0001B1EA 00              	   314:     dc.b     0                           ; extent mask, EXM
00:0001B1EB 00              	   315:     dc.b     0                           ; dummy fill
00:0001B1EC 00BF            	   316:     dc.w     191                         ; DSM, (3 tracks * 1024 sectors * 128 bytes /2048)-1
                            	   317:                            
00:0001B1EE 00FF            	   318:     dc.w     255                         ; DRM, 256 directory entries
00:0001B1F0 0000            	   319:     dc.w     0                           ; directory mask
00:0001B1F2 0000            	   320:     dc.w     0                           ; permanent mounted drive, check size is zero
00:0001B1F4 000C            	   321:     dc.w     12                          ; no track offset
                            	   322:          
                            	   323: ; use the battery-back RAM in ADC MPU as small RAMdisk, $C0000-$FFFFF
                            	   324: ; disk parameter block
                            	   325: ; choose a BLS of 1024
                            	   326: ; 1024 sectors (128 byte sector) per track
                            	   327: ; 8 sectors per block
                            	   328: ; 2 tracks per drive 
                            	   329: DPB2:    
00:0001B1F6 0400            	   330:     dc.w     1024                        ; 1024 sectors per track
00:0001B1F8 03              	   331:     dc.b     3                           ; block shift for BLS of 1024
00:0001B1F9 07              	   332:     dc.b     7                           ; block mask for BLS of 1024
00:0001B1FA 00              	   333:     dc.b     0                           ; extent mask, EXM
00:0001B1FB 00              	   334:     dc.b     0                           ; dummy fill
00:0001B1FC 00FF            	   335:     dc.w     255                         ; DSM, (2 tracks * 1024 sectors * 128 bytes /2048)-1
                            	   336: ; force the block number to be words rather than bytes                           
00:0001B1FE 007F            	   337:     dc.w     127                         ; DRM, 128 directory entries
00:0001B200 0000            	   338:     dc.w     0                           ; directory mask
00:0001B202 0000            	   339:     dc.w     0                           ; permanent mounted drive, check size is zero
00:0001B204 0000            	   340:     dc.w     0                           ; no track offset
                            	   341: 
                            	   342: **X    .bss
                            	   343: 
                            	   344: DIRBUF:    
00:0001B206 00              	   345:     ds.b     128                         ; directory buffer
00:0001B207 *
                            	   346: 
                            	   347: ALV0:    
00:0001B286 00              	   348: 	ds.b     256                         ; allocation vector, DSM/8+1 = 128
00:0001B287 *
                            	   349: ALV1:    
00:0001B386 00              	   350: 	ds.b     256                         ; DSM/8 +1 = 128, round up to 256
00:0001B387 *
                            	   351: ALV2:    
00:0001B486 00              	   352: 	ds.b     256                         ; DSM/8 +1 = 128, round up to 256
00:0001B487 *
                            	   353: 


Symbols by name:
ALV0                             A:0001B286
ALV1                             A:0001B386
ALV2                             A:0001B486
BIOSBASE                         A:0001B024
CONIN                            A:0001B090
CONOUT                           A:0001B0A6
CONSTAT                          A:0001B084
CURCFSECT                        A:0001B170
DIRBUF                           A:0001B206
DMA                              A:0001B178
DPB0                             A:0001B1D6
DPB1                             A:0001B1E6
DPB2                             A:0001B1F6
DPH0                             A:0001B188
DPH1                             A:0001B1A2
DPH2                             A:0001B1BC
DPHLEN                           E:0000001A
FLUSH                            A:0001B142
GETDATA                          A:0001B11C
GETIOB                           A:0001B14E
GETSEG                           A:0001B146
HOME                             A:0001B0B6
LISTST                           A:0001B0B0
LSTOUT                           A:0001B0AE
MAXDSK                           E:00000003
MEMRGN                           A:0001B17E
NOSET                            A:0001B16C
PUN                              A:0001B0AE
RAMDRV                           A:0001B11C
RAMDRVR                          A:0001B0FA
RAMDRVW                          A:0001B134
RDR                              A:0001B0AE
READ                             A:0001B0F8
RESV                             A:0001B16F
RESV1                            A:0001B17D
SECTOR                           A:0001B176
SECTRAN                          A:0001B0EC
SELCODE                          A:0001B17C
SELDRV                           A:0001B16E
SELDSK                           A:0001B0BE
SELRTN                           A:0001B0DA
SETDMA                           A:0001B0F0
SETEXC                           A:0001B152
SETIOB                           A:0001B150
SETSEC                           A:0001B0E4
SETTRK                           A:0001B0DC
SETUPRD                          A:0001B104
TRACK                            A:0001B174
TRAPHNDL                         A:0001B012
TRAPNG                           A:0001B022
WBOOT                            A:0001B080
WRBAD                            A:0001B13E
WRITE                            A:0001B128
_ccp                             E:000150BC
_init                            A:0001B000 EXP

Symbols by value:
00000003 MAXDSK
0000001A DPHLEN
000150BC _ccp
0001B000 _init
0001B012 TRAPHNDL
0001B022 TRAPNG
0001B024 BIOSBASE
0001B080 WBOOT
0001B084 CONSTAT
0001B090 CONIN
0001B0A6 CONOUT
0001B0AE RDR
0001B0AE PUN
0001B0AE LSTOUT
0001B0B0 LISTST
0001B0B6 HOME
0001B0BE SELDSK
0001B0DA SELRTN
0001B0DC SETTRK
0001B0E4 SETSEC
0001B0EC SECTRAN
0001B0F0 SETDMA
0001B0F8 READ
0001B0FA RAMDRVR
0001B104 SETUPRD
0001B11C GETDATA
0001B11C RAMDRV
0001B128 WRITE
0001B134 RAMDRVW
0001B13E WRBAD
0001B142 FLUSH
0001B146 GETSEG
0001B14E GETIOB
0001B150 SETIOB
0001B152 SETEXC
0001B16C NOSET
0001B16E SELDRV
0001B16F RESV
0001B170 CURCFSECT
0001B174 TRACK
0001B176 SECTOR
0001B178 DMA
0001B17C SELCODE
0001B17D RESV1
0001B17E MEMRGN
0001B188 DPH0
0001B1A2 DPH1
0001B1BC DPH2
0001B1D6 DPB0
0001B1E6 DPB1
0001B1F6 DPB2
0001B206 DIRBUF
0001B286 ALV0
0001B386 ALV1
0001B486 ALV2
